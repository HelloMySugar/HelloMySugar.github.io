{"meta":{"title":"Root's Blog","subtitle":null,"description":null,"author":"Root","url":"https://tangyanqiong.com","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-04-30T11:21:24.170Z","updated":"2019-05-24T08:41:03.000Z","comments":true,"path":"404.html","permalink":"https://tangyanqiong.com/404.html","excerpt":"","text":"404 Not Found 很抱歉，您访问的页面不存在您可以留言告诉我哪个页面找不到，谢谢您的提议！"},{"title":"关于我","date":"2018-03-18T06:22:35.000Z","updated":"2019-07-26T08:31:54.000Z","comments":true,"path":"about/index.html","permalink":"https://tangyanqiong.com/about/index.html","excerpt":"","text":"自我介绍我大学其实学的是通信工程，大学时期，一次机缘巧合看到土豪朋友在玩iPhone 3GS，天啦，在那个还是手机键盘咔咔敲的年代，突然一个全触屏的科技性手机迅速吸引了我的眼球。大学毕业后看到有公司招iPhone开发实习生，被iPhone影响深刻的我，毫不犹豫的加入了，成为了一名iOS开发攻城师，目前也在搞Web开发和学习小程序开发。我平时其实是一个比较闷的人，喜欢看美剧、旅游、玩游戏，爱好美食。 共勉所谓技多不压身，在互联网这个更新迭代非常迅速的时代，只有不断的提升自己来与时俱进，避免被淘汰，且职场上女性更容易被歧视，其实很不想讲出这样的话，但目前的大环境来说，特别是IT行业，程序员的保鲜程度就在20-35岁，特别对女程序员相关条件更是苛刻。 So，无论你是程序猿还是程序媛，希望我们都能在互联网这个行业继续艰苦的摸爬滚打，无论你是被生活压弯了腰还是兴趣所向在这条路上，希望你一切都好，继续努力，为了你爱的人和爱你的人！ 共勉之有话要说小伙伴你们是怎么进入到互联网的行业呢，是各种机缘巧合还是兴趣所向呢，动动你发财的小手，在评论区告诉我吧，哈哈。"},{"title":"归档","date":"2018-02-20T03:44:04.000Z","updated":"2019-07-26T08:31:48.000Z","comments":true,"path":"archives/index.html","permalink":"https://tangyanqiong.com/archives/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2018-02-23T03:43:30.000Z","updated":"2019-07-26T08:43:38.000Z","comments":true,"path":"categories/index.html","permalink":"https://tangyanqiong.com/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2018-02-24T03:43:12.000Z","updated":"2019-07-26T08:31:37.000Z","comments":true,"path":"tags/index.html","permalink":"https://tangyanqiong.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"浏览器输入url到页面渲染过程","slug":"浏览器渲染过程","date":"2020-08-28T11:05:33.000Z","updated":"2022-07-22T13:13:55.316Z","comments":true,"path":"post/7429757f.html","link":"","permalink":"https://tangyanqiong.com/post/7429757f.html","excerpt":"背景相信很多人都会被面试到一道比较综合的面试题，答案也不是固定的，从浏览器输入地址到页面渲染经过了很多的过程，且每个过程都可以深挖出很多知识点，面试官可以用这一道题区分出不同面试者的水平。下面我们就来具体学习下。 构建请求 1GET/HTTP/1.1;","text":"背景相信很多人都会被面试到一道比较综合的面试题，答案也不是固定的，从浏览器输入地址到页面渲染经过了很多的过程，且每个过程都可以深挖出很多知识点，面试官可以用这一道题区分出不同面试者的水平。下面我们就来具体学习下。 构建请求 1GET/HTTP/1.1; 过程查找强缓存浏览器会先检查是否存在缓存，如果存在缓存就直接从缓存里面拿数据，给到浏览器进行渲染 DNS 解析由于我们输入的是域名，而数据包是通过 IP 地址传给对方的。因此我们需要得到域名对应的 IP 地址。这个过程需要依赖一个服务系统，这个系统将域名和 IP 一一映射，我们将这个系统就叫做 DNS（域名系统）。得到具体 IP 的过程就是 DNS 解析。 当然，值得注意的是，浏览器提供了 DNS 数据缓存功能。即如果一个域名已经解析过，那会把解析的结果缓存下来，下次处理直接走缓存，不需要经过 DNS 解析 建立 TCP 连接建立 TCP 连接经历了下面三个阶段 通过三次握手(即总共发送 3 个数据包确认已经建立连接)建立客户端和服务器之间的连接。 进行数据传输。这里有一个重要的机制，就是接收方接收到数据包后必须要向发送方确认, 如果发送方没有接到这个确认的消息，就判定为数据包丢失，并重新发送该数据包。当然，发送的过程中还有一个优化策略，就是把大的数据包拆成一个个小包，依次传输到接收方，接收方按照这个小包的顺序把它们组装成完整数据包。 断开连接的阶段。数据传输完成，现在要断开连接了，通过四次挥手来断开连接。 TCP 就是通过三次握手确认连接，数据包校验保证数据到达接收方，然后通过四次挥手断开连接保证数据传输的可靠性 发送 HTTP 请求现在 TCP 连接建立完毕，浏览器可以和服务器开始通信，即开始发送 HTTP 请求。浏览器发 HTTP 请求要携带三样东西:请求行、请求头和请求体 网络响应HTTP 请求到达服务器，服务器进行对应的处理。最后要把数据传给浏览器，也就是返回网络响应。 响应头包含了服务器及其返回数据的一些信息, 服务器生成数据的时间、返回的数据类型以及对即将写入的 Cookie 信息。如果请求头或响应头中包含 Connection: Keep-Alive，表示建立了持久连接，这样 TCP 连接会一直保持，之后请求统一站点的资源会复用这个连接。 页面渲染完成以上过程后，数据已经达到浏览器端，接下来就是浏览器解析并渲染数据了 解析过程 构建 DOM 树 由于浏览器无法直接理解 HTML 字符串，因此将这一系列的字节流转换为一种有意义并且方便操作的数据结构，这种数据结构就是 DOM 树。DOM 树本质上是一个以 document 为根节点的多叉树 样式计算 首先，浏览器是无法直接识别 CSS 样式文本的，因此渲染引擎接收到 CSS 文本之后第一件事情就是将其转化为一个结构化的对象，即 styleSheets。 这个格式化的过程过于复杂，而且对于不同的浏览器会有不同的优化策略，这里就不展开了。 在浏览器控制台能够通过 document.styleSheets 来查看这个最终的结构。当然，这个结构包含了以上三种 CSS 来源，为后面的样式操作提供了基础。 生成布局树 现在已经生成了 DOM 树和 DOM 样式，接下来要做的就是通过浏览器的布局系统确定元素的位置，也就是要生成一棵布局树(Layout Tree)。 布局树生成的大致工作如下: 遍历生成的 DOM 树节点，并把他们添加到布局树中； 计算布局树节点的坐标位置。 值得注意的是，布局树只包含可见元素，对于 head 标签和设置了 display: none 的元素，将不会被放入其中。 渲染 构建 DOM 树 浏览器将 HTML 解析成树形结构的 DOM 树，一般来说，这个过程发生在页面初次加载，或页面 JavaScript 修改了节点结构的时候 构建渲染树 浏览器将 CSS 解析成树形结构的 CSSOM 树，再和 DOM 树合并成渲染树 布局（Layout） 浏览器根据渲染树所体现的节点、各个节点的 CSS 定义以及它们的从属关系，计算出每个节点在屏幕中的位置。Web 页面中元素的布局是相对的，在页面元素位置、大小发生变化，往往会导致其他节点联动，需要重新计算布局，这时候的布局过程一般被称为回流（Reflow）。 绘制（Paint） 遍历渲染树，调用渲染器的 paint() 方法在屏幕上绘制出节点内容，本质上是一个像素填充的过程。这个过程也出现于回流或一些不影响布局的 CSS 修改引起的屏幕局部重画，这时候它被称为重绘（Repaint）。实际上，绘制过程是在多个层上完成的，这些层我们称为 渲染层（RenderLayer） 渲染层合成（Composite） 多个绘制后的渲染层按照恰当的重叠顺序进行合并，而后生成位图，最终通过显卡展示到屏幕上。 那什么是渲染层合成呢？ 在 DOM 树中每个节点都会对应一个渲染对象（RenderObject），当它们的渲染对象处于相同的坐标空间（z 轴空间）时，就会形成一个 RenderLayers，也就是渲染层。渲染层将保证页面元素以正确的顺序堆叠，这时候就会出现层合成（composite），从而正确处理透明元素和重叠元素的显示。 这个模型类似于 Photoshop 的图层模型，在 Photoshop 中，每个设计元素都是一个独立的图层，多个图层以恰当的顺序在 z 轴空间上叠加，最终构成一个完整的设计图。 对于有位置重叠的元素的页面，这个过程尤其重要，因为一旦图层的合并顺序出错，将会导致元素显示异常。 显示器显示内容 栅格化操作完成后，合成线程会生成一个绘制命令，即”DrawQuad”，并发送给浏览器进程。 浏览器进程中的 viz 组件接收到这个命令，根据这个命令把页面内容绘制到内存，也就是生成了页面，然后把这部分内存发送给显卡，从而展示在屏幕上。 总结从浏览器的渲染过程中我们知道，页面 HTML 会被解析成 DOM 树，每个 HTML 元素对应了树结构上的一个 node 节点。而从 DOM 树转化到一个个的渲染层，并最终执行合并、绘制的过程，中间其实还存在一些过渡的数据结构，它们记录了 DOM 树到屏幕图形的转化原理，其本质也就是树结构到层结构的演化。","categories":[{"name":"Web","slug":"Web","permalink":"https://tangyanqiong.com/categories/Web/"},{"name":"JS","slug":"Web/JS","permalink":"https://tangyanqiong.com/categories/Web/JS/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://tangyanqiong.com/tags/JavaScript/"}]},{"title":"vue3双向数据绑定原理","slug":"vue3双向数据绑定","date":"2020-07-18T12:25:45.000Z","updated":"2022-07-22T12:55:31.064Z","comments":true,"path":"post/acef5003.html","link":"","permalink":"https://tangyanqiong.com/post/acef5003.html","excerpt":"概念什么是双向数据绑定，这里就不做赘述了，vue的双向数据绑定是什么大家都很了解了，这里主要讲vue2和vue3中双向绑定的区别。 vue2中使用“Object.defineProperty”对象以及对象属性的劫持实现双向绑定；而vue3中的响应式采用了ES6中的“Proxy”方法实现双向绑定。","text":"概念什么是双向数据绑定，这里就不做赘述了，vue的双向数据绑定是什么大家都很了解了，这里主要讲vue2和vue3中双向绑定的区别。 vue2中使用“Object.defineProperty”对象以及对象属性的劫持实现双向绑定；而vue3中的响应式采用了ES6中的“Proxy”方法实现双向绑定。 为什么要替换vue2的双向数据绑定问题关于对象： Vue 无法检测 property 的添加或移除。关于数组：不能利用索引直接设置一个数组项,也不能修改数组的长度。 总结来说Object.defineProperty方法存在一定的局限性 在Vue中，Object.defineProperty无法监控到数组下标的变化，导致直接通过数组的下标给数组设置值，不能实时响应。 为了解决这个问题，经过vue内部处理后可以使用以下几种方法来监听数组（ Vue为什么不能检测数组变动） 1234567push()pop()shift()unshift()splice()sort()reverse() Object.defineProperty只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历。Vue里，是通过递归以及遍历data对象来实现对数据的监控的，如果属性值也是对象那么需要深度遍历,显然如果能劫持一个完整的对象，不管是对操作性还是性能都会有一个很大的提升。 vue3双向绑定原理什么是ProxyProxy 是ES6中新增的一个特性，可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。 基本用法： 12//ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。var proxy = new Proxy(target, handler); 参数解释 target: 是用Proxy包装的被代理对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。 handler: 是一个对象，其声明了代理target 的一些操作，其属性是当执行一个操作时定义代理的行为的函数。Proxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法 Proxy的13种拦截 get(target, propKey, receiver)：拦截对象属性的读取，比如proxy.foo和proxy[‘foo’]。 set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo = v或proxy[‘foo’] = v，返回一个布尔值。 has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值。 deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值。 ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for…in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。 getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。 defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。 preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值。 getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象。 isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值。 setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。 apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。 construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。 例子 1234567891011121314151617181920212223242526272829303132333435// #注：Proxy 实例也可以作为其他对象的原型对象。var proxy = new Proxy(&#123;&#125;, &#123; get: function(target, property) &#123; return 35; &#125;&#125;);let obj = Object.create(proxy);obj.time // 35var handler = &#123; get: function(target, name) &#123; if (name === &apos;prototype&apos;) &#123; return Object.prototype; &#125; return &apos;Hello, &apos; + name; &#125;, apply: function(target, thisBinding, args) &#123; return args[0]; &#125;, construct: function(target, args) &#123; return &#123;value: args[1]&#125;; &#125;&#125;;var fproxy = new Proxy(function(x, y) &#123; return x + y;&#125;, handler);fproxy(1, 2) // 1new fproxy(1, 2) // &#123;value: 2&#125;fproxy.prototype === Object.prototype // truefproxy.foo === &quot;Hello, foo&quot; // true Proxy实现数据劫持12345678910111213141516observe(data) &#123; const that = this; let handler = &#123; get(target, property) &#123; return target[property]; &#125;, set(target, key, value) &#123; let res = Reflect.set(target, key, value); that.subscribe[key].map(item =&gt; &#123; item.update(); &#125;); return res; &#125; &#125; this.$data = new Proxy(data, handler);&#125;","categories":[{"name":"Web","slug":"Web","permalink":"https://tangyanqiong.com/categories/Web/"},{"name":"JS","slug":"Web/JS","permalink":"https://tangyanqiong.com/categories/Web/JS/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://tangyanqiong.com/tags/JavaScript/"}]},{"title":"什么是闭包及防抖节流","slug":"什么是闭包及节流防抖应用","date":"2020-05-02T10:05:42.000Z","updated":"2022-07-22T12:55:31.065Z","comments":true,"path":"post/c980d613.html","link":"","permalink":"https://tangyanqiong.com/post/c980d613.html","excerpt":"概念通常情况下，声明在一个函数中的函数，叫做闭包函数，在Javascript语言中，只有函数内部的子函数才能读取局部变量： 1234567// 闭包函数function f1()&#123; var n; return function () &#123; n ++; &#125;&#125;","text":"概念通常情况下，声明在一个函数中的函数，叫做闭包函数，在Javascript语言中，只有函数内部的子函数才能读取局部变量： 1234567// 闭包函数function f1()&#123; var n; return function () &#123; n ++; &#125;&#125; 优缺点优点让外部访问函数内部变量成为可能可以避免使用全局变量，防止全局变量污染 缺点局部变量会常驻在内存中，会造成内存泄漏（有一块内存空间被长期占用，而不被释放） 防抖设想有此场景：输入框中内容变化需要实时请求接口以获取最新搜索结果，如果在输入完成前输入框内容每变化一下都去请求接口，会造成很多不必要的请求，大大增加服务器压力。 解决思路：有变化时延迟一段时间再执行function，若在这段延迟时间内又有新变化，则重新开始延迟 12345678910111213141516171819202122232425262728293031// 定时器期间，有新操作时，清空旧定时器，重设新定时器var debounce = (fn, wait) =&gt; &#123; let timer, timeStamp=0; let context, args; let run = ()=&gt;&#123; timer= setTimeout(()=&gt;&#123; fn.apply(context,args); &#125;,wait); &#125; let clean = () =&gt; &#123; clearTimeout(timer); &#125; return function() &#123; context = this; args = arguments; let now = (new Date()).getTime(); if (now-timeStamp &lt; wait) &#123; console.log(&apos;reset&apos;,now); // 清除定时器，并重新加入延迟 clean(); run(); &#125; else &#123; console.log(&apos;set&apos;,now); run(); // last timer alreay executed, set a new timer &#125; timeStamp = now; &#125;&#125; 代码进一步优化：周期内有新事件触发时，重置定时器开始时间戳，定时器执行时，判断开始时间戳，若开始时间戳被推后，重新设定延时定时器；加入是否立即执行参数。 1234567891011121314151617181920212223242526272829303132333435363738// 增加前缘触发功能var debounce = (fn, wait, immediate=false) =&gt; &#123; let timer, startTimeStamp=0; let context, args; let run = (timerInterval) =&gt; &#123; timer= setTimeout(() =&gt; &#123; let now = (new Date()).getTime(); let interval = now-startTimeStamp if(interval &lt; timerInterval) &#123; // the timer start time has been reset，so the interval is less than timerInterval console.log(&apos;debounce reset&apos;,timerInterval-interval); startTimeStamp = now; run(wait-interval); // reset timer for left time &#125; else &#123; if (!immediate) &#123; fn.apply(context,args); &#125; clearTimeout(timer); timer=null; &#125; &#125;, timerInterval); &#125; return function() &#123; context = this; args = arguments; let now = (new Date()).getTime(); startTimeStamp = now; // set timer start time if(!timer) &#123; console.log(&apos;debounce set&apos;,wait); if(immediate) &#123; fn.apply(context,args); &#125; run(wait); // last timer alreay executed, set a new timer &#125; &#125;&#125; 节流设想有此场景：有‘搜索’按钮，每点击一次都会重新请求接口，获取并渲染页面表格最新数据，假如短时间内连续点击按钮，依然会造成很多不必要的请求解决思路：在一段时间内只执行最后一次function 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 定时器期间，只执行最后一次操作var throttling = (fn, wait) =&gt; &#123; let timer; let context, args; let run = () =&gt; &#123; timer=setTimeout(()=&gt;&#123; fn.apply(context,args); clearTimeout(timer); timer=null; &#125;,wait); &#125; return function () &#123; context=this; args=arguments; if(!timer)&#123; console.log(&quot;throttle, set&quot;); run(); &#125;else&#123; console.log(&quot;throttle, ignore&quot;); &#125; &#125;&#125;// 增加前缘var throttling = (fn, wait, immediate) =&gt; &#123; let timer, timeStamp=0; let context, args; let run = () =&gt; &#123; timer=setTimeout(()=&gt;&#123; if(!immediate)&#123; fn.apply(context,args); &#125; clearTimeout(timer); timer=null; &#125;,wait); &#125; return function () &#123; context=this; args=arguments; if(!timer)&#123; console.log(&quot;throttle, set&quot;); if(immediate)&#123; fn.apply(context,args); &#125; run(); &#125;else&#123; console.log(&quot;throttle, ignore&quot;); &#125; &#125;&#125; 总结防抖及节流都是使用闭包函数来应用的实际场景，平时也应注意合理使用闭包函数，避免性能消耗过多。","categories":[{"name":"Web","slug":"Web","permalink":"https://tangyanqiong.com/categories/Web/"},{"name":"JS","slug":"Web/JS","permalink":"https://tangyanqiong.com/categories/Web/JS/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://tangyanqiong.com/tags/JavaScript/"}]},{"title":"Flutter最新版本环境搭建报错","slug":"Flutter环境搭建","date":"2020-04-15T06:24:35.000Z","updated":"2022-07-20T16:53:04.194Z","comments":true,"path":"post/dc7fb27e.html","link":"","permalink":"https://tangyanqiong.com/post/dc7fb27e.html","excerpt":"前言最近更新到Mac OS最新系统Catalina，重装了Flutter，出现了些问题，在网上也搜索了，可能是才出的新版本问题，也没找到解决办法，最终自己捣鼓解决了此问题，随笔记录下此问题。","text":"前言最近更新到Mac OS最新系统Catalina，重装了Flutter，出现了些问题，在网上也搜索了，可能是才出的新版本问题，也没找到解决办法，最终自己捣鼓解决了此问题，随笔记录下此问题。 问题正常搭建Flutter的过程就不说了，到最后一步执行flutter doctor时报错如下： 1234567891011121314151617TangYanQiong-MacbookPro:~ TangDan$ flutter doctorDoctor summary (to see all details, run flutter doctor -v):[✓] Flutter (Channel master, v1.18.0-5.0.pre.57, on Mac OS X 10.15.4 19E287, locale zh-Hans-CN)[!] Android toolchain - develop for Android devices (Android SDK version 29.0.3) ✗ Android license status unknown. Try re-installing or updating your Android SDK Manager. See https://developer.android.com/studio/#downloads or visit visit https://flutter.dev/docs/get-started/install/macos#android-setup for detailed instructions.[✓] Xcode - develop for iOS and macOS (Xcode 11.4)[✓] Android Studio (version 3.6) [!] Connected device ! No devices available! Doctor found issues in 2 categories. 网上查了，大多答案都是让执行flutter doctor --android-licenses，结果又报错如下： 12345678TangYanQiong-MacbookPro:~ TangDan$ flutter doctor --android-licensesAndroid sdkmanager tool not found(/Users/TangDan/Library/Android/sdk/tools/bin/sdkmanager).Try re-installing or updating your Android SDK,visit https://flutter.dev/docs/get-started/install/macos#android-setup fordetailed instructions. 这个意思是说，Android sdkmanager tool没找到，然后按照提示的目录信息，去找了一下，发现我的sdk目录下，根本就没有tools这个文件夹，后来调查发现，这个tools文件实际上是android studio安装了Android SDK Tools才会有生成那个文件夹，在这里勾选安装，如果你本地有这个的话，安装了应该就好了。 但是我本地并没有这个选项，我这边的Android SDK配置是这样的，根本没有tools这个安装包，只有Command-line Tools这个，有点类似，就也勾选安装了： 安装成功后的目录如下： 还是没有tools这个文件夹，但是sdkmanager有了，后面自己想了下，不是缺tools吗？只是路径不对的问题了，就自己新建了个tools，里面在创建了个bin文件夹，再把sdkmanager拷进去。 原因猜想是，Android Studio最新版本Tools版本、名称及路径修改了，但是flutter最新版本并未更新，还是使用老路径导致找不到。 解决现在再来执行flutter doctor --android-licenses，一路y下去，设置成功。1234TangYanQiong-MacbookPro:~ TangDan$ flutter doctor --android-licenses5 of 7 SDK package licenses not accepted. 100% Computing updates... Review licenses that have not been accepted (y/N)? y... 最后，再执行flutter doctor，大功告成，不报错了。 1234567891011TangYanQiong-MacbookPro:~ TangDan$ flutter doctor[✓] Flutter (Channel master, v1.18.0-5.0.pre.57, on Mac OS X 10.15.4 19E287, locale zh-Hans-CN) [✓] Android toolchain - develop for Android devices (Android SDK version 29.0.3)[✓] Xcode - develop for iOS and macOS (Xcode 11.4)[✓] Android Studio (version 3.6) [✓] Connected device (1 available) • No issues found!","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://tangyanqiong.com/categories/Flutter/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://tangyanqiong.com/tags/Flutter/"}]},{"title":"Mac OS Catalina 终端Shell报警告","slug":"MacOS升级","date":"2020-02-10T07:18:37.000Z","updated":"2022-07-20T16:54:26.670Z","comments":true,"path":"post/bdd80ff3.html","link":"","permalink":"https://tangyanqiong.com/post/bdd80ff3.html","excerpt":"随笔前两天更新了Mac OS Catalina系统，总体来说还是可以，虽然有些只支持32位的应用，比如2015版的Office、WireShark等不能用了，但塞翁失马焉知非福呢，卸掉了Office相关的Word、Excel、PPT，瞬间清了几大个G，然后去下载了WPS多方文档格式支持软件，简直不要太好用，而且才几百兆，扯远了。。。 今天随笔记一个小事件，对于强迫症人士有用，比如我。 终端Shell报警告： 1234The default interactive shell is now zsh.To update your account to use zsh, please run `chsh -s /bin/zsh`.For more details, please visit https://support.apple.com/kb/HT208050.TangYanQiongdeMacBook-Pro:~ TangDan$","text":"随笔前两天更新了Mac OS Catalina系统，总体来说还是可以，虽然有些只支持32位的应用，比如2015版的Office、WireShark等不能用了，但塞翁失马焉知非福呢，卸掉了Office相关的Word、Excel、PPT，瞬间清了几大个G，然后去下载了WPS多方文档格式支持软件，简直不要太好用，而且才几百兆，扯远了。。。 今天随笔记一个小事件，对于强迫症人士有用，比如我。 终端Shell报警告： 1234The default interactive shell is now zsh.To update your account to use zsh, please run `chsh -s /bin/zsh`.For more details, please visit https://support.apple.com/kb/HT208050.TangYanQiongdeMacBook-Pro:~ TangDan$ 原因从报的警告就可以看出，提示原来使用的是bash风格，然而Catalina系统的shell已更改为zsh，请用 chsh -s /bin/zsh 更新替换，好吧，就run了，结果变成了这个风格 1TangDan@TangYanQiongdeMacBook-Pro ~ % 对这种爱不起来，然后查看系统支持的shell风格列表： 123456789101112TangYanQiongdeMacBook-Pro:~ TangDan$ cat /etc/shells# List of acceptable shells for chpass(1).# Ftpd will not allow users to connect who are not using# one of these shells./bin/bash/bin/csh/bin/dash/bin/ksh/bin/sh/bin/tcsh/bin/zsh 然后每个都试了，还是/bin/bash这种风格TangYanQiongdeMacBook-Pro:~ TangDan$最喜欢，但是系统会报警告，好，那把这个警告怎么消除？ 解决 vim修改bash_profile文件，在终端输出 1vim ~/.bash_profile 在bash_profile文件最下方加上，按i进入编辑模式 12# macOS Catalinaexport BASH_SILENCE_DEPRECATION_WARNING=1 按esc退出编辑模式，再输入:wq保存退出，现在终端就不会报警告了。 12Last login: Fri Apr 10 15:40:06 on ttys006TangYanQiongdeMacBook-Pro:~ TangDan$ 题外看到我这边shell用户名TangYanQiongdeMacBook-Pro我想改它很久（中英混合。。。），这会顺便改了，打开系统偏好设置-共享-直接修改电脑名称就可以修改了 12Last login: Fri Apr 10 15:46:05 on ttys006TangYanQiong-MacbookPro:~ TangDan$ 舒服了，😃","categories":[{"name":"Others","slug":"Others","permalink":"https://tangyanqiong.com/categories/Others/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"https://tangyanqiong.com/tags/Shell/"}]},{"title":"RN分享","slug":"RN分享","date":"2019-12-08T12:01:33.000Z","updated":"2022-07-20T16:54:02.593Z","comments":true,"path":"post/98fdf95d.html","link":"","permalink":"https://tangyanqiong.com/post/98fdf95d.html","excerpt":"什么是 React React 是一个用于构建用户界面的 JavaScript 库。 声明式UI","text":"什么是 React React 是一个用于构建用户界面的 JavaScript 库。 声明式UI JSXJSX Component Props State 生命周期 图例 shouldComponentUpdate react 的核心卖点之一 setState （只要调用了 setState 就会调用 render 无论你 setState 修改的是什么，哪怕是页面里没有的一个数据，render 都会被触发，并且父组件渲染中会嵌套渲染自、子组件。） render diff | reconciliation 官方一点的定义应该称为 reconciliation，也就是 React 用来比较两棵节点树的算法，它确定树中的哪些部分需要被更新。 在确定两棵树的区别后，会根据不同的地方对实际节点进行操作，这样你看到的界面终于在这一步得到了改变。当年 React 也就因为这个高效的 dom 操作方法得到追捧。 shouldComponentUpdate PureComponentContextRefrefs 转发 Fragmentfragment 高阶组件高阶组件 协调与 diffdiffing react hook","categories":[{"name":"Web","slug":"Web","permalink":"https://tangyanqiong.com/categories/Web/"},{"name":"JS","slug":"Web/JS","permalink":"https://tangyanqiong.com/categories/Web/JS/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://tangyanqiong.com/tags/JavaScript/"}]},{"title":"Charles抓包微信小程序\\移动端（Mac版）","slug":"charles抓包小程序","date":"2019-10-11T03:26:59.000Z","updated":"2020-04-24T06:21:45.000Z","comments":true,"path":"post/b032c09d.html","link":"","permalink":"https://tangyanqiong.com/post/b032c09d.html","excerpt":"前言之前做移动端，对网络进行测试抓包一直用的Charles抓包工具，很实用的一款工具，那怎么抓微信小程序的包呢，实际跟移动端是一样的，下面统一记录下，避免换电脑遗忘。","text":"前言之前做移动端，对网络进行测试抓包一直用的Charles抓包工具，很实用的一款工具，那怎么抓微信小程序的包呢，实际跟移动端是一样的，下面统一记录下，避免换电脑遗忘。 抓包其实要想抓取到微信小程序的数据首先要解决的第一个问题件就是如何通过charles抓取手机上的数据（HTTP)。 步骤第一步charles上通过proxy-&gt;proxy setting进入代理设置，入口如下图所示： 点击后进入如下图所示： 记住此处的port，默认为8888，也可以进行修改，只要不冲突就可以，勾选上Enable transparent HTTP proxying，到此为止完成charles上的初步设置。 到此为止，完成了电脑端的设置。 第二步设置手机代理，注意要保证手机所连接的wifi跟电脑在一个局域网内（就是连接同一个wifi或者通过电脑分享出的wifi进行连接） 首先，需要知道电脑的ip地址，手机上进入wifi设置，电脑与手机共连同一个网络，修改手机上wifi代理 点击代理后进入如下界面，服务器主机名处填写刚才查到的电脑的ip地址即可，服务器端口填写第一步中charles处设置的端口，默认是8888，如果做了修改，填写设置charles时修改的端口值。 点击保存，此时charles上会弹出一个对话框，点击allow(允许)即可。此时就可以抓取手机上的http数据包了（注意不是https） 如下图所示，点入一个应用后，抓取到的http包。 建议完成以上步骤，charles会同时抓取手机以及电脑上的数据包，如果针对手机抓包可以通过取消勾选下图所示的选项屏蔽掉，这样更清楚。 问题手机连接不上Charles的几种原因及解决方案： 确认手机跟电脑是不是在一个wifi环境下，我在使用过程中又一次手机由于wifi信号强弱问题自动切换过wifi导致抓了一般的数据包抓不到了。 可以尝试更换一下端口号（8888可能已经被占用）。 可以通过电脑手动添加手机的ip。 试试关掉电脑防火墙，在重新连接。 最后大招，万能重启。重新打开charles，重新设置手机连接。 抓HTTPS包电脑端设置到此为止，完成了一大步骤的设置，可以通过电脑抓取手机的HTTP数据包了，但对于HTTPS数据，到此步为止，抓包工具上的列表部分会显示一堆unknown的地址。 那怎么来解决呢？ 首先是电脑端的配置，进入Charles的Help-&gt;SSL Proxying-&gt;Install Charles Root Certificate 点击Install Charles Root Certificate之后，会弹出mac的钥匙串访问页面，点击允许并安装证书，加入成功后会显示如下： 右键点击该证书，选择菜单中的“显示简介选项”，接着进入信任栏目，将其全部置为“始终信任” 接着点击Proxy-&gt;SSL Proxy Settings，弹出如下页面 弹出的对话框中，勾选Enable SSL Proxying，然后点击add添加Host为和Port为443，点击ok（此处将host设置为的意思是主抓取全部的http是数据包，如果想针对某个域名抓取可以在此设置） 到此为止，完成了电脑端的设置 移动端设置接着需要在手机端安装证书，点击Charles上的Help-&gt;SSL Proxying-&gt;Install Charles Root Certificate on a Mobile Device or Remote Browser 点击之后弹出如下对话框： 接着在手机浏览器上访问charlesproxy.com/getssl这个地址，然后会弹出如下界面： 输入一个名字比如charlesproxy之后点击确定，会有一个一闪而过的提示，就ok了 此时进入小程序，可以看到charles上能够看到https的接口的地址和数据了 到此，就可以愉快的抓包了。 注意温馨提示1苹果设备iOS10以后证书可以正常安装，可正常使用HTTPS抓包，但是安卓设备呢，需注意： 由于在Android7.0及以上的系统中，每个应用可以定义自己的可信CA集，默认情况下，应用只会信任系统预装的CA证书，而不会信任用户安装的CA证书 安卓系统 7.0 以下版本，不管微信任意版本，都会信任系统提供的证书 安卓系统 7.0 以上版本，微信 7.0 以下版本，微信会信任系统提供的证书 安卓系统 7.0 以上版本，微信 7.0 以上版本，微信只信任它自己配置的证书列表 简单来说，就是安卓系统7.0及以下的设备可以正常安装证书进行HTTPS抓包，7.0以上则需要曲线救国，这里就不多说了，我后面在电脑上用网易MuMu模拟器（该模拟器系统是6.0）安装微信，在wifi设置里长按默认网络进行网络修改，设置代理等，也可以愉快的抓小程序的数据包了。 温馨提示2注意，有一些应用使用的网络框架是不允许通过代理访问的，此时通过charles抓包显示的地址仍是unknown，或者手机上访问该应用会提示网络连接错误等信息，此时取消勾选charles的SSL Proxying settings中的勾选框就可以正常访问了。 温馨提示3抓取工作完成后，记得把手机上的代理设置恢复原样，否则当电脑上的charles关闭时，手机将无法正常访问网络。","categories":[{"name":"Others","slug":"Others","permalink":"https://tangyanqiong.com/categories/Others/"}],"tags":[{"name":"Charles","slug":"Charles","permalink":"https://tangyanqiong.com/tags/Charles/"},{"name":"WeChat","slug":"WeChat","permalink":"https://tangyanqiong.com/tags/WeChat/"},{"name":"抓包","slug":"抓包","permalink":"https://tangyanqiong.com/tags/抓包/"}]},{"title":"iOS及Web使用语言特性","slug":"iOS及Web使用的语言特性","date":"2019-09-16T03:07:38.000Z","updated":"2020-04-14T07:58:39.000Z","comments":true,"path":"post/4546698d.html","link":"","permalink":"https://tangyanqiong.com/post/4546698d.html","excerpt":"前言关于iOS及Web的使用语言Object-C、Swift、JavaScript，大家都耳熟能详，那它们到底是什么类型的静态语言？以及什么强弱类型语言？很多同学只是简单的背出它们是什么语言及类型，但并没有理解到，现在来举例说明和分享一下。","text":"前言关于iOS及Web的使用语言Object-C、Swift、JavaScript，大家都耳熟能详，那它们到底是什么类型的静态语言？以及什么强弱类型语言？很多同学只是简单的背出它们是什么语言及类型，但并没有理解到，现在来举例说明和分享一下。 分析Object-C我用的最多的当然是Object-C，毕竟是做iOS开发出身，对这个语言了解最深。首先，因为黑魔法RunTime机制，Object-C是一个运行时的动态类型的强类型语言，举例如下： 以下两种情况都可以看出，Xcode编译时并不会报错，说明是一个动态语言，运行时才会去检验类型 1234NSString *test = @&quot;1231231&quot;;test = [[NSDate alloc] init];NSDate *test2 = @&quot;1231231&quot;; // test2的真实类型是什么，运行时会得到String类型，并不是声明时的NSDate类型 Object-C是强类型语言，因为变量必须声明类型才能使用，说实话，Object-C的代码简洁性，是真的不怎么高 123NSString *certsPath = [[NSBundle mainBundle] pathForResource:@&quot;server&quot; ofType:@&quot;crt&quot;];NSError *error;NSString *contentInUTF8 = [NSString stringWithContentsOfFile:certsPath encoding:NSUTF8StringEncoding error:&amp;error]; SwiftiOS的这两种开发语言，Swift和OC，Swift更简洁了，减少了代码的冗余性，最开始接触它的时候，我还以为它是一门弱语言类型的语言，后来发现我错了，下面会娓娓道来，它实际是一门静态类型的强类型语言。 以下情况代码编译会报错：’Cannot assign value of type ‘NSDate’ to type ‘String’’ ，类型错误，由此看出Swift是静态类型语言 123var tmp = &quot;asdfas&quot;let date = NSDate.init()tmp = date 为什么一开始会觉得它是弱类型语言呢？ Swift 变量不强制的指定类型，而是用 var 和 let 表示可变与不可变。所以，误Swift是一门弱类型的语言。 像下面的代码块，变量赋值时并没声明类型 12let num = 1let str = &quot;2&quot; 基于以上，从自身理解，误以为Swift是弱类型语言 但是，实际上，这里没有强制声明类型，看似一个弱类型的语言，其实不然。Swift 编译器能够推断出 num 是 Int 类型。那么 num 就不能再被赋值为 String 类型。更不能写成如下的形式： 123let num = 1let str = &quot;2&quot;let result = num + str 编译器将会报如下的错误： 12345error: binary operator &apos;+&apos; cannot be applied to operands of type &apos;Int&apos; and &apos;String&apos;let result = num + str ~~~ ^ ~~~note: overloads for &apos;+&apos; exist with these partially matching parameter lists: (Int, Int), (String, String), (Int, UnsafeMutablePointer&lt;Pointee&gt;), (Int, UnsafePointer&lt;Pointee&gt;)let result = num + str 这说明了，Swift 是一门强类型语言。Swift 的类型声明，你可以看成是在定义变量的时候，隐式声明的（由编译器推断出），当然也可以显式的声明。如下： 1let num: Int = 1 JavaScriptWeb中的常用语言JavaScript，如果有语言基础的话，是一门很快上手的语言，我也很喜欢JavaScript，当然也有使用中比较头疼的事，因为它是一门动态类型的弱类型语言，往往项目中在项目运行成功后，控制台意想不到的报错，不像强语言类型那样，直接编译不过，而我又有Swift的编写思想，想着它类型编译通过了，运行肯定就没问题，往往会出现比如编译没问题，类型错误的问题，而且它没有iOS中nil可以调用任何方法的容错机制，如果这个对象为nil再调用其某个方法也会报错，所以写的时候必须要判断是否为空，增加代码冗余性，但是，好处大于弊端，比如代码简洁性，可以动态写很多业务逻辑，我还是很喜欢它。 动态类型语言，以下情况，编译没问题，动态运行时赋值类型 123let tmpFlag = falselet test = &apos;asdfasdfas&apos;test = tmpFlag // 所以最终test为Bool类型了 弱类型语言，书写变量时不用声明类型也可 123let tmpFlag = falselet test = &apos;asdfasdfas&apos;let jjjj = Date.now() 扩展TypeScriptTypeScript是JavaScript的一个超集，TypeScript可以使用JavaScript中的所有代码和编码概念，TypeScript是为了使 JavaScript的开发变得更加容易而创建的，它是关于尽早捕获错误并使您成为更高效的开发人员，它是什么类型的语言？我们把在JavaScript上实验的代码，放在ts里一试便知道。 以下情况是js上实验的代码，在ts里编译报错，说明TypeScript是静态类型语言 123let tmpFlag = falselet test = &apos;asdfasdfas&apos;test = tmpFlag 报错如下： 143:9 Type &apos;false&apos; is not assignable to type &apos;string&apos;. 相同代码又在ts里实验，编译未报错，故TypeScript是弱类型语言 123let tmpFlag = falselet test = &apos;asdfasdfas&apos;let jjjj = Date.now() 以下代码也未报错： 123let num = 1let str = &apos;2&apos;let result = num + str 综上可知，TypeScript是一门静态类型的弱类型语言。","categories":[{"name":"Others","slug":"Others","permalink":"https://tangyanqiong.com/categories/Others/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://tangyanqiong.com/tags/JavaScript/"},{"name":"Swift","slug":"Swift","permalink":"https://tangyanqiong.com/tags/Swift/"},{"name":"Object-C","slug":"Object-C","permalink":"https://tangyanqiong.com/tags/Object-C/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://tangyanqiong.com/tags/TypeScript/"}]},{"title":"跨平台RN与Flutter对比及学习","slug":"跨平台","date":"2019-09-08T07:42:34.000Z","updated":"2020-03-25T09:04:29.000Z","comments":true,"path":"post/196a8be9.html","link":"","permalink":"https://tangyanqiong.com/post/196a8be9.html","excerpt":"前言最近想学跨平台开发，在RN和Flutter中纠结学哪个，看了资料RN对Web前端比较友好，都是JS开发语言，比较容易上手，但是有个以前的iOS同事，他现在已经用Flutter着手在开发iOS、Android了，据他说很好用。","text":"前言最近想学跨平台开发，在RN和Flutter中纠结学哪个，看了资料RN对Web前端比较友好，都是JS开发语言，比较容易上手，但是有个以前的iOS同事，他现在已经用Flutter着手在开发iOS、Android了，据他说很好用。 对比跨平台，首先考虑的就是性能问题，谁的性能好，未来必将是谁的天下。 RN性能RN的效率由于是将View编译成了原生View，所以效率上要比基于Cordova的HTML5高很多，但是它也有效率问题，RN的渲染机制是基于前端框架的考虑，复杂的UI渲染是需要依赖多个view叠加。比如我们渲染一个复杂的ListView，每一个小的控件，都是一个native的view，然后相互组合叠加，想想此时如果我们的list再需要滑动刷新，会有多少个对象需要渲染，所以也就有了前面所说的RN的列表方案不友好。 RN框架原理图 Flutter性能而Flutter则吸收了前两者的教训之后，在渲染技术上，选择了自己实现(GDI)，有自己的一套UI系统，由于有更好的可控性，使用了新的语言Dart，避免了RN的那种通过桥接器与Javascript通讯导致效率低下的问题，所以在性能方面无可厚非比RN更高一筹，有经验的开发者可以打开Android手机开发者选项里面的显示边界布局，发现Flutter的布局是一个整体，说明Flutter的渲染没用使用原生控件进行渲染。 Flutter框架原理图 异同 Flutter性能会更好无线接近原生的体验,Dart是AOT编译的，编译成快速、可预测的本地代码 RN采用JS语言开发，基于React，对前端工程师更友好。Dart语言受众小 Flutter自己实现了一套UI框架，丢弃了原生的UI框架。而RN还是可以自己利用原生框架，两个各有好处。Flutter的兼容性高，RN可以利用原生已有的优秀UI RN的布局更像css，而Flutter的布局更像native布局，但是去掉xml通过代码直接写需要适应下 总结对比了RN/Flutter后，我觉得对于我来说，RN应该很容易上手，因为有前端基础，RN学习起来应该很快，但是我也不想放弃Flutter，Flutter布局像原生布局，有iOS开发经验的我也不想放弃，因为有iOS同事成功上车的前车之鉴，所以我也很有信心能学好它，从性能来说我也更偏向Flutter，但是也不想浪费RN这个学习机会，所以就我自己的实际情况而言，我会两个都学。 总之，一句话吧，基于自身实际情况，没有更好只有最适合你的框架。","categories":[{"name":"跨平台","slug":"跨平台","permalink":"https://tangyanqiong.com/categories/跨平台/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://tangyanqiong.com/tags/Flutter/"},{"name":"RN","slug":"RN","permalink":"https://tangyanqiong.com/tags/RN/"}]},{"title":"MarkDown常用语法","slug":"markdown常用语法","date":"2019-09-04T09:00:29.000Z","updated":"2020-03-25T09:20:10.000Z","comments":true,"path":"post/d18ae5e4.html","link":"","permalink":"https://tangyanqiong.com/post/d18ae5e4.html","excerpt":"由来由于前段时间工作忙，快一个月没更新博客了，貌似有些忘了MarkDown的语法，这里记录下MarkDown语法作备忘录，以后方便查找。","text":"由来由于前段时间工作忙，快一个月没更新博客了，貌似有些忘了MarkDown的语法，这里记录下MarkDown语法作备忘录，以后方便查找。 常用语法标题语法1234567891011#一级标题##二级标题###三级标题####四级标题#####五级标题######六级标题 分割线 使用*加空格，来表示无序列表 1 2 3 用数字加.加空格，来表示有序列表 1 2 3 4 使用引用 引用需要使用&gt;和空格 插入链接baidu 插入在线图片 使用粗体、斜体这就是粗体 这就是斜体 这就是斜粗体 Task list finished unfinished 这个是删除线 使用代码框，PS:这种不支持代码的语法高亮~~~@IBAction func showMessage(){ let alertController = UIAlertController(title: “welcome to my first app”, message: “hello world”, preferredStyle: UIAlertControllerStyle.Alert) alertController.addAction(UIAlertAction(title: “OK”, style: UIAlertActionStyle.Default, handler: nil)) self.presentViewController(alertController, animated: true, completion: nil) }`","categories":[{"name":"Others","slug":"Others","permalink":"https://tangyanqiong.com/categories/Others/"}],"tags":[{"name":"MarkDown","slug":"MarkDown","permalink":"https://tangyanqiong.com/tags/MarkDown/"}]},{"title":"Vue主题import出错","slug":"vue主题import出错","date":"2019-08-01T03:52:00.000Z","updated":"2020-03-25T08:53:59.000Z","comments":true,"path":"post/52c1147f.html","link":"","permalink":"https://tangyanqiong.com/post/52c1147f.html","excerpt":"问题在main.js文件中import‘../theme/index.css’ 报错： 12345ERROR Failed to compile with 1 errors This relative module was not found:* ../theme/index.css in ./src/main.js","text":"问题在main.js文件中import‘../theme/index.css’ 报错： 12345ERROR Failed to compile with 1 errors This relative module was not found:* ../theme/index.css in ./src/main.js 原因原来在webpack.base.conf.js中有导入过如下代码，可能是webpack.base.conf.js和utils.js重复编译SCSS文件导致报错。 12345// 导入SCSS&#123; test: /\\.(scss|css)?$/, loaders: [&quot;style&quot;, &quot;css&quot;, &quot;sass&quot;]&#125; 解决方案删除上述在webpack.base.conf.js中导入的SCSS代码，即可。","categories":[{"name":"Web","slug":"Web","permalink":"https://tangyanqiong.com/categories/Web/"},{"name":"Vue","slug":"Web/Vue","permalink":"https://tangyanqiong.com/categories/Web/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://tangyanqiong.com/tags/Vue/"},{"name":"CSS","slug":"CSS","permalink":"https://tangyanqiong.com/tags/CSS/"}]},{"title":"Vue项目缩进问题","slug":"vue缩进","date":"2019-07-30T09:50:46.000Z","updated":"2019-07-31T02:01:29.000Z","comments":true,"path":"post/db5c826e.html","link":"","permalink":"https://tangyanqiong.com/post/db5c826e.html","excerpt":"问题WebStorm的缩进规则和ESlint-vue的校验规则冲突引起的问题。 前提条件 Vue项目 安装时打开ESLint校验功能 开发工具WebStorm 代码格式化会出现两种：","text":"问题WebStorm的缩进规则和ESlint-vue的校验规则冲突引起的问题。 前提条件 Vue项目 安装时打开ESLint校验功能 开发工具WebStorm 代码格式化会出现两种： WebStorm格式化： 1234&lt;script&gt; exports default &#123; &#125;&lt;/script&gt; ESlint格式化： 1234&lt;script&gt;exports default &#123;&#125;&lt;/script&gt; 解决方案打开项目根下的.eslintrc.js文件，将rules节点中添加以下配置项，其中’2’是指统一缩进2个空格，’1’是指1倍缩进。 1&apos;vue/script-indent&apos;: [&apos;error&apos;, 2, &#123;&apos;baseIndent&apos;: 1&#125;] 另外需要添加以下节点，与rules节点同级： 1234567overrides: [ &#123; &apos;files&apos;: [&apos;*.vue&apos;], &apos;rules&apos;: &#123; &apos;indent&apos;: &apos;off&apos; &#125; &#125;] 问题搞定。","categories":[{"name":"Web","slug":"Web","permalink":"https://tangyanqiong.com/categories/Web/"},{"name":"Vue","slug":"Web/Vue","permalink":"https://tangyanqiong.com/categories/Web/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://tangyanqiong.com/tags/Vue/"},{"name":"ESLint","slug":"ESLint","permalink":"https://tangyanqiong.com/tags/ESLint/"},{"name":"WebStorm","slug":"WebStorm","permalink":"https://tangyanqiong.com/tags/WebStorm/"}]},{"title":"Github代码下载提速","slug":"github提速","date":"2019-07-25T08:06:27.000Z","updated":"2019-07-26T09:42:14.000Z","comments":true,"path":"post/1e0383f0.html","link":"","permalink":"https://tangyanqiong.com/post/1e0383f0.html","excerpt":"前言之前pod install安装GRPC出现各种错误，在网上找了各种办法，还重装过git以及pod都没有用，还是报类似如下错误。 123456789101112131415161718[!] Error installing !ProtoCompiler[!] /usr/bin/curl -f -L -o /var/folders/1s/jw93vj050vq92gbrjv1c3x880000gn/T/d20190718-18563-1fzxwnx/file.zip https://github.com/google/protobuf/releases/download/v3.8.0/protoc-3.8.0-osx-x86_64.zip --create-dirs --netrc-optional --retry 2 % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 162 0 162 0 0 11 0 --:--:-- 0:00:14 --:--:-- 39100 617 0 617 0 0 40 0 --:--:-- 0:00:15 --:--:-- 602k 10 2794k 10 305k 0 0 835 0 0:57:06 0:06:14 0:50:52 0curl: (56) LibreSSL SSL_read: SSL_ERROR_SYSCALL, errno 54[!] Error installing BoringSSL-GRPC[!] /usr/bin/git clone https://github.com/google/boringssl.git /var/folders/1s/jw93vj050vq92gbrjv1c3x880000gn/T/d20190718-18162-1vck5op --template=Cloning into &apos;/var/folders/1s/jw93vj050vq92gbrjv1c3x880000gn/T/d20190718-18162-1vck5op&apos;...error: RPC failed; curl 18 transfer closed with outstanding read data remainingfatal: The remote end hung up unexpectedlyfatal: early EOFfatal: index-pack failed 之前没想过是网络的原因导致，因为挂VPN也出现了这种情况，后来一一排除，pod install –verbose 打印log，才发现根本就是github下载速度过慢，甚至连接超时导致。 那怎么来提高github下载代码的速度呢？","text":"前言之前pod install安装GRPC出现各种错误，在网上找了各种办法，还重装过git以及pod都没有用，还是报类似如下错误。 123456789101112131415161718[!] Error installing !ProtoCompiler[!] /usr/bin/curl -f -L -o /var/folders/1s/jw93vj050vq92gbrjv1c3x880000gn/T/d20190718-18563-1fzxwnx/file.zip https://github.com/google/protobuf/releases/download/v3.8.0/protoc-3.8.0-osx-x86_64.zip --create-dirs --netrc-optional --retry 2 % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 162 0 162 0 0 11 0 --:--:-- 0:00:14 --:--:-- 39100 617 0 617 0 0 40 0 --:--:-- 0:00:15 --:--:-- 602k 10 2794k 10 305k 0 0 835 0 0:57:06 0:06:14 0:50:52 0curl: (56) LibreSSL SSL_read: SSL_ERROR_SYSCALL, errno 54[!] Error installing BoringSSL-GRPC[!] /usr/bin/git clone https://github.com/google/boringssl.git /var/folders/1s/jw93vj050vq92gbrjv1c3x880000gn/T/d20190718-18162-1vck5op --template=Cloning into &apos;/var/folders/1s/jw93vj050vq92gbrjv1c3x880000gn/T/d20190718-18162-1vck5op&apos;...error: RPC failed; curl 18 transfer closed with outstanding read data remainingfatal: The remote end hung up unexpectedlyfatal: early EOFfatal: index-pack failed 之前没想过是网络的原因导致，因为挂VPN也出现了这种情况，后来一一排除，pod install –verbose 打印log，才发现根本就是github下载速度过慢，甚至连接超时导致。 那怎么来提高github下载代码的速度呢？ 实现获取IP地址点击进入获取IP网址，获取到本机对应以下三个网址的IP地址。 github.com github.global.ssl.fastly.net codeload.github.com 每个人的都不一样，这是我获取到的IP地址： 123140.82.113.4 github.com151.101.185.194 github.global.ssl.fastly.net140.82.114.9 codeload.github.com 修改系统hosts文件Windows系统 hosts文件路径：C:\\Windows\\System32\\drivers\\etc\\hosts , 添加上面查询到的IP到hosts文件中（此时可能需要管理员权限,可以将hosts复制到桌面，修改好了再复制回去覆盖原来的） 修改完成后刷新DNS1ipconfig /flushdns Mac系统在Finder-&gt;前往-&gt;前往文件夹，在框里输入/etc/hosts，找到hosts文件，可以将hosts文件复制到桌面，将ip地址添加到里面，修改好了再复制回去覆盖原来的hosts文件。 最后在终端执行刷新DNS命令 1dscacheutil -flushcache 效果提速前的效果未截图，反正最快就是10多kb的样子，提速后效果如下： GRPC报错的相关问题也迎刃而解。","categories":[{"name":"Others","slug":"Others","permalink":"https://tangyanqiong.com/categories/Others/"}],"tags":[{"name":"GRPC","slug":"GRPC","permalink":"https://tangyanqiong.com/tags/GRPC/"},{"name":"Github","slug":"Github","permalink":"https://tangyanqiong.com/tags/Github/"}]},{"title":"Swift上View手势控制","slug":"Swift中View手势控制","date":"2019-06-03T07:31:20.000Z","updated":"2019-06-06T02:00:27.000Z","comments":true,"path":"post/a17aa0f4.html","link":"","permalink":"https://tangyanqiong.com/post/a17aa0f4.html","excerpt":"前言对View进行放大缩小、移动、旋转，其实是很常见的需求，最开始在OC上，很早的几年，还是用的touch事件来实现，这种实现方式很繁琐，呈现的效果也不是很好。 后来，苹果也逐步的淘汰了这种方式，出了手势这种模式，极大程度上的缩减了代码量，而且操作简单，上手迅速，OC上手势的使用方式网上比比皆是，这里就不细说，着重介绍Swift View手势控制方法。","text":"前言对View进行放大缩小、移动、旋转，其实是很常见的需求，最开始在OC上，很早的几年，还是用的touch事件来实现，这种实现方式很繁琐，呈现的效果也不是很好。 后来，苹果也逐步的淘汰了这种方式，出了手势这种模式，极大程度上的缩减了代码量，而且操作简单，上手迅速，OC上手势的使用方式网上比比皆是，这里就不细说，着重介绍Swift View手势控制方法。 实现添加旋转、缩放、移动手势，如下： 1234567891011//Rotationlet rotationGestureRecognizer = UIRotationGestureRecognizer(target: self, action: #selector(EditPhotoViewController.rotateView(_:)))photoImageView?.addGestureRecognizer(rotationGestureRecognizer)//Scale pinchlet pinchGestureRecognizer = UIPinchGestureRecognizer(target: self, action: #selector(EditPhotoViewController.pinchView(_:)))photoImageView?.addGestureRecognizer(pinchGestureRecognizer)//Movelet panGestureRecognizer = UIPanGestureRecognizer(target: self, action: #selector(EditPhotoViewController.panView(_:)))photoImageView?.addGestureRecognizer(panGestureRecognizer) 以下代码使用变量如下： private var cropFrame = CGRect.zero //图片上限制框的frame private var latestFrame = CGRect.zero //最大缩放frame private var rotationAngle: CGFloat = 0.0 //旋转的角度 给变量设置初始值： 12345678910111213141516171819202122private func resetShowImageViewFrame() &#123; rotationAngle = 0.0 photoImageView?.image = originalImage photoImageView?.transform = .identity // scale to fit the screen cropFrame = photoOverLayView?.transparentArea ?? CGRect.zero var oriWidth: CGFloat = cropFrame.size.width var oriHeight: CGFloat = (originalImage?.size.height ?? 0.0) * (oriWidth / (originalImage?.size.width ?? 0.0)) if ((originalImage?.size.width)!/(originalImage?.size.height)!) &gt; (CGFloat)(standardPostImgWidth)/(CGFloat)(standardPostImgHeight) &#123; oriHeight = cropFrame.size.height oriWidth = (originalImage?.size.width ?? 0.0) * (oriHeight / (originalImage?.size.height ?? 0.0)) &#125; let oriX: CGFloat = cropFrame.origin.x + (cropFrame.size.width - oriWidth) / 2 let oriY: CGFloat = cropFrame.origin.y + (cropFrame.size.height - oriHeight) / 2 oldFrame = CGRect(x: oriX, y: oriY, width: oriWidth, height: oriHeight) latestFrame = oldFrame photoImageView?.frame = oldFrame largeFrame = CGRect(x: 0, y: 0, width: limitRatio * oldFrame.size.width, height: limitRatio * oldFrame.size.height)&#125; 旋转实现12345678910@objc func rotateView(_ rotationGestureRecognizer: UIRotationGestureRecognizer?) &#123; let view: UIView? = photoImageView if rotationGestureRecognizer?.state == .began || rotationGestureRecognizer?.state == .changed &#123; view?.transform = (view?.transform.rotated(by: (rotationGestureRecognizer?.rotation)!))! rotationAngle = rotationAngle + (rotationGestureRecognizer?.rotation ?? 0.0) rotationGestureRecognizer?.rotation = 0 &#125; else if rotationGestureRecognizer?.state == .ended &#123; latestFrame = photoImageView?.frame ?? CGRect.zero &#125;&#125; 缩放实现1234567891011121314151617181920212223242526272829@objc func pinchView(_ pinchGestureRecognizer: UIPinchGestureRecognizer?) &#123; let view: UIView? = photoImageView if pinchGestureRecognizer?.state == .began || pinchGestureRecognizer?.state == .changed &#123; if rotationAngle == 0 &#123; //narrow if (pinchGestureRecognizer?.scale)! &lt;= CGFloat(1.0) &amp;&amp; ((photoImageView?.width)! &lt;= cropFrame.size.width || (photoImageView?.height)! &lt;= cropFrame.size.height) &#123; return &#125; &#125; //amplification if (pinchGestureRecognizer?.scale)! &gt; CGFloat(1.0) &amp;&amp; ((photoImageView?.width)! &gt; 5000 || (photoImageView?.height)! &gt; 5000) &#123; return &#125; view?.transform = (view?.transform.scaledBy(x: (pinchGestureRecognizer?.scale)!, y: (pinchGestureRecognizer?.scale)!))! pinchGestureRecognizer?.scale = 1 &#125; else if pinchGestureRecognizer?.state == .ended &#123; if rotationAngle == 0 &#123; var newFrame: CGRect? = photoImageView?.frame //newFrame = handleScaleOverflow(newFrame ?? CGRect.zero) newFrame = handleBorderOverflow(newFrame ?? CGRect.zero) UIView.animate(withDuration: TimeInterval(BOUNDCE_DURATION), animations: &#123; self.photoImageView?.frame = newFrame ?? CGRect.zero self.latestFrame = newFrame ?? CGRect.zero &#125;) &#125; else &#123; latestFrame = photoImageView?.frame ?? CGRect.zero &#125; &#125;&#125; 平移实现123456789101112131415161718192021@objc func panView(_ panGestureRecognizer: UIPanGestureRecognizer?)&#123; let view = panGestureRecognizer?.view; if (panGestureRecognizer?.state == .began || panGestureRecognizer?.state == .changed) &#123; let translation = panGestureRecognizer?.translation(in: view?.superview) view?.center = CGPoint(x: (view?.center.x)! + (translation?.x)!, y: (view?.center.y)! + (translation?.y)!) panGestureRecognizer?.setTranslation(CGPoint.zero, in: view?.superview) &#125; else if panGestureRecognizer?.state == .ended &#123; if rotationAngle == 0 &#123; //bounce to original frame var newFrame: CGRect? = photoImageView?.frame newFrame = handleBorderOverflow(newFrame ?? CGRect.zero) UIView.animate(withDuration: TimeInterval(BOUNDCE_DURATION), animations: &#123; self.photoImageView?.frame = newFrame ?? CGRect.zero self.latestFrame = newFrame ?? CGRect.zero &#125;) &#125; else &#123; latestFrame = photoImageView?.frame ?? CGRect.zero &#125; &#125;&#125; 最终效果","categories":[{"name":"iOS","slug":"iOS","permalink":"https://tangyanqiong.com/categories/iOS/"},{"name":"Swift","slug":"iOS/Swift","permalink":"https://tangyanqiong.com/categories/iOS/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://tangyanqiong.com/tags/Swift/"},{"name":"手势控制","slug":"手势控制","permalink":"https://tangyanqiong.com/tags/手势控制/"}]},{"title":"iPad控制多屏电视","slug":"ipad控制多屏","date":"2019-05-30T07:46:42.000Z","updated":"2019-07-26T09:48:49.000Z","comments":true,"path":"post/a503d77d.html","link":"","permalink":"https://tangyanqiong.com/post/a503d77d.html","excerpt":"前言背景我们公司有4个电视（内置机顶盒），用来展示公司的业务，平时经常会有客户来参观，电视下面是通过HDMI线连接的电脑，展示的实际是网页。 需求昨天下午领导提一个需求，因为演示的时候，需要操作，就得用电脑的鼠标在电视上点，屏幕太大鼠标又在电视下方，很不方便，不好操作，然后想借鉴别人公司，直接用iPad里控制4个电视来操作。","text":"前言背景我们公司有4个电视（内置机顶盒），用来展示公司的业务，平时经常会有客户来参观，电视下面是通过HDMI线连接的电脑，展示的实际是网页。 需求昨天下午领导提一个需求，因为演示的时候，需要操作，就得用电脑的鼠标在电视上点，屏幕太大鼠标又在电视下方，很不方便，不好操作，然后想借鉴别人公司，直接用iPad里控制4个电视来操作。 实现讨论用iPad来控制电视屏幕，是不是一听就很高大？ 哈哈，怎么控制？都不是一个系统，一个是windows系统，一个是iOS系统。讨论时，我提出了两个方案： 做个APP，把网页内嵌到里面，直接用自带的AirPlay把iPad投屏到电视，不用的电视，再切换投屏，这样在iPad上操作就会同步到电视。 因为展示的业务是web页，那么就用APP，在同一局域网给Web端发指令，或通过后台中转指令，以控制在电视上展示的网页。 调研1. 投屏方案这个方案，实际是时间成本最少的，说干就干，然后马上我这边就起了一个项目，嵌了一个网页在APP里，好吧，正式开始投屏，然后… 结果： 投屏是成功了的，但是呢，因为电视的屏幕比是16:9，而iPad是4:3，导致了在电视上，iPad的投屏屏幕显示不全，两边还有间隙，不是全屏，而且当初web端开发的网页尺寸也是固定的1920x1080，也就是为电视量身定做的，这个网页在iPad上也不能全屏显示。 这种硬件上及网页端的限制，不好改变，就放弃了这种方式。 2. 指令控制方案这个方案，需要和web端约定很多指令，基本指令像点击不同按钮的不同指令，而且比如上下滑动网页的距离，由于屏幕分辨率不一样，需要经过一定转换，才能是web端的对应距离等等问题。 结果： 诚如上面所说，这个开发成本会很大，而且有局限性，一旦网页内容改变，APP端需改动代码升级才能使用，这种做法不符合产品经理的预期，所以直接淘汰了。 另辟蹊径上面的两个方案告吹后，给产品经理说了结果，然后产品经理在网上找到了另一种方案，就是市面上这种类似TeamViewer的远程操控桌面软件，直接在iPad上安装软件，然后在PC上安装同样软件，使用iPad操控PC桌面。 两种方案有了这个方案，就在网上找到了向日葵、Splashtop，这两个软件支持多端连接。 1. 向日葵安装和使用都比较简单，APP风格符合中国人的操作习惯，每次连接PC端都需要输入验证码（PC端的向日葵软件上），这样的话，每次切换连接不同电脑比较慢，操作体验不好。 2. Splashtop同样的，安装和使用都比较简单，是国外软件，风格偏欧美风，我其实比较喜欢这种操作方式，简单易懂，连接同一个电脑，连续输入两次验证码，下次再点击接该电脑就直接连接了。 对比这两个软件，Splashtop切换不同电脑连接要更快些，而且不用每次都输验证码，相对方便些，所以就给产品经理推荐了这个软件来操作。 最终实施哈哈，以为这就OK了吗，NO，今天来公司，产品经理说昨晚给CEO看了，CEO觉得这样切换还是太慢，给了个建议，让4个电视通过HDMI方式连到一个电脑上，这样的话就用iPad操控一台电脑就可以了，不存在切换慢的问题了，仔细想了下，这种方案还真不错，有可行性，然后开撸，将4台电视连接到了一台电脑上（专门有HDMI拓展外接，所以接口足够），然后分屏显示。 1. Splashtop连接其实我真的是蛮喜欢Splashtop的，操作简单，可惜的是Splashtop只支持双屏显示，切换分屏始终只显示第1第2分屏。 2. 向日葵连接换了向日葵来连接，满怀期望的希望它支持多屏，结果不负众望，4台分屏完美切换，速度流畅，好，就用它了。 总结总的来说，这次需求完成还是比较满意的，上面领导也满意这个结果，这次分享希望能给需要iPad控制多屏电视的人带来帮助，有什么问题请在评论区告诉我吧。","categories":[{"name":"Others","slug":"Others","permalink":"https://tangyanqiong.com/categories/Others/"}],"tags":[{"name":"iPad控制多屏","slug":"iPad控制多屏","permalink":"https://tangyanqiong.com/tags/iPad控制多屏/"},{"name":"远程桌面控制","slug":"远程桌面控制","permalink":"https://tangyanqiong.com/tags/远程桌面控制/"},{"name":"向日葵","slug":"向日葵","permalink":"https://tangyanqiong.com/tags/向日葵/"},{"name":"Splashtop","slug":"Splashtop","permalink":"https://tangyanqiong.com/tags/Splashtop/"}]},{"title":"Vue框架底层原理","slug":"vue-use","date":"2019-03-20T09:58:17.000Z","updated":"2019-07-26T09:44:56.000Z","comments":true,"path":"post/d32be447.html","link":"","permalink":"https://tangyanqiong.com/post/d32be447.html","excerpt":"前言Vue框架是什么，怎么用，相信大家都已经很熟悉了，诚如Vue教程所说，它是一套构建用户界面的渐进式Web前端框架。 但是很多人就是拿来主义，就只管用，博主也是这类人 = =!, 但是随着深入使用Vue，越发觉得深知其原理的重要性，那么，本文来探讨一下Vue的底层原理到底是什么，是怎么实现的。","text":"前言Vue框架是什么，怎么用，相信大家都已经很熟悉了，诚如Vue教程所说，它是一套构建用户界面的渐进式Web前端框架。 但是很多人就是拿来主义，就只管用，博主也是这类人 = =!, 但是随着深入使用Vue，越发觉得深知其原理的重要性，那么，本文来探讨一下Vue的底层原理到底是什么，是怎么实现的。 目录概括Vue的底层原理总体来说就是深入响应式原理，它最独特的特性之一就是非侵入性的响应式系统。数据模型仅仅是普通的 JavaScript 对象。而当你修改它们时，视图会进行更新，这使得状态管理非常简单直接。 详解双向绑定下面是一段代码，较直观的体现了Vue特点，如下： 1234567891011121314151617181920212223&lt;div id=&quot;mvvm-app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;word&quot;&gt; &lt;p&gt;&#123;&#123;word&#125;&#125;&lt;/p&gt; &lt;button v-on:click=&quot;sayHi&quot;&gt;change model&lt;/button&gt; //点击这个button，word的值会发生改变&lt;/div&gt;&lt;script src=&quot;./js/observer.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./js/watcher.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./js/compile.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./js/mvvm.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var vm = new MVVM(&#123; el: &apos;#mvvm-app&apos;, data: &#123; word: &apos;Hello World!&apos; &#125;, methods: &#123; sayHi: function() &#123; this.word = &apos;Hi, everybody!&apos;; &#125; &#125; &#125;);&lt;/script&gt; 实现效果如下： 而Vue实现数据双向绑定的效果，需要三大模块： Observer：对数据对象的所有属性进行监听，如有变动可拿到最新值并通知观察者 Compile：对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数 Watcher：作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图 ObserverObserver的核心是通过Obeject.defineProperty()来监听数据的变动，这个函数内部可以定义setter和getter，每当数据发生变化，就会触发setter。这时候Observer就要通知订阅者，订阅者就是Watcher。 WatcherWatcher订阅者作为Observer和Compile之间通信的桥梁，主要做的事情是： 在自身实例化时往属性订阅器(dep)里面添加自己 自身必须有一个update()方法 待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调 CompileCompile主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图。 总结MVVM 是Model-View-ViewModel 的缩写，它是一种基于前端开发的架构模式，其核心是提供对View 和 ViewModel 的双向数据绑定，这使得ViewModel 的状态改变可以自动传递给 View，即所谓的数据双向绑定。 而Vue框架则是一个提供了 MVVM 风格的双向数据绑定的 Javascript 库，专注于View 层。它的核心是 MVVM 中的 VM，也就是 ViewModel。 ViewModel负责连接 View 和 Model，保证视图和数据的一致性，这种轻量级的架构让前端开发更加高效、便捷。","categories":[{"name":"Web","slug":"Web","permalink":"https://tangyanqiong.com/categories/Web/"},{"name":"Vue","slug":"Web/Vue","permalink":"https://tangyanqiong.com/categories/Web/Vue/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://tangyanqiong.com/tags/JavaScript/"},{"name":"Vue","slug":"Vue","permalink":"https://tangyanqiong.com/tags/Vue/"},{"name":"MVVM","slug":"MVVM","permalink":"https://tangyanqiong.com/tags/MVVM/"}]},{"title":"初探JavaScript的变量","slug":"js-var","date":"2019-02-25T08:12:34.000Z","updated":"2019-07-26T09:43:36.000Z","comments":true,"path":"post/6e5ac6c0.html","link":"","permalink":"https://tangyanqiong.com/post/6e5ac6c0.html","excerpt":"基本类型和引用类型的值ECMAScript变量一般有两种数据类型的值：基本类型和引用类型。 基本类型： 简单的数据段：Undefined, Null, Boolean, Number, String 引用类型：多个值构成的对象；","text":"基本类型和引用类型的值ECMAScript变量一般有两种数据类型的值：基本类型和引用类型。 基本类型： 简单的数据段：Undefined, Null, Boolean, Number, String 引用类型：多个值构成的对象； 1. 动态的属性定义两者的值：创建一个变量并为其变量赋值； 执行两者的值： 引用类型：可以添加、删除属性和方法； 基本类型：不能添加、删除属性和方法； 比如：引用类型 a，可以添加属性 name age1234var a = new Object();a.name = \"杨子龙\";a.age = 24;console.log(a.name); //杨子龙 基本类型 name 无法添加属性 age123var name = \"杨子龙\";name.age = 24;console.log(name.age); //undefined 代码中可知：只能给引用类型值动态地添加属性，以便将来使用。 2. 赋值变量值从一个变量向另一个变量复制基本类型值和引用类型值时： 基本类型：在变量对象上创建一个新值，并将其值复制给新变量分配的位置上；（完全独立的两个变量）例如： 123var a = 111;var b = a;console.log(b); //111 代码中可知：变量b的值只是变量a的值的一个副本，两者的值111是完全独立的。 引用类型：将存储在变量对象中的值复制一份放到为新变量分配的空间中；（引用同一个对象的两个变量） 引用类型的值的副本实际是一个指针，指向存储在堆中的一个对象。例如：1234var obj1 = new Object;var obj2 = obj1;obj1.name = \"杨子龙\";console.log(obj2,name); // Object &#123; name=\"杨子龙\"&#125; 杨子龙 代码中可知：obj1和obj2都指向同一个对象Object；所以，为obj1添加的name属性，通过obj2也可以访问的到。 3. 传递参数我们都知道基本类型是按值访问的，因为可以访问保存在变量中的实际的值。所有函数的参数都是按值传递的。 基本类型：基本类型值的传递如同基本类型变量的复制一样；在向参数传递值，被传递的值会被复制给一个局部变量（命名参数），因此这个局部变量的变化不会反映在函数的外部。 例如： 12345678function fn(num) &#123; num += 10; return num;&#125;var a = 10;var result = fn(a);console.log(result); //20console.log(a); //10 代码中可知：参数num和变量a互不相识，只是有着相同的值而已，用完之后，你还是你，我还是我，互不干政。 引用类型：引用类型的传递如同引用类型变量的复制一样；在向参数传递值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。 例如：123456function fn(obj) &#123; obj.name = '杨子龙';&#125;var person = new Object();fn(person);console.log(person.name); //杨子龙 代码中可知：在这个函数内部，参数obj和变量person引用的是同一个对象Object，所以，你不动我也不动，你动我也动，你中有我，我中有你，情义绵绵，经久不息…… 也就是说：即使变量person是按值传递的，但是参数obj（想象成局部变量）还是会按引用来访问同一个对象。 访问变量有按值和按引用两种方式，参数只能按值传递。 4. 检测类型 基本类型：typeof 引用类型：instanceof（对象或null） 例如： 1234567891011121314151617var a = 'Yang Zilong';var b = 24;var c = '';var d = true;var e;var g = undefined;var f = null; // 比较特殊var h = new Object();console.log(typeof a); //stringconsole.log(typeof b); //number console.log(typeof c); //stringconsole.log(typeof d); //booleanconsole.log(typeof e); //undefinedconsole.log(typeof g); //undefinedconsole.log(typeof f); //objectconsole.log(typeof h); //object 所用引用类型的值都是Object的实例。 如下：12345678var person = new Object();var num = [1,2, 3];var pattern = /.at/i;console.log(person instanceof Object); //trueconsole.log(num instanceof Object); //trueconsole.log(num instanceof Array); //trueconsole.log(pattern instanceof Object); //trueconsole.log(pattern instanceof RegExp); //true 使用instanceof检测基本类型，会返回false，基本类型不是对象。 参考资料：《JavaScript高级程序设计》（第三版）第四章 同步于： 掘金、慕课网","categories":[{"name":"Web","slug":"Web","permalink":"https://tangyanqiong.com/categories/Web/"},{"name":"JS","slug":"Web/JS","permalink":"https://tangyanqiong.com/categories/Web/JS/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://tangyanqiong.com/tags/JavaScript/"}]},{"title":"Swift中UILabel设置角标","slug":"Swift设置角标","date":"2018-12-20T07:10:08.000Z","updated":"2019-06-06T01:48:00.000Z","comments":true,"path":"post/f0789496.html","link":"","permalink":"https://tangyanqiong.com/post/f0789496.html","excerpt":"项目开发中，我们往往会遇到客户提出设置角标的需求，如下图： 这种是怎么实现的呢？","text":"项目开发中，我们往往会遇到客户提出设置角标的需求，如下图： 这种是怎么实现的呢？ 其实也很简单，我们用富文本就能实现这种方式。 12345678let text = (textLabel.text)!let attrText = NSMutableAttributedString(string: text)var: scaleRange = (text as NSString).range(of: &quot;r&quot;)attrText.addAttribute(NSAttributedString.Key.font, value: UIFont.systemFont(ofSize: textLabel.font.pointSize*0.8), range: scaleRange) //设置角标的字体大小 attrText.addAttribute(NSAttributedString.Key.foregroundColor, value: textLabel.textColor, range: scaleRange) //设置角标的字体颜色textLabel.attributedText = attrText 那-1在右上角的这种方式又是怎么实现的呢？ 如下： 12scaleRange = (text as NSString).range(of: &quot;-1&quot;)attrText.addAttribute(NSAttributedString.Key.baselineOffset, value: (textLabel.font.pointSize*0.4), range: scaleRange) 同理，在OC里，同样用富文本也可实现角标显示。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://tangyanqiong.com/categories/iOS/"},{"name":"Swift","slug":"iOS/Swift","permalink":"https://tangyanqiong.com/categories/iOS/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://tangyanqiong.com/tags/Swift/"},{"name":"角标","slug":"角标","permalink":"https://tangyanqiong.com/tags/角标/"}]},{"title":"Git使用命令行管理","slug":"Git-常用命令练习","date":"2018-12-14T14:45:16.000Z","updated":"2019-07-26T09:48:25.000Z","comments":true,"path":"post/c0119d4f.html","link":"","permalink":"https://tangyanqiong.com/post/c0119d4f.html","excerpt":"前言平时项目中很常用的代码管理工具就是git了，其实有很好的类似SourceTree这样的工具来管理git，但是本文所讲的是通过终端命令行来管理git。 原理 Workspace: 工作区 Index / Stage: 暂存区 Repository: 仓库区（或本地仓库） Remote: 远程仓库","text":"前言平时项目中很常用的代码管理工具就是git了，其实有很好的类似SourceTree这样的工具来管理git，但是本文所讲的是通过终端命令行来管理git。 原理 Workspace: 工作区 Index / Stage: 暂存区 Repository: 仓库区（或本地仓库） Remote: 远程仓库 管理新建12345678# 在当前目录 git-command 下新建 Git 代码库，（会生成 .git 文件）git init# 新建目录 git-command 并将其初始化为 Git 代码库git init git-command# 从线上获取一个完整的项目代码git clone https://github.com/yangtao2o/git-command.git 配置Git的设置文件为 .gitconfig ，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 12345678# 显示配置信息git config --list# 修改git config --globalgit config --global user.name \"yangtao\"git config --global user.email \"xxx@.qq.com\" 增加、删除文件123456789101112131415161718192021# 添加指定文件到暂存区git add index.html# 添加指定目录到暂存区，包括子目录git add assets# 添加当前目录的所有文件到暂存区git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交git add -p# 删除工作区文件，并将这次删除加入暂存区git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区git rm --cached [file]# 修改文件名，并放入暂存区git mv index.html index-new.html 代码提交123456789101112131415161718# 暂存区提交到仓库区 ( -m (msg) )git commit -m \"My first commit\"# 指定文件提交git commit [file1] [file2] ... -m [message]# 提交工作区自上次 commit 之后的变化，直接到仓库区git commit -a# 提交时显示所有的 diff 信息git commit -v# 使用一次新的 commit ，提交上一次提交# 如果代码没有任何变化，则用来改写上一次 commit 的提交信息git commit --amend -m \"new commit\"# 重做上一次 commit ，并包括指定文件的新变化git commit --amend [file1] [file2] ... 分支123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有的本地分支git branch# 列出所有的远程分支 ( -r (remotes))git branch -r# 列出所有的本地分支和远程分支git branch -a# 新建一个分支，但依然停留在当前分支git branch primary# 新建，并切换至 该分支git checkout -b primary-yt# 新建，指向指定 commitgit branch [branch] [commitID]# 新建，与指定的远程分支建立追踪关系git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区git checkout [branch-name]# 切换到上一个分支git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间git branch --set-upstream [branch] [remote-branch]# 合并指定分支 master-yt 到当前分支 mastergit merge master-yt# 选择一个\b commit，合并进当前分支git cherry-pick [commitid]# 删除分支git branch -d master-ytt# 删除远程分支git push origin --delete [branch-name]git branch -dr [remote/branch] 标签12# 列出标签git tag 查看信息12345# 显示有变更的文件git status# 显示当前分支的版本历史git log 参考目录 Git常用命令 Git教程 - 廖雪峰的官方网站","categories":[{"name":"Others","slug":"Others","permalink":"https://tangyanqiong.com/categories/Others/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://tangyanqiong.com/tags/Git/"},{"name":"代码管理工具","slug":"代码管理工具","permalink":"https://tangyanqiong.com/tags/代码管理工具/"}]},{"title":"iOS纯播放器（适配器）","slug":"iOS播放器适配器","date":"2018-12-06T02:45:35.000Z","updated":"2019-07-26T08:18:34.000Z","comments":true,"path":"post/4d0d70a6.html","link":"","permalink":"https://tangyanqiong.com/post/4d0d70a6.html","excerpt":"前言背景以前写过一套播放器，详见iOS流媒体播放器，结合了UI与播放层，集成使用很方便，但是呢，定制性很强，想要修改UI层或新增另外的功能，比较不好拓展，还因为公司播放类的项目很多，也为了能适用到其他项目，不同项目不同UI层或者有些定制化的需求，所以我将UI与播放层进行了拆分，使播放器变得更纯粹。 诞生由此，一个纯播放层播放器TDPlayerLite应运而生，哈哈，该播放器采取适配器模式，有基于AVPlayer封装的，也可集成其他播放器，例DRM播放器，或者音乐播放器，都可以，这样对在项目中不同地方使用不同播放器提供很大便利。","text":"前言背景以前写过一套播放器，详见iOS流媒体播放器，结合了UI与播放层，集成使用很方便，但是呢，定制性很强，想要修改UI层或新增另外的功能，比较不好拓展，还因为公司播放类的项目很多，也为了能适用到其他项目，不同项目不同UI层或者有些定制化的需求，所以我将UI与播放层进行了拆分，使播放器变得更纯粹。 诞生由此，一个纯播放层播放器TDPlayerLite应运而生，哈哈，该播放器采取适配器模式，有基于AVPlayer封装的，也可集成其他播放器，例DRM播放器，或者音乐播放器，都可以，这样对在项目中不同地方使用不同播放器提供很大便利。 集成与使用实现模式TDPlayerLite采用适配器模式，所有对外的方法和代理都放在BasePlayer类，需要集成某播放器时，以集成系统播放器AVPlayer为例，继承BasePlayer类生成ReAVPlayer类，在ReAVPlayer类里实现AVPlayer的装载，也实现BasePlayer类对外暴露的方法。 优点：这种模式能够快速集成不同播放器到项目中，且不会影响到原项目。 导入Demo里PlayerAdapter直接拖往工程里，就可直接使用。 目录PlayerManager12345678910/** 播放器类型，目前有系统播放器及DRM播放器 */typedef enum _PlayerManagerType&#123; PlayerManagerTypeNone = 0, PlayerManagerTypeAVPlayer = 1, PlayerManagerTypeVisualOnPlayer = 2 //DRM //还可添加其他类型的播放器&#125; PlayerManagerType; 使用PlayerManager类可传入不同类型生成对应播放器： 1self.player = [[PlayerManager manager] getPlayerBy:self.playerView andPlayerType:PlayerManagerTypeVisualOnPlayer]; 若不传入Type，默认生成AVPlayer播放器 BasePlayer它是播放器基类，其实BasePlayer.h里注释已经写得很全面了，每个属性和方法的使用和用途都有注释，这里不赘述了。 说下BasePlayer这个类的作用，写这个类的目录是为了把与外部交互数据统一化，且把播放器产生的数据全面的归整统一对外提供，后面集成进来的播放器，都继承这个基类，实现其方法。 例如： 此自定义的播放器状态基本概括了全部状态，对用户特别友好，能够在不同状态提示用户，提升了用户体验。 BTW：系统播放器AVPlayer经常就有乱调、部分视频状态没有的情况，所以我在ReAVPlayer做了兼容性处理，当你需要集成其他播放器时，也需要做相关处理，保证最外层使用的Player的使用完整性。 BasePlayer_Methods扩展类，可加入BasePlayer的扩展接口或属性。 ReAVPlayer该类继承于BasePlayer，里面装载了系统播放器AVPlayer，使用该类实际就是使用系统播放器，AVPlayer一些兼容性处理也放在了里面。 总结这个播放器我们已经应用到了很多项目中，也已经上线测试了很多版本，已经是很稳定的版本了，不用担心在使用中会出现什么奇怪难解的问题了。 另，目前TDPlayerLite相当于是一个播放器的适配器，如果你只是单纯的想用一个稳定友好的系统播放器，可直接导入Players文件夹使用。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://tangyanqiong.com/categories/iOS/"},{"name":"OC","slug":"iOS/OC","permalink":"https://tangyanqiong.com/categories/iOS/OC/"}],"tags":[{"name":"Object-C","slug":"Object-C","permalink":"https://tangyanqiong.com/tags/Object-C/"},{"name":"AVPlayer","slug":"AVPlayer","permalink":"https://tangyanqiong.com/tags/AVPlayer/"},{"name":"DRMPlayer","slug":"DRMPlayer","permalink":"https://tangyanqiong.com/tags/DRMPlayer/"},{"name":"适配器","slug":"适配器","permalink":"https://tangyanqiong.com/tags/适配器/"}]},{"title":"学习JavaScript深入系列简要总结","slug":"学习JavaScript深入系列简要总结","date":"2018-10-31T15:07:42.000Z","updated":"2019-07-26T09:41:49.000Z","comments":true,"path":"post/6ec5e01.html","link":"","permalink":"https://tangyanqiong.com/post/6ec5e01.html","excerpt":"从原型到原型链原文地址：JavaScript深入之从原型到原型链 每一个函数都有一个prototype属性，该属性指向了一个对象，此对象为调用该函数而创建的实例的原型","text":"从原型到原型链原文地址：JavaScript深入之从原型到原型链 每一个函数都有一个prototype属性，该属性指向了一个对象，此对象为调用该函数而创建的实例的原型 每一个对象（除null）都具有一个属性：__proto__，这个属性指向该对象的原型 每个原型都有一个constructor属性指向关联的构造函数 原型对象是通过 Object 构造函数生成的，最后Object.prototype.__proto__ = null 词法作用域和动态作用域原文链接：JavaScript深入之词法作用域和动态作用域 javascript采用的是词法作用域(lexical scoping)，函数的作用域是在函数定义的时候就决定了，而不是调用的时候才决定 词法作用域，即静态作用域，函数的作用域在函数定义的时候就决定了 动态作用域，函数的作用域是在函数调用的时候才决定 执行上下文栈当执行一个函数的时候，就会创建一个执行上下文(execution context)，并且压入执行上下文栈(Execution context stack, ESC) 当函数执行完毕的时候，会将函数的执行上下文栈中弹出 变量对象1、全局上下文的变量对象初始化：全局对象 2、函数上下文的变量对象初始化：只包括Arguments对象 3、进入执行上下文时：给变量对象添加形参、函数声明、变量声明等初始的属性值 4、代码执行阶段：再次修改变量对象的属性值 总结：未进入执行阶段之前，变量对象(VO)中的属性都不能访问！但是进入执行阶段之后，变量对象(VO)转变为了活动对象(AO)，里面的属性都能被访问了，然后开始进行执行阶段的操作。它们其实都是同一个对象，只是处于执行上下文的不同生命周期。 最后，函数是“第一等公民”，记住这个，变量名称和函数名称相同的声明，优先执行函数声明 作用域从ECMAScript规范解读this执行上下文闭包闭包是指那些能够访问自由变量的函数。 自由变量是指在函数中使用的，但既不是参数也不是函数的局部变量的变量。 那么，闭包 = 函数 + 函数能够访问的自由变量。 参数按值传递ECMAScript中所有函数的参数都是按值传递的。 即，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制给另一个变量一样。 参数如果是基本类型是按值传递，如果是引用类型按共享传递。 共享传递是指，在传递对象的时候，传递对象的引用的副本。 call和apply的模拟实现call()在使用一个指定的this值和若干个指定的参数值的前提下，调用某个函数或方法。 12345678910111213Function.prototype.mycall = function(context) &#123; var context = context || window; //获取调用call的函数，用this可以获取 context.fn = this; var args = []; for (var i = 1, l = arguments.length; i &lt; l; i++) &#123; args.push('arguments[' + i + ']'); &#125; // 把传给call的参数传递给了context.fn函数 var result = eval('context.fn(' + args + ')'); delete context.fn; return result;&#125; apply()同call()，只不过将多个参数值，以数组的形式传入而已。 12345678910111213141516Function.prototype.myapply = function(context, arr) &#123; var context = Object(context) || window; context.fn = this; var result; if (!arr) &#123; result = context.fn(); &#125; else &#123; var args = []; for (var index = 0; index &lt; arr.length; index++) &#123; args.push('arr[' + index + ']'); &#125; result = eval('context.fn(' + args + ')'); &#125; delete context.fn; return result;&#125; bind的模拟实现bind()方法会创建一个新函数。当这个新函数被调用，bind()第一个参数将作为它运行时的this，之后的一系列参数将会在传递的实参前传入，作为它的参数。 new的模拟实现new运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象类型之一。","categories":[{"name":"Web","slug":"Web","permalink":"https://tangyanqiong.com/categories/Web/"},{"name":"JS","slug":"Web/JS","permalink":"https://tangyanqiong.com/categories/Web/JS/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://tangyanqiong.com/tags/JavaScript/"}]},{"title":"【转】高效学习JavaScript的六个思维技巧","slug":"js-learn","date":"2018-10-22T14:11:53.000Z","updated":"2019-07-26T09:42:39.000Z","comments":true,"path":"post/f78e3d89.html","link":"","permalink":"https://tangyanqiong.com/post/f78e3d89.html","excerpt":"初始整理于慕课网手记高效学习JavaScript的六个思维技巧","text":"初始整理于慕课网手记高效学习JavaScript的六个思维技巧 更快学习JavaScript的六个思维技巧 当人们试图学习JavaScript或其他编程语言的时候，他们通常会遇到如下挑战。 1234567891. 一些概念让他们感到困惑，特别是如果之前学过其他类型的语言。2. 很难找到学习的时间（或者动力）去学习。3. 你很容易忘掉之前学到的东西。4. JavaScript工具太多并且经常更新，以至于很难找到学习的切入点。5. ... 幸运的是，这些难题最终能够被克服。在这篇文章，我将展示六个能够帮助你更快、更开心、更高效地学习JavaScript的六个思维技巧。 1、不要让对未来的忧虑干扰你现在的学习 有些JavaScript初学者会问刚开始要学习哪种框架，但是如果你还没能熟练使用原生JavaScript，你就不应该问这种问题。因为你会花很多时间研究各种框架而得不到进步。 走出这个陷阱的一个方法是制定一个学习路径图。例如，要成为前端开发，你的路径图可能是下图。在将来你能够使用HTML和CSS制作动态页面。 2、不要让自信骗你进入持续遗忘的陷阱快速理解一个概念会是JavaScript进步的最大阻碍，下面我将解释。 当你遇到一个知识点，而你好像理解了，你很可能抑制不住内心跳到下一个知识点的冲动。 现实可能是你会理解下一个知识点然后继续跳到下一个知识点。 但是，很快你会到达一个节点，在这个节点你发现自己已经忘了前面所学，于是你需要回过头复习，你快速瞟了一下之前所学然后又继续学习新的知识。 但是现在，你忘记了其他东西。 你一直重复这种继续-回顾-继续-回顾模式直到你发现自己完全迷失。 你开始沮丧，想要休息，然后当你开始重振旗鼓，却发现自己已经忘掉所有。 幸运的是，我们有两个应对上述问题的方法： 一次只学一样东西； 做练习——实际就是敲代码； 当你学习一个新的概念，你要将它实践出来，练习它，与它和善相处，甚至能够将它与其他概念联系到一起。 当你学习一个示例，最重要的是你要自己将代码敲出来，这样能帮助你吸收它。另外，一次只学一个东西能够帮助你巩固所学，因为记忆更少的东西更容易。 这个过程看起来貌似比阅读然后快速跳到下一个知识点要花费更长的时间，但是实际上它所花的时间更少，因为这样你就不需要频繁复习之前所学。我在好几个场合后才艰难的领悟到这个道理。 3、使用正确的思维方式练习很多人认为敲代码是烦人的重复性工作，所以他们通常会跳过这个步骤试着寻找捷径。如果你试图为JavaScript练习寻找捷径，你将会为此花费更多的时间。 但是我们如何才能使得敲代码更加的有趣，使得我们愿意去敲代码呢？ 试着改变为下面的思维模式： 如果你刚学了一个JavaScript概念，然而你被告知不能使用它，对此你感觉如何？个人来说我会感到有点恼火，特别是为了弄懂它我花费了宝贵的时间。这就像是一个小孩得到了一个新的玩具，但却被限制不能玩它。 当你学习JavaScript的新知识，试着将这个知识点视作一个新玩具，例如新车、一双新鞋、或任何你觉得值得有趣的东西。然后，不要把敲代码当成工作，将敲代码视作你正在玩游戏。你正在使用刚学的技能做一些很酷的事情。给自己惊喜，把成果展示给你的朋友。 带着游戏的思维模式你将学得更快，将记忆的更牢，同时你将体会到更多乐趣。 4、使用Facebook技巧为编程腾时间 人们遇到的一个普遍问题是，他们通常找不到时间去敲代码。通常，这些人会花好几个小时浏览例如Facebook、YouTube、Wikipedia或者Reddit这样的网站。无论你是否符合上述描述，我们都能从中学到一些东西。 我当然有时间只浏览Facebook一会儿，但通常我会在上面待好几个小时浏览往返。这是如何发生的？我认为原因在于，刚开始我并没打算花在这上面花费那么多时间。开始行动是做一件事情最困难的部分，所以将目标设定的足够小能够帮助我们进入状态。如果有人问我是不是打算花几个小时浏览Facebook，我会回答不，因为我没有时间。然而，对于仅仅尝试一下我是能够接受的，这也是我能够沉浸其中的方法。 好消息是，你能够对敲代码运用同样的心理技巧。 不要计划花几个小时敲代码，因为你会发现自己没有时间。 相反的，告诉自己只敲三分钟代码。这样你就不需要为寻找敲代码的时间烦心。 5、思考的更慢你将学得更快 这一条听起来违反直觉，所以下面我将用一个故事来解释。 我的一个朋友又一次对JavaScript的一个特性感到困惑。我让他将他知道的解释给我听，然后告诉我哪儿让他困惑。当它向我解释代码，我发现他在跳步。 “等会儿！”我说道。“慢慢来，然后将这些一步步解释给我听。” 我的朋友直接将整个代码的功能总结给我听。 我再次让他暂停。“你还是在跳步。再解释一次，这次我需要你一步步将每一行代码发生了什么解释给我听。” 这一次，我的朋友能够更好的解释代码是如何运行的。关键在于他花时间去理解每一行代码而不是试图一下理解所有。 在上述这种案例中，思考的更慢实际上让你学得更快。 6、在写复杂代码前先用简单语言写下 如果你要写的代码是复杂并且不常见的，先用简单语言将代码写下。这样，你能够你能够在真正写之前知道自己要做什么。下面是使用这个方法的两个好处： 你将更容易更快速的写代码，因为你不需要时刻停下来思考自己将要怎么做。 由于你知道代码要干什么，能够更好的排除错误。 总结 我们已经讲了好几个更快速学习JavaScript的方法，但是你也能将上述方法运用于学习其他东西。下面是上述方法的概括： 1234567（1）、不要再想将要学什么，沉浸于现在；（2）、通过把新技能当做玩具使得练习更有趣；（3）、就像浏览Facebook、YouTube之类的网站一样，在敲代码前告诉自己只敲几分钟，这样你就拥有了敲代码的时间；（4）、慢下来，小步向前，你将学得更快。 本文转载自：众成翻译 译者：Ryan 链接：http://www.zcfy.cc/article/436","categories":[{"name":"Web","slug":"Web","permalink":"https://tangyanqiong.com/categories/Web/"},{"name":"JS","slug":"Web/JS","permalink":"https://tangyanqiong.com/categories/Web/JS/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://tangyanqiong.com/tags/JavaScript/"}]},{"title":"JS设计模式学习之单例模式","slug":"mode-单例模式","date":"2018-10-03T13:24:26.000Z","updated":"2019-07-26T09:44:33.000Z","comments":true,"path":"post/23158cb2.html","link":"","permalink":"https://tangyanqiong.com/post/23158cb2.html","excerpt":"什么是单例模式？ 保证一个类仅有一个实例，并提供一个访问它的全局访问点 用一个变量标志当前是否已经为某个类型创建过对象，如果是，则下次直接返回之前创建的对象。 1234567891011121314151617181920var Singleton = function (name) &#123; this.name = name; this.instance = null;&#125;Singleton.prototype.getName = function () &#123; console.log(this.name);&#125;Singleton.getInstance = function (name) &#123; if (!this.instance) &#123; this.instance = new Singleton(name); &#125; return this.instance;&#125;var a = Singleton.getInstance('Tony1');var b = Singleton.getInstance('Tony2');console.log(a === b); // true 通过 Singleton.getInstance来获取 Singleton 类的唯一对象，里边使用了 new 来获取，导致了这个类的“不透明性”。","text":"什么是单例模式？ 保证一个类仅有一个实例，并提供一个访问它的全局访问点 用一个变量标志当前是否已经为某个类型创建过对象，如果是，则下次直接返回之前创建的对象。 1234567891011121314151617181920var Singleton = function (name) &#123; this.name = name; this.instance = null;&#125;Singleton.prototype.getName = function () &#123; console.log(this.name);&#125;Singleton.getInstance = function (name) &#123; if (!this.instance) &#123; this.instance = new Singleton(name); &#125; return this.instance;&#125;var a = Singleton.getInstance('Tony1');var b = Singleton.getInstance('Tony2');console.log(a === b); // true 通过 Singleton.getInstance来获取 Singleton 类的唯一对象，里边使用了 new 来获取，导致了这个类的“不透明性”。 透明的单例模式创建一个“透明”的单例类，就是让我们从这个类中创建对象的时候可以和使用其他普通类一样：var aa = new CreateDiv(&#39;Sisi1&#39;); 1234567891011121314151617181920212223242526var CreateDiv = (function () &#123; var instance; var CreateDiv = function (html) &#123; if (instance) &#123; return instance; &#125; this.html = html; this.init(); return instance = this; &#125;; CreateDiv.prototype.init = function () &#123; var div = document.createElement('div'); div.innerHTML = this.html; document.body.appendChild(div); &#125;; return CreateDiv;&#125;)();var aa = new CreateDiv('Sisi1');var bb = new CreateDiv('Sisi2');console.log(aa === bb); // true 下面这段代码中，CreateDiv 的构造函数负责了两件事：创建对象和执行初始化 init 方法，及保证只有一个对象： 12345678var CreateDiv = function (html) &#123; if (instance) &#123; return instance; &#125; this.html = html; this.init(); return instance = this;&#125;; 但是，如果我们要创建很多的div，这里的 return instance = this; 就需要删掉。 用代理实现单例模式这时候，为了避免上面不能复用的尴尬，通过引入代理类的方式，把负责管理单例的逻辑移交至代理类ProxySingletonCreateDiv，这样CreateDiv只是一个普通的类。 12345678910111213141516171819202122232425var CreateDiv = function (html) &#123; this.html = html; this.init();&#125;;CreateDiv.prototype.init = function () &#123; var div = document.createElement('div'); div.innerHTML = this.html; document.body.appendChild(div);&#125;var ProxySingletonCreateDiv = (function () &#123; var instance; return function (html) &#123; if (!instance) &#123; instance = new CreateDiv(html); &#125; return instance; &#125;&#125;)();var aa = new ProxySingletonCreateDiv('Tony1');var bb = new ProxySingletonCreateDiv('Tony2');console.log(aa === bb); // true JavaScript 中的单例模式单例模式的核心是：确保只有一个实例，并提供全局访问。 使用命名空间 对象字面量的方式: 12345678910var namespace1 = &#123; a: function() &#123; console.log(1); &#125;, b: function() &#123; console.log(2); &#125;&#125;namespace1.a(); //1 把a和b都定义为 namespace1 的属性，减少了变量和全局作用域打交道的机会，还可以动态地创建命名空间： 1234567891011121314151617181920212223242526272829303132333435363738394041424344var MyApp = &#123;&#125;;MyApp.namespace = function (name) &#123; var parts = name.split('.'); var current = MyApp; for (var i in parts) &#123; if (!current[parts[i]]) &#123; current[parts[i]] = &#123;&#125;; &#125; current = current[parts[i]]; &#125;&#125;MyApp.namespace('event');MyApp.namespace('dom.style');console.log(MyApp);// 相当于：var MyApp = &#123; event: &#123;&#125;, dom: &#123; style: &#123;&#125; &#125;&#125;``` 2. 使用闭包封装私有变量使用下划线约定私有变量 _name 和 _age。```jsvar user = (function () &#123; var _name = 'Seven'; var _age = 27; return &#123; getUserInfo: function () &#123; return _name + '-' + _age; &#125; &#125;&#125;)();console.log(user.getUserInfo()) // Seven-27 惰性单例宗旨：在需要的时候才创建对象！！！ 栗子：QQ的登录浮窗 第一种方案：页面加载完成的时候便创建好浮窗。 1234567891011var loginLayer = (function () &#123; var div = document.createElement('div'); div.innerHTML = '我是一个小小的悬浮框'; div.style.display = 'none'; document.body.appendChild(div); return div;&#125;)();document.getElementById('loginBtn').addEventListener('click', function () &#123; loginLayer.style.display = 'block';&#125;); 但是，不管我们登录与否，都会创建悬浮窗，所以我们可以修改为：在点击登录的时候再创建悬浮窗。 123456789101112var createLoginLayer = function () &#123; var div = document.createElement('div'); div.innerHTML = '我是一个小小的悬浮框'; div.style.display = 'none'; document.body.appendChild(div); return div;&#125;;document.getElementById('loginBtn').addEventListener('click', function () &#123; var loginLayer = createLoginLayer(); loginLayer.style.display = 'block';&#125;); 这时候，虽然达到了惰性的目的，却失去了单例的效果，每次点击登录，都会创建一个新的悬浮窗。 所以我们需要一个变量来判断是否已经创建过悬浮窗： 1234567891011121314151617var createLoginLayer = (function () &#123; var div; return function () &#123; if (!div) &#123; // 判断是否已创建 div = document.createElement('div'); div.innerHTML = '我是一个小小的悬浮框'; div.style.display = 'none'; document.body.appendChild(div); &#125; return div; &#125;&#125;)();document.getElementById('loginBtn').addEventListener('click', function () &#123; var loginLayer = createLoginLayer(); loginLayer.style.display = 'block';&#125;); 通用的惰性单例虽然上面的悬浮框是一个可用的惰性单例，但是仍然违反了单一职责原则，如果我们要创建其他的标签，就需要把创建悬浮窗的函数复制一份，再修修改改，无法做到复用。 所以，我们需要把不变的部分隔离出来，进行抽象，无论创建什么标签，都是一样的逻辑： 1234var obj;if(!obj) &#123; obj = xxx;&#125; 接着，继续： 123456789101112131415161718192021var getSingle = function (fn) &#123; var result; return function () &#123; return result || (result = fn.apply(this, arguments)); &#125;&#125;var createLoginLayer = function () &#123; var div = document.createElement('div'); div.innerHTML = '我是一个小小的悬浮框'; div.style.display = 'none'; document.body.appendChild(div); return div;&#125;var createSingleLoginLayer = getSingle(createLoginLayer);document.getElementById('loginBtn').addEventListener('click', function () &#123; var loginLayer = createSingleLoginLayer(); loginLayer.style.display = 'block';&#125;); 这时，我们创建其他标签就只需要关系如何创建该标签就可以： 123456789101112var createIframe = function () &#123; var iframe = document.createElement('iframe'); iframe.src = 'https://baidu.com'; document.body.appendChild(iframe); return iframe;&#125;var createSingleIframe = getSingle(createIframe);document.getElementById('loginBtn2').addEventListener('click', function () &#123; createSingleIframe();&#125;); 总结单例模式是一种简单却非常常用的模式，特别是惰性单例技术，在合适的时候才创建对象，并且只创建唯一的一个。 创建对象和管理单例的职责被分布在两个不同的方法中，两个方法组合起来才具有单例模式的威力。","categories":[{"name":"Web","slug":"Web","permalink":"https://tangyanqiong.com/categories/Web/"},{"name":"JS","slug":"Web/JS","permalink":"https://tangyanqiong.com/categories/Web/JS/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://tangyanqiong.com/tags/JavaScript/"},{"name":"单例模式","slug":"单例模式","permalink":"https://tangyanqiong.com/tags/单例模式/"}]},{"title":"页面滑动时的动画插件WOW.js","slug":"wow","date":"2018-09-04T03:16:42.000Z","updated":"2019-07-26T09:53:02.000Z","comments":true,"path":"post/9ac2330d.html","link":"","permalink":"https://tangyanqiong.com/post/9ac2330d.html","excerpt":"当初次加载页面的时候，需要一些动画渐入，并且当滑动到当前内容时也会出现动画，之后就恢复正常，所以就用到了 WOW.js。 比如：RT-Thread 再比如设计师必备：sketchapp","text":"当初次加载页面的时候，需要一些动画渐入，并且当滑动到当前内容时也会出现动画，之后就恢复正常，所以就用到了 WOW.js。 比如：RT-Thread 再比如设计师必备：sketchapp WOW.js文档：WOW Animate.css模拟：Animate animate.css 包含了一组炫酷、有趣、跨浏览器的动画，可以在你的项目中直接使用。 CDN12&lt;link href=\"https://cdn.bootcss.com/animate.css/3.7.0/animate.min.css\" rel=\"stylesheet\"&gt;&lt;script src=\"https://cdn.bootcss.com/wow/1.1.2/wow.min.js\"&gt;&lt;/script&gt; 用法文档：Setup WOW.js 12345678```html&lt;div class=&quot;wow bounceInUp&quot; data-wow-duration=&quot;2s&quot; data-wow-delay=&quot;5s&quot;&gt; Content to Reveal Here&lt;/div&gt;&lt;script&gt; new WOW().init();&lt;/script&gt; ps：初始加载页面的时候，很有可能会出现内容再动画渲染，所以直接设置：`css.wow { visibility: hidden;}","categories":[{"name":"Web","slug":"Web","permalink":"https://tangyanqiong.com/categories/Web/"},{"name":"CSS","slug":"Web/CSS","permalink":"https://tangyanqiong.com/categories/Web/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://tangyanqiong.com/tags/CSS/"}]},{"title":"OC工程怎么转换为Swift工程","slug":"octoswift","date":"2018-08-24T09:42:27.000Z","updated":"2019-05-27T06:32:07.000Z","comments":true,"path":"post/dff23fd2.html","link":"","permalink":"https://tangyanqiong.com/post/dff23fd2.html","excerpt":"前言前段时间用Object-C正在开发一个项目，开发了差不多百分之七八十了，客户通知要求改成Swift语言开发（因为他只会Swift），好吧，一个项目用Swift来写其实也无可厚非，但是这个项目中途来换，可想而知是多么痛苦的事，已经写了好多个OC类。","text":"前言前段时间用Object-C正在开发一个项目，开发了差不多百分之七八十了，客户通知要求改成Swift语言开发（因为他只会Swift），好吧，一个项目用Swift来写其实也无可厚非，但是这个项目中途来换，可想而知是多么痛苦的事，已经写了好多个OC类。 步骤调研之前一开始也在网上找了很多资料，有OC与Swift对应功能的语法解说，也有贴代码用工具直接转的，用过iSwift，但不是很好用，识别率不高，正确率不高。 这些都感觉比较费时（客户只给了一周的时间），然后就在想，有没有一个是直接可以转工程的工具呢？别说，强大的google还真搜出来了，这个软件可以直接转换工程。 实施这个软件叫什么名呢，也不卖关子了，是一个在线转换的网站： OC2Swift 它是提供少量代码免费转换，大家可转换自己的部分代码看看正确性，还可以在线输出Swift代码结果，它可以单文件、文件夹或工程打包在线转换。 不过呢，好的软件都是收费的，具体资费我就不说了（避免托的嫌疑，有需要的上官网自己看吧），对于转换的成本来说这个价格很便宜了。 结果注意点 给大家一个建议，这个购买后使用有流量限制，建议打包的时候把静态库、framwork、SDK、第三方库等相关的剔除后打包上传，转换成功后再放置到对应路径下。 原OC代码留存（原因见下面）。 问题这个工程转换成功后，使用起来就没有一点问题了吗？ 错错错，当初我记得一开始报错不怎么多几十个吧，关键改完后，不断的重编译就暴露更多的错，这样下来估计也改了有几百个错了。 是什么类型的错误 很多都是语法的错误，而Xcode有提示修正的方法，直接鼠标点点点就改好了，比较轻松。 有些是语法不识别的问题，这个就需要自己查资料对应OC代码寻找对应的Swift代码了，所以要留存原OC代码。 有些工程设置的地方报错，但是这个很少，就几处，百度google就能解决。 最后然后，到了这一步，以为万事大吉了吗？哈哈，并没有，有些地方转换虽说没报错，但可能会转错意，需要整体流程跑下，最好找测试再过遍流程，切记。 PS：有些OC库实在没办法转的，就采取桥接的方式使用吧。 总结总体来说，这次的转换是很成功的，原本估时为一周，但是实际2～3天就完成了转换，比较高效率，所以建议大家转换Swift可采取这种方式。 比较遗憾的是，当时时间比较赶，没来得及截图留存给大家，如果觉得文章上有什么疑问，或者实际实践过程中遇到什么问题，欢迎大家在下方留言告诉我，我会第一时间回复你。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://tangyanqiong.com/categories/iOS/"},{"name":"Swift","slug":"iOS/Swift","permalink":"https://tangyanqiong.com/categories/iOS/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://tangyanqiong.com/tags/Swift/"},{"name":"Object-C","slug":"Object-C","permalink":"https://tangyanqiong.com/tags/Object-C/"}]},{"title":"iOS流媒体播放器","slug":"iOS流媒体播放器","date":"2018-08-05T03:02:20.000Z","updated":"2019-07-26T08:18:46.000Z","comments":true,"path":"post/70bc6a39.html","link":"","permalink":"https://tangyanqiong.com/post/70bc6a39.html","excerpt":"前言我写了一个iOS流媒体播放器Demo：TDPlayer，需要的朋友可下载，播放器底层播放这层本文就不做赘述了，本文主要针对TDPlayer（播放与UI）的分解使用讲解，Demo实际效果如下：","text":"前言我写了一个iOS流媒体播放器Demo：TDPlayer，需要的朋友可下载，播放器底层播放这层本文就不做赘述了，本文主要针对TDPlayer（播放与UI）的分解使用讲解，Demo实际效果如下： 集成与使用导入Demo里TDPlayer直接拖往工程里，就可直接使用。 目录TDPlayerConfigTDPlayerConfig.h配置文件，一些自定义配置可在里面设置。 TDPlayerView播放器View层，此层在Player上面，也在播放器UI层的最低层，作为中间层来执行UI层与Player数据交互，对外交互也应是此View来完成。 TDPlayerTopBar播放器Top层，可设置标题，有左右按钮交互事件等。 TDPlayerBottomBar播放器Bottom层，为用户与播放交互层，播放\\暂停，快进\\快退，音量调节，上\\下一页都在这层实现。 TDPlayerStatusView该View简单来所就是用户友好提示页，根据视频的状态来显示加载、正常、结束、失败、错误状态UI，还提供重新播放功能。 TDPlayerLoadingView视频加载过程中出现的加载View，以及还支持显示当前的加载网速。 使用其实对外的接口，我已经封装得比较简单易懂了，外部使用直接使用TDPlayerView这个类，如下：（Demo上还有代理回调的使用） 123456789101112tdPlayerView = [[TDPlayerView alloc] initWithFrame:CGRectMake(0, 0, selfWidth, selfHeight)];tdPlayerView.delegate = self;[self.view addSubview:tdPlayerView]; [tdPlayerView startLoadingWithTitleStr:@&quot;测试视频&quot;]; self.playUrl = @&quot;http://182.138.101.48:5001/nn_vod/nn_x64/aWQ9NWZlOTljZWYwY2Q0Mzk3ZGRlNjI1MDExMTE0OGFlNjMmdXJsX2MxPTZkNmY2OTc2NjU3MzJmMzA2MjYzMzQzODMzNjUzMDY1MzIzMTYzNjYzMTMzMzAzMzYyMzUzNzM3MzkzMjY1NjE2MTM0Mzg2NjY2NjQzMzJlNzQ3MzIwMDAmbm5fYWs9MDFkZTU0YTczNjYxOWZiODdlMzU1NjgxZjEzZGNhYzc4ZCZudHRsPTMmbnBpcHM9MTgyLjEzOC4xMDEuNDg6NTEwMSZuY21zaWQ9MTAwMDAxJm5ncz01NTFlMDQxYTAwMGI5NWYxNWVjZjc1NTg2MDYyMTZiOCZubl91c2VyX2lkPVlZSEQwMDAwMDc3OSZuZHY9MS4wLjAuMC4yLlNDLUpHUy1JUEhPTkUuMC4wX1JlbGVhc2UmbmVhPSZuZXM9/5fe99cef0cd4397dde6250111148ae63.ts&quot;; if ([self.playUrl rangeOfString:@&quot;.ts&quot;].location != NSNotFound) &#123; self.playUrl = [self.playUrl stringByReplacingOccurrencesOfString:@&quot;.ts&quot; withString:@&quot;.m3u8&quot;];&#125;[tdPlayerView playVideoByUrl:self.playUrl]; 值得注意的是：iOS播放器是不支持ts后缀地址播放的，替换成m3u8后缀即可，实际m3u8是一个索引文件，播放时，会根据索引去下载对应的ts分片进行播放。 总结优缺点TDPlayer将播放层及UI层统一进行了封装，如果你的需求仅仅是播放一个视频，对UI要求不高，这套使用起来还是很方便的。 但是，缺点是什么呢？耦合度太高，播放层与UI层粘性高，不利用扩展或修改。 推荐这里提供一个无UI的纯播放适配器TDPlayerLite，这个将AVPlayer一些回调乱调、状态不友好的问题内部解决了，并封装了一套用户友好的代理出来，很好集成与使用。 此纯播放器SDK，具体集成与使用详见：iOS纯播放器（适配器）","categories":[{"name":"iOS","slug":"iOS","permalink":"https://tangyanqiong.com/categories/iOS/"},{"name":"OC","slug":"iOS/OC","permalink":"https://tangyanqiong.com/categories/iOS/OC/"}],"tags":[{"name":"Object-C","slug":"Object-C","permalink":"https://tangyanqiong.com/tags/Object-C/"},{"name":"播放器","slug":"播放器","permalink":"https://tangyanqiong.com/tags/播放器/"}]},{"title":"JavaScript算法初级练习","slug":"js算法","date":"2018-08-01T07:43:10.000Z","updated":"2019-07-26T09:44:05.000Z","comments":true,"path":"post/f4b98ba6.html","link":"","permalink":"https://tangyanqiong.com/post/f4b98ba6.html","excerpt":"# 需要定义一个最小值和一个最大值之间的随机数12345function ourFunction(ourMin, ourMax) &#123; return Math.floor(Math.random() * (ourMax - ourMin + 1)) + ourMin;&#125;ourFunction(1, 9);","text":"# 需要定义一个最小值和一个最大值之间的随机数12345function ourFunction(ourMin, ourMax) &#123; return Math.floor(Math.random() * (ourMax - ourMin + 1)) + ourMin;&#125;ourFunction(1, 9); # 计算一个整数的阶乘12345678910function factorialize(num) &#123; // 请把你的代码写在这里 if(num &lt;= 1) &#123; return 1; &#125; else &#123; return num *= factorialize(num - 1); &#125;&#125;factorialize(5); # 来一段回文 JavaScript算法练习： JavaScript中回文(Palindromes)处理 123456789101112131415161718192021222324252627//方法一function palindrome(str) &#123; // 请把你的代码写在这里 var re = /[\\W_]/g; var lowRegStr = str.toLowerCase().replace(re, ''); var reveRegStr = lowRegStr.split('').reverse().join(''); return lowRegStr == reveRegStr;&#125;palindrome(\"eye\");//方法二function palindrome(str) &#123; // 请把你的代码写在这里 var re = /[\\W_]/g; var lowRegStr = str.toLowerCase().replace(re, ''); for(var i=0, l=lowRegStr.length; i&lt;l/2; i++) &#123; if(lowRegStr[i] != lowRegStr[l - 1 -i]) &#123; return false; &#125; &#125; return true;&#125;palindrome(\"eye\"); # 在句子中找出最长的单词，并返回它的长度。 js 数组排序和算法排序 12345678910111213function findLongestWord(str) &#123; var strArr = str = str.split(' '); var newArr = []; for(var i=0;i&lt;strArr.length; i++) &#123; newArr.push(strArr[i].length); &#125; newArr.sort(function(a, b) &#123; return b - a; &#125;); return newArr[0];&#125;findLongestWord(\"What if we try a super-long word such as otorhinolaryngology\"); # 确保字符串的每个单词首字母都大写，其余部分小写。12345678910111213141516function titleCase(str) &#123; var strArr = str.split(' '); var newStrArr = []; var newStr = ''; for(var i=0; i&lt;strArr.length; i++) &#123; newStr = strArr[i][0].toUpperCase(); newStr += strArr[i].substr(1).toLowerCase(); newStrArr.push(newStr); &#125; newStrArr = newStrArr.join(' '); return newStrArr;&#125;titleCase(\"I'm a little tea pot\"); # 找出多个数组中的最大数12345678910111213function largestOfFour(arr) &#123; var newArr = []; var num = []; for(var i=0; i&lt;arr.length; i++) &#123; num = arr[i].sort(function(a, b) &#123; return b - a; &#125;); newArr.push(num[0]); &#125; return newArr;&#125;largestOfFour([[4, 5, 1, 3], [13, 27, 18, 26], [32, 35, 37, 39], [1000, 1001, 857, 1]]); # 判断一个字符串(str)是否以指定的字符串(target)结尾。123456789101112function confirmEnding(str, target) &#123; var len = target.length; if(str.substr(-len) == target) &#123; return true; &#125; else &#123; return false; &#125; &#125;confirmEnding(\"He has to give me a new name\", \"name\");confirmEnding(\"Bastian\", \"n\"); # 重复一个指定的字符串 num次，如果num是一个负数则返回一个空字符串。12345678910111213141516function repeat(str, num) &#123; // 请把你的代码写在这里 var newArr = []; var newStr = ''; if(num &lt; 0) &#123; newStr = ''; &#125; else &#123; for(var i=0; i&lt;num; i++) &#123; newArr.push(str); &#125; newStr = newArr.join(''); &#125; return newStr;&#125;repeat(\"abc\", 4); # 如果字符串的长度比指定的参数num长… 如果字符串的长度比指定的参数num长，则把多余的部分用…来表示。切记，插入到字符串尾部的三个点号也会计入字符串的长度。但是，如果指定的参数num小于或等于3，则添加的三个点号不会计入字符串的长度。 12345678910111213function truncate(str, num) &#123; var newStr=''; if(num &gt;= str.length) &#123; newStr = str.slice(0); &#125; else if(num &gt; 3) &#123; newStr = str.slice(0, num-3) + '...'; &#125; else &#123; newStr = str.slice(0, num) + '...'; &#125; return newStr;&#125;truncate(\"A-tisket a-tasket A green and yellow basket\", 11); # 把一个数组arr按照指定的数组大小size分割成若干个数组块。 js将一位数组分割成每三个一组 123456789function chunk(arr, size) &#123; var newArr = []; for(var i=0; i&lt;arr.length; i+=size) &#123; newArr.push(arr.slice(i, i+size)); &#125; return newArr;&#125;chunk([\"a\", \"b\", \"c\", \"d\"], 2); # 返回一个数组被截断n个元素后还剩余的元素，截断从索引0开始。123456function slasher(arr, howMany) &#123; arr.splice(0, howMany); return arr;&#125;slasher([1, 2, 3], 2); # 如果数组第一个字符串元素包含了第二个字符串元素的所有字符，函数返回true。123456789101112function mutation(arr) &#123; var str1 = arr[0].toLowerCase(); var str2 = arr[1].toLowerCase(); for(var i=0; i&lt;str2.length; i++) &#123; if(str1.indexOf(str2[i]) == -1) &#123; return false; &#125; &#125; return true;&#125;mutation([\"hello\", \"hey\"]); # 删除数组中的所有假值。1234567891011function bouncer(arr) &#123; var newArr = []; newArr = arr.filter(function(val) &#123; if(val !== (undefined &amp;&amp; null &amp;&amp; \"\" &amp;&amp; NaN &amp;&amp; false &amp;&amp; 0)) &#123; return val; &#125; &#125;); return newArr;&#125;bouncer([7, \"ate\", \"\", false, 9]); # 数组排序并找出元素索引，先给数组排序，然后找到指定的值在数组的位置，最后返回位置对应的索引。123456789function where(arr, num) &#123; arr.push(num); arr.sort(function(a, b) &#123; return a-b; &#125;); return arr.indexOf(num);&#125;where([40, 60], 50); # 实现一个摧毁(destroyer)函数，第一个参数是待摧毁的数组，其余的参数是待摧毁的值。 FCC–Seek and Destroy（摧毁数组） Seek and Destroy(算法) 12345678910111213function destroyer(arr) &#123; var newArr = []; var arg = arguments; for(var i=1; i&lt;arg.length; i++) &#123; newArr.push(arg[i]); &#125; arr = arr.filter(function(val) &#123; return newArr.indexOf(val) &lt; 0; &#125;); return arr;&#125;destroyer([1, 2, 3, 1, 2, 3], 2, 3); 发表于慕课网手记 题目来自： FreeCodeCamp BasicAlgorithmScripting参考资料： JavaScript标准库","categories":[{"name":"Web","slug":"Web","permalink":"https://tangyanqiong.com/categories/Web/"},{"name":"JS","slug":"Web/JS","permalink":"https://tangyanqiong.com/categories/Web/JS/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://tangyanqiong.com/tags/JavaScript/"},{"name":"算法","slug":"算法","permalink":"https://tangyanqiong.com/tags/算法/"}]},{"title":"《Vue.js实战》之前端路由与vue-router","slug":"vue-router","date":"2018-07-04T03:23:17.000Z","updated":"2019-07-26T09:44:45.000Z","comments":true,"path":"post/8734e386.html","link":"","permalink":"https://tangyanqiong.com/post/8734e386.html","excerpt":"前言什么是前端路由 每次 GET 或者 POST 请求在服务端有一个专门的正则配置列表，然后匹配到具体的一条路径后，分发到不同的 Controller，进行各种操作，最终将 html 或数据返回给前端，这就完成了一次 IO。 前端路由的实现\b有两种： URL的hash，即锚点（#），js 通过 hashChange 事件监听 url 的变化 HTML5 的 History 模式 优点： 页面持久性，如音乐网站 前后端彻底分离，如 Angular 的 ngRouter，\bReact 的 ReactRouter，还有 Vue 的 vue-router 需要考虑的问题： 页面的拔插性 页面的生命周期 内存管理等","text":"前言什么是前端路由 每次 GET 或者 POST 请求在服务端有一个专门的正则配置列表，然后匹配到具体的一条路径后，分发到不同的 Controller，进行各种操作，最终将 html 或数据返回给前端，这就完成了一次 IO。 前端路由的实现\b有两种： URL的hash，即锚点（#），js 通过 hashChange 事件监听 url 的变化 HTML5 的 History 模式 优点： 页面持久性，如音乐网站 前后端彻底分离，如 Angular 的 ngRouter，\bReact 的 ReactRouter，还有 Vue 的 vue-router 需要考虑的问题： 页面的拔插性 页面的生命周期 内存管理等 vue-router 基本用法1234567# 新建目录 router# 安装 vue-routernpm i -S vue-router# index.js添加import VueRouter from 'vue-router';Vue.use(VueRouter); 在目录 \brouter 新建 views 目录，接着新建 about.vue、 index.vue、 user.vue等 123456789101112131415161718192021222324252627282930// index.jsconst Routers = [ &#123; path: '/index', component: (resolve) =&gt; require(['../router/views/index.vue'], resolve) &#125;, &#123; path: '/about', component: (resolve) =&gt; require(['../router/views/about.vue'], resolve) &#125;, &#123; path: '*', redirect: '../index' // 404指向首页 &#125;];const RouterConfig = &#123; // 使用HTML5的history路由模式 mode: 'history', routes: Routers&#125;const router = new VueRouter(RouterConfig);document.body.appendChild(root);new Vue(&#123; router: router, render: h =&gt; h(App)&#125;).$mount(root); 路由模式通过HTML5的History路由模式，通过 ‘/’设置路径。修改package.json:123\"scripts\": &#123; \"dev\": \"webpack-dev-server --config webpack.config.js --mode=development --history-api-fallback\"&#125;, 增加了 --history-api-fallback，所有的路由都指向index.html。 然后在根实例App.vue中添加&lt;router-view&gt;&lt;/router-view&gt; 跳转vue-router 有两种跳转页面的方式： &lt;router-link&gt;组件，会渲染成\b &lt;a&gt; 标签，如：&lt;router-link to=&quot;/about&quot;&gt;跳转到 about&lt;/router-link&gt; tag : tag=&quot;li&quot; 标签会被渲染成指定的 &lt;li&gt; replace : 无历史记录 active-class 使用router实例： $router 方法，如：this.$router.push(&#39;/index&#39;); replace : this.$router.replace(&#39;/index&#39;); go : this.$router.go(-1);高级用法 问题：如何在SPA项目中，修改网页的标题？ 一般我们是通过window.document.title = &#39;标题&#39;来修改，但是在什么时候修改，这是个问题。 vue-router 提供了导航钩子 beforeEach() 和 afterEach()，它们会在路由即将改变前和改变后触发。 这样就解决了页面众多，维护麻烦的问题。（mounted钩子） 123456789101112131415router.beforeEach((to, from, next) =&gt; &#123; // 从路由对象 to 里获取 meta 信息 window.document.title = to.meta.title; // 判断页面是否登录 if(window.localStorage.getItem('token')) &#123; next(); &#125; else &#123; next('/login'); &#125;&#125;);router.afterEach((to, from, next) =&gt; &#123; // 页面跳转回来滚动条默认\b在顶端 window.scroll(0, 0);&#125;) 状态管理与 Vuex状态管理与使用场景组件的基本运行模式：一个组件分为数据和视图，数据更新时，视图也跟着更新…视图中又可以绑定一些事件，它们触发methods里指定的方法，从而可以改变数据、更新视图。 如果需要跨组件共享数据的需求，那就需要借助 Vuex 来管理组件状态。 Vuex 基本用法1npm i -S vuex","categories":[{"name":"Web","slug":"Web","permalink":"https://tangyanqiong.com/categories/Web/"},{"name":"Vue","slug":"Web/Vue","permalink":"https://tangyanqiong.com/categories/Web/Vue/"}],"tags":[{"name":"Vue-router","slug":"Vue-router","permalink":"https://tangyanqiong.com/tags/Vue-router/"}]},{"title":"SDWebImage实现原理","slug":"SDWebImage原理","date":"2018-06-25T03:02:32.000Z","updated":"2019-07-26T06:44:47.000Z","comments":true,"path":"post/7ae6af5d.html","link":"","permalink":"https://tangyanqiong.com/post/7ae6af5d.html","excerpt":"前言平时项目中经常使用到的框架中必有SDWebImage框架，这是一个很成熟图片缓存框架，而且使用非常的方便，只需一行代码就可以实现设置占位图以及在网络图片拉取成功后替换占位图的功能。虽然，乍一看只是现实了拉取网络图片的小小功能，但是，里面还包含了很多逻辑代码，也是很复杂的，你有没有深究它的实现原理呢？","text":"前言平时项目中经常使用到的框架中必有SDWebImage框架，这是一个很成熟图片缓存框架，而且使用非常的方便，只需一行代码就可以实现设置占位图以及在网络图片拉取成功后替换占位图的功能。虽然，乍一看只是现实了拉取网络图片的小小功能，但是，里面还包含了很多逻辑代码，也是很复杂的，你有没有深究它的实现原理呢？ 实现原理 在网络获取图片前，取消并移除当前对象的图片下载线程。 动态关联该图片url（用于图片存缓存的key），一般默认选项有占位图则先显示占位图（其中有个options选项可以不显示或者延时显示占位图等等，稍后再讲）。 使用关联的key作为路径，在内存中寻找该图片，找不到，再到本地中找，还是找不到，则通过url去服务器中下载。 在上一步中，如果在内存中找到了该图片，则直接返回；如果在本地找到了该图片，则先加载到内存中，再返回；如果需要到服务器拉取，则先把拉取到的图片加载到内存中，再存到本地，最后才返回。 设置对象的图片并显示。 具体逻辑如下图： 详解 取消当前对象的下载线程 1234567891011//通过key（一般都是url）获取下载线程- (void)sd_cancelImageLoadOperationWithKey:(NSString *)key &#123; // Cancel in progress downloader from queue NSMutableDictionary *operationDictionary = [self operationDictionary]; //获取下载队列字典 id operations = [operationDictionary objectForKey:key]; //取出当前key的所有队列 ··· [operation cancel]; //取消当前线程 ··· [operationDictionary removeObjectForKey:key]; //所有队列执行完cancel操作后，在所在数组移除 &#125;&#125; 设置关联的key 1objc_setAssociatedObject(self, &amp;imageURLKey, url, OBJC_ASSOCIATION_RETAIN_NONATOMIC); 设置占位图 12345if (!(options &amp; SDWebImageDelayPlaceholder)) &#123; dispatch_main_async_safe(^&#123; self.image = placeholder; &#125;);&#125; 下载图片（在缓存或者本地缓存获取也算在这里面，这里只列出了核心代码，完整代码在Github上下载SDWebImage库了解） 1234567891011121314151617181920212223242526272829//下载图片，返回一个实现SDWebImageOperation协议的对象。注：该协议只有一个cancel函数id &lt;SDWebImageOperation&gt; operation = [SDWebImageManager.sharedManager downloadImageWithURL:url options:options progress:progressBlock completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123; dispatch_main_sync_safe(^&#123; completedBlock(image, error, cacheType, url); &#125; &#125;);&#125;];//图片下载- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url options:(SDWebImageOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageCompletionWithFinishedBlock)completedBlock &#123; ... //获取图片 operation.cacheOperation = [self.imageCache queryDiskCacheForKey:key done:^(UIImage *image, SDImageCacheType cacheType) &#123;...&#125;]; return operation;&#125;//queryDiskCacheForkey函数里面首先会先去内存中寻找图片，没有再去本地找，最后才去服务器下载- (NSOperation *)queryDiskCacheForKey:(NSString *)key done:(SDWebImageQueryCompletedBlock)doneBlock &#123; //获取内存中的图片 UIImage *image = [self imageFromMemoryCacheForKey:key]; ... //获取本地储存的图片 UIImage *diskImage = [self diskImageForKey:key]; ... return operation;&#125; options作用1234567891011121314typedef NS_OPTIONS(NSUInteger, SDWebImageOptions) &#123; SDWebImageRetryFailed = 1 &lt;&lt; 0, SDWebImageLowPriority = 1 &lt;&lt; 1, SDWebImageCacheMemoryOnly = 1 &lt;&lt; 2, SDWebImageProgressiveDownload = 1 &lt;&lt; 3, SDWebImageRefreshCached = 1 &lt;&lt; 4, SDWebImageContinueInBackground = 1 &lt;&lt; 5, SDWebImageHandleCookies = 1 &lt;&lt; 6, SDWebImageAllowInvalidSSLCertificates = 1 &lt;&lt; 7, SDWebImageHighPriority = 1 &lt;&lt; 8, SDWebImageDelayPlaceholder = 1 &lt;&lt; 9, SDWebImageTransformAnimatedImage = 1 &lt;&lt; 10, SDWebImageAvoidAutoSetImage = 1 &lt;&lt; 11&#125;; 就说说SDWebImageRetryFailed有什么作用，先看一下注释： By default, when a URL fail to be downloaded, the URL is blacklisted so the library won’t keep trying.This flag disable this blacklisting. 默认options=0，也就是如果不传SDWebImageRetryFailed，图片下载失败了就会被加入黑名单，不会再重新下载，除非设置options=SDWebImageRetryFailed。 1234567891011if ( error.code != NSURLErrorNotConnectedToInternet &amp;&amp; error.code != NSURLErrorCancelled &amp;&amp; error.code != NSURLErrorTimedOut &amp;&amp; error.code != NSURLErrorInternationalRoamingOff &amp;&amp; error.code != NSURLErrorDataNotAllowed &amp;&amp; error.code != NSURLErrorCannotFindHost &amp;&amp; error.code != NSURLErrorCannotConnectToHost) &#123; @synchronized (self.failedURLs) &#123; [self.failedURLs addObject:url]; &#125;&#125; 其他 AutoPurgeCacheNSCache子类，初始化的时候注册通知，监听内存报警，会在接收到通知后清除内存，代码如下： 1[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(removeAllObjects) name:UIApplicationDidReceiveMemoryWarningNotification object:nil]; 设置image在获取图片后没有立即刷新，而是设置刷新标志，下一次runloop的时候刷新，代码如下： 12wself.image = image;[wself setNeedsLayout]; 总结其实SDWebImage的源码很好理解，核心逻辑代码条理清晰，只不过，作者在这基础上完善了很多功能逻辑，功能模块分离，降低耦合度，除了UIImageView控件，还有UIButton控件也能用来设置Image。源码不多，建议感兴趣的都可以去看一下，了解一下。最后，来说一下缓存和本地缓存的区别： 本地缓存顾名思义是存在本地的，具体是存在应用沙盒的cache文件里，而cache里面会在某些情况下被系统自动清除，比如，内存报警，所以一般放不太重要的，不需要备份的文件。s 缓存是一个大概念，本地缓存也算缓存，这里NSCahce指的应该是内存，看是否已经加在到内存里了，如果已经存在内存，就可以直接从内存中获取设置图片了。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://tangyanqiong.com/categories/iOS/"},{"name":"OC","slug":"iOS/OC","permalink":"https://tangyanqiong.com/categories/iOS/OC/"}],"tags":[{"name":"SDWebImage","slug":"SDWebImage","permalink":"https://tangyanqiong.com/tags/SDWebImage/"},{"name":"图片缓存","slug":"图片缓存","permalink":"https://tangyanqiong.com/tags/图片缓存/"}]},{"title":"Web设置Cookie","slug":"设置Cookie","date":"2018-05-03T03:32:13.000Z","updated":"2019-07-26T06:46:04.000Z","comments":true,"path":"post/e189a0d8.html","link":"","permalink":"https://tangyanqiong.com/post/e189a0d8.html","excerpt":"设置Cookie总结","text":"设置Cookie总结 代码记录 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 收藏功能 function addFavorite() &#123; var title = '意法半导体STM32/STM8技术社区 - 提供最新的ST资讯和技术交流'; var URL = 'http://www.stmcu.org.cn/'; // IE10 if(document.all) &#123; window.external.addFavorite(URL, title); &#125; else &#123; alert('手动 Ctrl+D 可以收藏我们的网站哦'); &#125; &#125; // 设置cookie，同一域名都可获取 function setCookie(name, value, exdays) &#123; var exdays = exdays || 1024; var d = new Date(); d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000)); document.cookie = name + \"=\" + escape(value) + \";path=/;expires=\" + d.toGMTString(); &#125; // 读取cookies，判断是否存在设置的name function getCookie(name) &#123; var name = name + \"=\"; var ca = document.cookie.split(';'); for (var i = 0; i &lt; ca.length; i++) &#123; var c = ca[i].trim(); if (c.indexOf(name) == 0) &#123; return c.substring(name.length, c.length); &#125; &#125; return \"\"; &#125; function checkCookie() &#123; var user = getCookie(\"msgCookie\"); var width = window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth; if(width &gt;= 1080) &#123; if (user != \"\") &#123; msgHide(); &#125; else &#123; msgShow(); &#125; &#125; &#125; // 关闭时设置cookie function closeModal() &#123; msgHide(); setCookie(\"msgCookie\", 'msgCookie'); &#125; function msgHide() &#123; document.getElementById('newsTipsModal').style.display = 'none'; &#125; function msgShow() &#123; document.getElementById('newsTipsModal').style.display = 'block'; &#125; // init checkCookie();","categories":[{"name":"Web","slug":"Web","permalink":"https://tangyanqiong.com/categories/Web/"},{"name":"JS","slug":"Web/JS","permalink":"https://tangyanqiong.com/categories/Web/JS/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://tangyanqiong.com/tags/JavaScript/"},{"name":"Cookie","slug":"Cookie","permalink":"https://tangyanqiong.com/tags/Cookie/"},{"name":"Web","slug":"Web","permalink":"https://tangyanqiong.com/tags/Web/"}]},{"title":"《Vue.js实战》之使用webpack","slug":"vue-webpack","date":"2018-03-04T03:22:59.000Z","updated":"2019-07-26T09:46:02.000Z","comments":true,"path":"post/e8ff02eb.html","link":"","permalink":"https://tangyanqiong.com/post/e8ff02eb.html","excerpt":"前端工程化与webpack前端工程化主要解决的问题： JavaScript、css 代码的合并与压缩 CSS 预处理：Less、Sass、Stylus 的编译 生成雪碧图 ES6 -&gt; ES5 模块化等 webpack 的主要使用场景是单页面富应用（SPA），将一些诸如：typescript、less、jpg、vue等格式的文件通过特定的加载器（Loader）编译后，最终统一生成 .js、.css、.png等静态资源文件。 如何文件都可称为是一个模块。webpack就是处理模块间的依赖关系，并把他们进行打包。","text":"前端工程化与webpack前端工程化主要解决的问题： JavaScript、css 代码的合并与压缩 CSS 预处理：Less、Sass、Stylus 的编译 生成雪碧图 ES6 -&gt; ES5 模块化等 webpack 的主要使用场景是单页面富应用（SPA），将一些诸如：typescript、less、jpg、vue等格式的文件通过特定的加载器（Loader）编译后，最终统一生成 .js、.css、.png等静态资源文件。 如何文件都可称为是一个模块。webpack就是处理模块间的依赖关系，并把他们进行打包。 webpack 基础配置安装 webpack 与 webpack-dev-server初始化12npm init # 按照提示一步步往下走 本地局部安装 webpack:（书中是v2，我的\b需要下载脚手架 -cli）1234567npm install webpack --save-devnpm i -D webpack-cli# 会多出下面一项“\"devDependencies\": &#123; \"webpack\": \"^4.28.4\"&#125; 安装 webpack-dev-server，可以启动一个服务器、热更新、接口代理等1npm install webpack-dev-server --save-dev 最终的 package.json 文件内容如下：1234567891011121314151617181920212223242526272829&#123; \"name\": \"vue-webpack-iview\", \"version\": \"1.0.0\", \"description\": \"学习《Vue.js实战》之进阶篇\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"repository\": &#123; \"type\": \"git\", \"url\": \"git+https://github.com/yangtao2o/vue-webpack-iview.git\" &#125;, \"keywords\": [ \"vue\", \"webpack\", \"iview\" ], \"author\": \"yangtao\", \"license\": \"ISC\", \"bugs\": &#123; \"url\": \"https://github.com/yangtao2o/vue-webpack-iview/issues\" &#125;, \"homepage\": \"https://github.com/yangtao2o/vue-webpack-iview#readme\", \"devDependencies\": &#123; \"webpack\": \"^4.28.4\", \"webpack-cli\": \"^3.2.1\", \"webpack-dev-server\": \"^3.1.14\" &#125;&#125; 就是一个 js 文件而已创建 webpack.config.js，并初始化： 12345var config = &#123;&#125;module.exports = config; 接着，在 package.json 里配置启动项： 123456789\"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"dev\": \"webpack-dev-server --open --config webpack.config.js --mode=development\"&#125;// --open：会在启动服务时自动\b打开浏览器// --config：指向 webpack-dev-server 读取的配置文件路径// --host --port：可配置 IP 和端口，如：--host 172.172.172.1 --port 8888// --mode=development：需要说明是什么环境，不然会显示警告 webpack 的入口\b（Entry）和出口（Output），重中之重，新建 main.js，并在 webpack.config.js 中进行\b\b入口和输出的配置：123456789101112var config = &#123; entry: &#123; main: &apos;./main&apos; // 入口文件为 main.js &#125;, output: &#123; path: path.join(__dirname, &apos;./dist&apos;), // 输出目录 publicPath: &apos;./dist&apos;, //指定资源文件引用的目录 filename: &apos;main.js&apos; // 指定输出文件的名称 &#125;&#125;module.exports = config; 然后：npm run dev，浏览器会自动打开页面了。 逐步完善配置文件webpack 对于不同的\b模块需要不同的加载器来处理，通过安装不同的加载器，就可以对各种后缀名的文件进行处理。 如处理 .css 文件：123456789101112131415161718# cssnpm install css-loader --save-devnpm install style-loader --save-dev# rules 属性中可以指定一系列的 loaders# 每一个 loader 都必须包含 test 和 use # \b处理名为 .css 的文件时，先通过 css-loader 转换，再通过 style-loader 转换，然后继续打包module: &#123; rules: [ &#123; test: '/\\.css$/', use: [ 'style-loader', 'css-loader' ] &#125; ]&#125; 在实际的业务中，需要使用插件 extract-text-webpack-plugin 把各处的css文件提取出来。，并生成一个 main.css 文件，最终在 index.html 里加载它。 1npm install extract-text-webpack-plugin@next --save-dev config12345678910111213141516var ExtractTextPlugin = require('extract-text-webpack-plugin');module: &#123; rules: [ &#123; test: '/\\.css$/', use: ExtractTextPlugin.extract(&#123; use: 'css-loader', fallback: 'style-loader' &#125;) &#125; ]&#125;,plugins: [ new ExtractTextPlugin('main.css'),] 单文件组件与 vue-loader安装加载器：123456npm install --save-dev vue vue-loader vue-style-loadernpm install --save-dev vue-template-compilernpm install --save-dev vue-hot-reload-apinpm i -D babel babel-loadernpm i -D @babel/corenpm i -D @babel/preset-env 配置：Babel-loader、Vue-loader 结合自己配置的过程中关于版本冲突的解决办法参考：webpack4配置vue环境和一些小坑 主要修改： index.js(之前的 main.js，目录也放在了/src/下) 1234567import Vue from 'vue';import App from './App.vue';const root = document.createElement('div');document.body.appendChild(root);new Vue(&#123; render: h =&gt; h(App)&#125;).$mount(root); App.vue 12345678910111213141516171819&lt;template&gt; &lt;div&gt; Hello &#123;&#123; name &#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; name: 'Vue.js' &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; package.js 12345678910111213141516171819202122\"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"dev\": \"webpack-dev-server --config webpack.config.js --mode=development\", \"build\": \"webpack --progress --hide-modules --mode=production\"&#125;,\"devDependencies\": &#123; \"@babel/core\": \"^7.2.2\", \"@babel/preset-env\": \"^7.2.3\", \"babel\": \"^6.23.0\", \"babel-loader\": \"^8.0.5\", \"css-loader\": \"^2.1.0\", \"extract-text-webpack-plugin\": \"^4.0.0-beta.0\", \"style-loader\": \"^0.23.1\", \"vue\": \"^2.5.22\", \"vue-hot-reload-api\": \"^2.3.1\", \"vue-loader\": \"^15.5.1\", \"vue-style-loader\": \"^4.1.2\", \"vue-template-compiler\": \"^2.5.22\", \"webpack\": \"^4.28.4\", \"webpack-cli\": \"^3.2.1\", \"webpack-dev-server\": \"^3.1.14\"&#125;, webpack.config.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344const path = require('path');const VueLoaderPlugin = require('vue-loader/lib/plugin');const ExtractTextPlugin = require('extract-text-webpack-plugin');module.exports = &#123; entry: path.join(__dirname, './src/index.js'), output: &#123; path: path.join(__dirname, './dist'), // 输出目录 publicPath: '/dist', //指定资源文件引用的目录 filename: 'main.js' // 指定输出文件的名称 &#125;, module: &#123; rules: [ &#123; test: /\\.vue$/, loader: 'vue-loader', options: &#123; loaders: &#123; css: ExtractTextPlugin.extract(&#123; use: 'css-loader', fallback: 'vue-style-loader' &#125;) &#125; &#125; &#125;, &#123; test: /\\.js$/, loader: 'babel-loader', exclude: /node_modules/ &#125;, &#123; test: /\\.css$/, use: ExtractTextPlugin.extract(&#123; use: 'css-loader', fallback: 'style-loader' &#125;) &#125; ] &#125;, plugins: [ new VueLoaderPlugin(), new ExtractTextPlugin('main.css'), ]&#125; .babelrc 1234&#123; \"presets\": [\"@babel/preset-env\"], \"plugins\": [\"@babel/plugin-transform-runtime\"]&#125; index.html 123456...&lt;link rel=\"stylesheet\" href=\"./dist/main.css\"&gt;...&lt;body&gt; &lt;script src=\"./dist/main.js\"&gt;&lt;/script&gt;&lt;/body&gt; 用于生产环境 练习地址","categories":[{"name":"Web","slug":"Web","permalink":"https://tangyanqiong.com/categories/Web/"},{"name":"Vue","slug":"Web/Vue","permalink":"https://tangyanqiong.com/categories/Web/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://tangyanqiong.com/tags/Vue/"},{"name":"Webpack","slug":"Webpack","permalink":"https://tangyanqiong.com/tags/Webpack/"}]},{"title":"怎么使用Hexo编写博客","slug":"hexo-use","date":"2018-01-18T07:39:43.000Z","updated":"2019-07-26T08:31:18.000Z","comments":true,"path":"post/4f821c45.html","link":"","permalink":"https://tangyanqiong.com/post/4f821c45.html","excerpt":"前言由于网上太多关于github+hexo搭建教程，搭建这里就不多说了，推荐之前搭建参考的网址： 使用hexo+github搭建免费个人博客详细教程 GitPages+Hexo搭建个人博客 搭建完成后，怎么使用hexo这个框架，网页的排版这些就很难找到相关资料了，自己研究了下，具体整理出来，方便后面的人使用。","text":"前言由于网上太多关于github+hexo搭建教程，搭建这里就不多说了，推荐之前搭建参考的网址： 使用hexo+github搭建免费个人博客详细教程 GitPages+Hexo搭建个人博客 搭建完成后，怎么使用hexo这个框架，网页的排版这些就很难找到相关资料了，自己研究了下，具体整理出来，方便后面的人使用。 目录 博客功能配置 根目录_config.yml配置 Hexo常用命令 博客功能配置主题配置官方提供很多主题，这里放两个主题，其他可以自行度娘，博主更偏爱material-x主题，哈哈。到指定目录下clone。 1234$ cd /Users/TangDan/GitHub/MyHexoBlog/themes$ hexo clean$ git clone https://github.com/iissnan/hexo-theme-next$ git clone https://github.com/xaoxuu/hexo-theme-material-x themes/material-x //本博客使用主题 现在themes目录下应该多了两个目录：next、material-x，然后到_config.yml修改theme: material-x，再执行 1234$ cd /Users/TangDan/GitHub/MyHexoBlog$ hexo g$ hexo d //推送到远端$ hexo server //本地查看 PS:运行中出现任何问题，可以先hexo clean再执行。 两个主题配置这两个主题配置其实说难不难，说简单不简单，目前我是只去研究了material-x主题的配置，过程即酸爽又享受。 Next主题官方配置文档Material-X主题官方配置文档PS：请一定要仔细的去读官方文档，不要看了这个文档一半又跑去查其他的资料，其他的资料可能更新没官方那么快，是老版本的，到最后一顿操作猛如虎，结果等于白忙，不要问我怎么知道的，我不会告诉你，= =！ 链接持久化hexo默认的链接是http://xxx.com/2017/08/18/hello-world 这种类型的，这种路径看着也挺low的，这源于站点配置文件_config.yml里的配置: permalink: :year/:month/:day/:title/. 这种默认配置的缺点就是当我们创建的博文名包含中文的名的时候，url 链接地址经常会变成一串很长的难以理解的字符串，不利于博文的链接分享，以及搜索引擎搜索，另外就是年月日都会有分隔符。我们可以让 url 链接持久化来解决这个问。 安装hexo-abbrlink插件 $ sudo npm install hexo-abbrlink 修改站点配置文件 _config.yml permalink: post/:abbrlink.html 添加 abbrlink: 123456permalink: post/:abbrlink.html # :year/:month/:day/:title/ # 文章的永久链接格式permalink_defaults: # 永久链接中个部分的默认值# abbrlink config 需安装插件hexo-abbrlinkabbrlink: alg: crc32 # 算法： crc16(default) and crc32 rep: hex # 进制： dec(default) and hex 站内搜索安装 hexo-generator-search 插件 $ sudo npm install hexo-generator-search 配置站点文件_config.yml: 1234567# 站内搜索search: path: search.xml field: postlocal_search: enable: true 根目录_config.yml配置站点配置（重要）123456title: 博客名 //网站标题subtitle: To strive, to seek, to find //网站副标题description: To strive, to seek, to find, and not to yield. //网站描述author: WenBo //您的名字language: zh-Hans //网站使用的语言 简体中文 zh-Hanstimezone: //网站时区。Hexo 默认使用您电脑的时区 URL配置1234url: http://blogwenbo.com/ //网址root: / //网站根目录permalink: :year/:month/:day/:title/ // 文章的 [永久链接](https://hexo.io/zh-cn/docs/permalinks.html) 格式 | `:year/:month/:day/:title/` |permalink_defaults: //永久链接中各部分的默认值 目录配置12345678source_dir: source //资源文件夹，这个文件夹用来存放内容。默认值：sourcepublic_dir: public //公共文件夹，这个文件夹用于存放生成的站点文件。默认值：publictag_dir: tags //标签文件夹 默认值：tagsarchive_dir: archives //归档文件夹 默认值：archivescategory_dir: categories //分类文件夹 默认值：categoriescode_dir: downloads/code //Include code 文件夹 默认值：downloads/codei18n_dir: :lang //国际化（i18n）文件夹 默认值：:langskip_render: README.md //跳过指定文件的渲染，您可使用 [glob 表达式](https://github.com/isaacs/node-glob)来匹配路径。 Git部署配置（重要）1234deploy: type: git //填git repo: git@github.com:wenmobo/wenmobo.github.io.git //SSH地址 branch: master //分支 Hexo常用命令其实搭建成功后，在/Users/TangDan/GitHub/MyHexoBlog/source/_posts里默认会有生成一个hello-world.md，这个里面描述了常用的哪些命令及意义，可在里面查看。 常用创建命令： 12$ hexo new &quot;xxx&quot; //创建一篇文章$ hexo new page &quot;xxx&quot; //创建一个分类 总体来说，提交一个修改到github，最好顺序执行以下命令： 1234$ hexo clean$ hexo g// $ hexo s //这个是提交到本地$ hexo d //推送到github","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://tangyanqiong.com/categories/Hexo/"}],"tags":[{"name":"Hexo命令","slug":"Hexo命令","permalink":"https://tangyanqiong.com/tags/Hexo命令/"},{"name":"Material-X","slug":"Material-X","permalink":"https://tangyanqiong.com/tags/Material-X/"}]}]}