{"meta":{"title":"Root's Blog","subtitle":null,"description":null,"author":"Root","url":"https://tangyanqiong.com","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-05-24T08:41:03.975Z","updated":"2019-05-24T08:41:03.963Z","comments":true,"path":"404.html","permalink":"https://tangyanqiong.com/404.html","excerpt":"","text":"404 Not Found 很抱歉，您访问的页面不存在您可以留言告诉我哪个页面找不到，谢谢您的提议！"},{"title":"所有分类","date":"2017-12-24T03:43:30.000Z","updated":"2019-05-24T06:33:20.549Z","comments":true,"path":"categories/index.html","permalink":"https://tangyanqiong.com/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2017-12-24T03:43:12.000Z","updated":"2019-05-24T06:33:36.617Z","comments":true,"path":"tags/index.html","permalink":"https://tangyanqiong.com/tags/index.html","excerpt":"","text":""},{"title":"关于我","date":"2018-03-18T06:22:35.000Z","updated":"2019-05-24T07:05:31.397Z","comments":true,"path":"about/index.html","permalink":"https://tangyanqiong.com/about/index.html","excerpt":"","text":"自我介绍我大学其实学的是通信工程，大学时期，一次机缘巧合看到土豪朋友在玩iPhone 3GS，天啦，在那个还是手机键盘咔咔敲的年代，突然一个全触屏的科技性手机迅速吸引了我的眼球。大学毕业后看到有公司招iPhone开发实习生，被iPhone影响深刻的我，毫不犹豫的加入了，成为了一名iOS开发攻城师，目前也在搞Web开发和学习小程序开发。我平时其实是一个比较闷的人，喜欢看美剧、旅游、玩游戏，爱好美食。 共勉所谓技多不压身，在互联网这个更新迭代非常迅速的时代，只有不断的提升自己来与时俱进，避免被淘汰，且职场上女性更容易被歧视，其实很不想讲出这样的话，但目前的大环境来说，特别是IT行业，程序员的保鲜程度就在20-35岁，特别对女程序员相关条件更是苛刻。 So，无论你是程序猿还是程序媛，希望我们都能在互联网这个行业继续艰苦的摸爬滚打，无论你是被生活压弯了腰还是兴趣所向在这条路上，希望你一切都好，继续努力，为了你爱的人和爱你的人！ 共勉之有话要说小伙伴你们是怎么进入到互联网的行业呢，是各种机缘巧合还是兴趣所向呢，动动你发财的小手，在评论区告诉我吧，哈哈。"},{"title":"归档","date":"2017-12-20T03:44:04.000Z","updated":"2019-05-24T06:14:56.548Z","comments":true,"path":"archives/index.html","permalink":"https://tangyanqiong.com/archives/index.html","excerpt":"","text":""}],"posts":[{"title":"Swift上View手势控制","slug":"Swift中View手势控制","date":"2019-06-03T07:31:20.000Z","updated":"2019-06-06T02:00:27.137Z","comments":true,"path":"post/a17aa0f4.html","link":"","permalink":"https://tangyanqiong.com/post/a17aa0f4.html","excerpt":"前言对View进行放大缩小、移动、旋转，其实是很常见的需求，最开始在OC上，很早的几年，还是用的touch事件来实现，这种实现方式很繁琐，呈现的效果也不是很好。 后来，苹果也逐步的淘汰了这种方式，出了手势这种模式，极大程度上的缩减了代码量，而且操作简单，上手迅速，OC上手势的使用方式网上比比皆是，这里就不细说，着重介绍Swift View手势控制方法。","text":"前言对View进行放大缩小、移动、旋转，其实是很常见的需求，最开始在OC上，很早的几年，还是用的touch事件来实现，这种实现方式很繁琐，呈现的效果也不是很好。 后来，苹果也逐步的淘汰了这种方式，出了手势这种模式，极大程度上的缩减了代码量，而且操作简单，上手迅速，OC上手势的使用方式网上比比皆是，这里就不细说，着重介绍Swift View手势控制方法。 实现添加旋转、缩放、移动手势，如下： 1234567891011//Rotationlet rotationGestureRecognizer = UIRotationGestureRecognizer(target: self, action: #selector(EditPhotoViewController.rotateView(_:)))photoImageView?.addGestureRecognizer(rotationGestureRecognizer)//Scale pinchlet pinchGestureRecognizer = UIPinchGestureRecognizer(target: self, action: #selector(EditPhotoViewController.pinchView(_:)))photoImageView?.addGestureRecognizer(pinchGestureRecognizer)//Movelet panGestureRecognizer = UIPanGestureRecognizer(target: self, action: #selector(EditPhotoViewController.panView(_:)))photoImageView?.addGestureRecognizer(panGestureRecognizer) 以下代码使用变量如下： private var cropFrame = CGRect.zero //图片上限制框的frame private var latestFrame = CGRect.zero //最大缩放frame private var rotationAngle: CGFloat = 0.0 //旋转的角度 给变量设置初始值： 12345678910111213141516171819202122private func resetShowImageViewFrame() &#123; rotationAngle = 0.0 photoImageView?.image = originalImage photoImageView?.transform = .identity // scale to fit the screen cropFrame = photoOverLayView?.transparentArea ?? CGRect.zero var oriWidth: CGFloat = cropFrame.size.width var oriHeight: CGFloat = (originalImage?.size.height ?? 0.0) * (oriWidth / (originalImage?.size.width ?? 0.0)) if ((originalImage?.size.width)!/(originalImage?.size.height)!) &gt; (CGFloat)(standardPostImgWidth)/(CGFloat)(standardPostImgHeight) &#123; oriHeight = cropFrame.size.height oriWidth = (originalImage?.size.width ?? 0.0) * (oriHeight / (originalImage?.size.height ?? 0.0)) &#125; let oriX: CGFloat = cropFrame.origin.x + (cropFrame.size.width - oriWidth) / 2 let oriY: CGFloat = cropFrame.origin.y + (cropFrame.size.height - oriHeight) / 2 oldFrame = CGRect(x: oriX, y: oriY, width: oriWidth, height: oriHeight) latestFrame = oldFrame photoImageView?.frame = oldFrame largeFrame = CGRect(x: 0, y: 0, width: limitRatio * oldFrame.size.width, height: limitRatio * oldFrame.size.height)&#125; 旋转实现12345678910@objc func rotateView(_ rotationGestureRecognizer: UIRotationGestureRecognizer?) &#123; let view: UIView? = photoImageView if rotationGestureRecognizer?.state == .began || rotationGestureRecognizer?.state == .changed &#123; view?.transform = (view?.transform.rotated(by: (rotationGestureRecognizer?.rotation)!))! rotationAngle = rotationAngle + (rotationGestureRecognizer?.rotation ?? 0.0) rotationGestureRecognizer?.rotation = 0 &#125; else if rotationGestureRecognizer?.state == .ended &#123; latestFrame = photoImageView?.frame ?? CGRect.zero &#125;&#125; 缩放实现1234567891011121314151617181920212223242526272829@objc func pinchView(_ pinchGestureRecognizer: UIPinchGestureRecognizer?) &#123; let view: UIView? = photoImageView if pinchGestureRecognizer?.state == .began || pinchGestureRecognizer?.state == .changed &#123; if rotationAngle == 0 &#123; //narrow if (pinchGestureRecognizer?.scale)! &lt;= CGFloat(1.0) &amp;&amp; ((photoImageView?.width)! &lt;= cropFrame.size.width || (photoImageView?.height)! &lt;= cropFrame.size.height) &#123; return &#125; &#125; //amplification if (pinchGestureRecognizer?.scale)! &gt; CGFloat(1.0) &amp;&amp; ((photoImageView?.width)! &gt; 5000 || (photoImageView?.height)! &gt; 5000) &#123; return &#125; view?.transform = (view?.transform.scaledBy(x: (pinchGestureRecognizer?.scale)!, y: (pinchGestureRecognizer?.scale)!))! pinchGestureRecognizer?.scale = 1 &#125; else if pinchGestureRecognizer?.state == .ended &#123; if rotationAngle == 0 &#123; var newFrame: CGRect? = photoImageView?.frame //newFrame = handleScaleOverflow(newFrame ?? CGRect.zero) newFrame = handleBorderOverflow(newFrame ?? CGRect.zero) UIView.animate(withDuration: TimeInterval(BOUNDCE_DURATION), animations: &#123; self.photoImageView?.frame = newFrame ?? CGRect.zero self.latestFrame = newFrame ?? CGRect.zero &#125;) &#125; else &#123; latestFrame = photoImageView?.frame ?? CGRect.zero &#125; &#125;&#125; 平移实现123456789101112131415161718192021@objc func panView(_ panGestureRecognizer: UIPanGestureRecognizer?)&#123; let view = panGestureRecognizer?.view; if (panGestureRecognizer?.state == .began || panGestureRecognizer?.state == .changed) &#123; let translation = panGestureRecognizer?.translation(in: view?.superview) view?.center = CGPoint(x: (view?.center.x)! + (translation?.x)!, y: (view?.center.y)! + (translation?.y)!) panGestureRecognizer?.setTranslation(CGPoint.zero, in: view?.superview) &#125; else if panGestureRecognizer?.state == .ended &#123; if rotationAngle == 0 &#123; //bounce to original frame var newFrame: CGRect? = photoImageView?.frame newFrame = handleBorderOverflow(newFrame ?? CGRect.zero) UIView.animate(withDuration: TimeInterval(BOUNDCE_DURATION), animations: &#123; self.photoImageView?.frame = newFrame ?? CGRect.zero self.latestFrame = newFrame ?? CGRect.zero &#125;) &#125; else &#123; latestFrame = photoImageView?.frame ?? CGRect.zero &#125; &#125;&#125; 最终效果","categories":[{"name":"iOS","slug":"iOS","permalink":"https://tangyanqiong.com/categories/iOS/"},{"name":"Swift","slug":"iOS/Swift","permalink":"https://tangyanqiong.com/categories/iOS/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://tangyanqiong.com/tags/Swift/"},{"name":"手势控制","slug":"手势控制","permalink":"https://tangyanqiong.com/tags/手势控制/"}]},{"title":"iPad控制多屏电视","slug":"ipad控制多屏","date":"2019-05-30T07:46:42.000Z","updated":"2019-05-31T06:24:59.678Z","comments":true,"path":"post/a503d77d.html","link":"","permalink":"https://tangyanqiong.com/post/a503d77d.html","excerpt":"前言背景我们公司有4个电视（内置机顶盒），用来展示公司的业务，平时经常会有客户来参观，电视下面是通过HDMI线连接的电脑，展示的实际是网页。 需求昨天下午领导提一个需求，因为演示的时候，需要操作，就得用电脑的鼠标在电视上点，屏幕太大鼠标又在电视下方，很不方便，不好操作，然后想借鉴别人公司，直接用iPad里控制4个电视来操作。","text":"前言背景我们公司有4个电视（内置机顶盒），用来展示公司的业务，平时经常会有客户来参观，电视下面是通过HDMI线连接的电脑，展示的实际是网页。 需求昨天下午领导提一个需求，因为演示的时候，需要操作，就得用电脑的鼠标在电视上点，屏幕太大鼠标又在电视下方，很不方便，不好操作，然后想借鉴别人公司，直接用iPad里控制4个电视来操作。 实现讨论用iPad来控制电视屏幕，是不是一听就很高大？ 哈哈，怎么控制？都不是一个系统，一个是windows系统，一个是iOS系统。讨论时，我提出了两个方案： 做个APP，把网页内嵌到里面，直接用自带的AirPlay把iPad投屏到电视，不用的电视，再切换投屏，这样在iPad上操作就会同步到电视。 因为展示的业务是web页，那么就用APP，在同一局域网给Web端发指令，或通过后台中转指令，以控制在电视上展示的网页。 调研1. 投屏方案这个方案，实际是时间成本最少的，说干就干，然后马上我这边就起了一个项目，嵌了一个网页在APP里，好吧，正式开始投屏，然后… 结果： 投屏是成功了的，但是呢，因为电视的屏幕比是16:9，而iPad是4:3，导致了在电视上，iPad的投屏屏幕显示不全，两边还有间隙，不是全屏，而且当初web端开发的网页尺寸也是固定的1920x1080，也就是为电视量身定做的，这个网页在iPad上也不能全屏显示。 这种硬件上及网页端的限制，不好改变，就放弃了这种方式。 2. 指令控制方案这个方案，需要和web端约定很多指令，基本指令像点击不同按钮的不同指令，而且比如上下滑动网页的距离，由于屏幕分辨率不一样，需要经过一定转换，才能是web端的对应距离等等问题。 结果： 诚如上面所说，这个开发成本会很大，而且有局限性，一旦网页内容改变，APP端需改动代码升级才能使用，这种做法不符合产品经理的预期，所以直接淘汰了。 另辟蹊径上面的两个方案告吹后，给产品经理说了结果，然后产品经理在网上找到了另一种方案，就是市面上这种类似TeamViewer的远程操控桌面软件，直接在iPad上安装软件，然后在PC上安装同样软件，使用iPad操控PC桌面。 两种方案有了这个方案，就在网上找到了向日葵、Splashtop，这两个软件支持多端连接。 1. 向日葵安装和使用都比较简单，APP风格符合中国人的操作习惯，每次连接PC端都需要输入验证码（PC端的向日葵软件上），这样的话，每次切换连接不同电脑比较慢，操作体验不好。 2. Splashtop同样的，安装和使用都比较简单，是国外软件，风格偏欧美风，我其实比较喜欢这种操作方式，简单易懂，连接同一个电脑，连续输入两次验证码，下次再点击接该电脑就直接连接了。 对比这两个软件，Splashtop切换不同电脑连接要更快些，而且不用每次都输验证码，相对方便些，所以就给产品经理推荐了这个软件来操作。 最终实施哈哈，以为这就OK了吗，NO，今天来公司，产品经理说昨晚给CEO看了，CEO觉得这样切换还是太慢，给了个建议，让4个电视通过HDMI方式连到一个电脑上，这样的话就用iPad操控一台电脑就可以了，不存在切换慢的问题了，仔细想了下，这种方案还真不错，有可行性，然后开撸，将4台电视连接到了一台电脑上（专门有HDMI拓展外接，所以接口足够），然后分屏显示。 1. Splashtop连接其实我真的是蛮喜欢Splashtop的，操作简单，可惜的是Splashtop只支持双屏显示，切换分屏始终只显示第1第2分屏。 2. 向日葵连接换了向日葵来连接，满怀期望的希望它支持多屏，结果不负众望，4台分屏完美切换，速度流畅，好，就用它了。 总结总的来说，这次需求完成还是比较满意的，上面领导也满意这个结果，这次分享希望能给需要iPad控制多屏电视的人带来帮助，有什么问题请在评论区告诉我吧。","categories":[{"name":"基本操作","slug":"基本操作","permalink":"https://tangyanqiong.com/categories/基本操作/"}],"tags":[{"name":"iPad控制多屏","slug":"iPad控制多屏","permalink":"https://tangyanqiong.com/tags/iPad控制多屏/"},{"name":"远程桌面控制","slug":"远程桌面控制","permalink":"https://tangyanqiong.com/tags/远程桌面控制/"},{"name":"向日葵","slug":"向日葵","permalink":"https://tangyanqiong.com/tags/向日葵/"},{"name":"Splashtop","slug":"Splashtop","permalink":"https://tangyanqiong.com/tags/Splashtop/"}]},{"title":"Vue框架底层原理","slug":"vue-use","date":"2019-03-20T09:58:17.000Z","updated":"2019-06-06T02:00:47.815Z","comments":true,"path":"post/d32be447.html","link":"","permalink":"https://tangyanqiong.com/post/d32be447.html","excerpt":"前言Vue框架是什么，怎么用，相信大家都已经很熟悉了，诚如Vue教程所说，它是一套构建用户界面的渐进式Web前端框架。 但是很多人就是拿来主义，就只管用，博主也是这类人 = =!, 但是随着深入使用Vue，越发觉得深知其原理的重要性，那么，本文来探讨一下Vue的底层原理到底是什么，是怎么实现的。","text":"前言Vue框架是什么，怎么用，相信大家都已经很熟悉了，诚如Vue教程所说，它是一套构建用户界面的渐进式Web前端框架。 但是很多人就是拿来主义，就只管用，博主也是这类人 = =!, 但是随着深入使用Vue，越发觉得深知其原理的重要性，那么，本文来探讨一下Vue的底层原理到底是什么，是怎么实现的。 目录概括Vue的底层原理总体来说就是深入响应式原理，它最独特的特性之一就是非侵入性的响应式系统。数据模型仅仅是普通的 JavaScript 对象。而当你修改它们时，视图会进行更新，这使得状态管理非常简单直接。 详解双向绑定下面是一段代码，较直观的体现了Vue特点，如下： 1234567891011121314151617181920212223&lt;div id=&quot;mvvm-app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;word&quot;&gt; &lt;p&gt;&#123;&#123;word&#125;&#125;&lt;/p&gt; &lt;button v-on:click=&quot;sayHi&quot;&gt;change model&lt;/button&gt; //点击这个button，word的值会发生改变&lt;/div&gt;&lt;script src=&quot;./js/observer.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./js/watcher.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./js/compile.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./js/mvvm.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var vm = new MVVM(&#123; el: &apos;#mvvm-app&apos;, data: &#123; word: &apos;Hello World!&apos; &#125;, methods: &#123; sayHi: function() &#123; this.word = &apos;Hi, everybody!&apos;; &#125; &#125; &#125;);&lt;/script&gt; 实现效果如下： 而Vue实现数据双向绑定的效果，需要三大模块： Observer：对数据对象的所有属性进行监听，如有变动可拿到最新值并通知观察者 Compile：对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数 Watcher：作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图 ObserverObserver的核心是通过Obeject.defineProperty()来监听数据的变动，这个函数内部可以定义setter和getter，每当数据发生变化，就会触发setter。这时候Observer就要通知订阅者，订阅者就是Watcher。 WatcherWatcher订阅者作为Observer和Compile之间通信的桥梁，主要做的事情是： 在自身实例化时往属性订阅器(dep)里面添加自己 自身必须有一个update()方法 待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调 CompileCompile主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图。 总结MVVM 是Model-View-ViewModel 的缩写，它是一种基于前端开发的架构模式，其核心是提供对View 和 ViewModel 的双向数据绑定，这使得ViewModel 的状态改变可以自动传递给 View，即所谓的数据双向绑定。 而Vue框架则是一个提供了 MVVM 风格的双向数据绑定的 Javascript 库，专注于View 层。它的核心是 MVVM 中的 VM，也就是 ViewModel。 ViewModel负责连接 View 和 Model，保证视图和数据的一致性，这种轻量级的架构让前端开发更加高效、便捷。","categories":[{"name":"Web前端","slug":"Web前端","permalink":"https://tangyanqiong.com/categories/Web前端/"},{"name":"Vue","slug":"Web前端/Vue","permalink":"https://tangyanqiong.com/categories/Web前端/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://tangyanqiong.com/tags/Vue/"},{"name":"Web","slug":"Web","permalink":"https://tangyanqiong.com/tags/Web/"},{"name":"MVVM","slug":"MVVM","permalink":"https://tangyanqiong.com/tags/MVVM/"}]},{"title":"Swift中UILabel设置角标","slug":"Swift设置角标","date":"2018-12-20T07:10:08.000Z","updated":"2019-06-06T01:48:00.876Z","comments":true,"path":"post/f0789496.html","link":"","permalink":"https://tangyanqiong.com/post/f0789496.html","excerpt":"项目开发中，我们往往会遇到客户提出设置角标的需求，如下图： 这种是怎么实现的呢？","text":"项目开发中，我们往往会遇到客户提出设置角标的需求，如下图： 这种是怎么实现的呢？ 其实也很简单，我们用富文本就能实现这种方式。 12345678let text = (textLabel.text)!let attrText = NSMutableAttributedString(string: text)var: scaleRange = (text as NSString).range(of: &quot;r&quot;)attrText.addAttribute(NSAttributedString.Key.font, value: UIFont.systemFont(ofSize: textLabel.font.pointSize*0.8), range: scaleRange) //设置角标的字体大小 attrText.addAttribute(NSAttributedString.Key.foregroundColor, value: textLabel.textColor, range: scaleRange) //设置角标的字体颜色textLabel.attributedText = attrText 那-1在右上角的这种方式又是怎么实现的呢？ 如下： 12scaleRange = (text as NSString).range(of: &quot;-1&quot;)attrText.addAttribute(NSAttributedString.Key.baselineOffset, value: (textLabel.font.pointSize*0.4), range: scaleRange) 同理，在OC里，同样用富文本也可实现角标显示。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://tangyanqiong.com/categories/iOS/"},{"name":"Swift","slug":"iOS/Swift","permalink":"https://tangyanqiong.com/categories/iOS/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://tangyanqiong.com/tags/Swift/"},{"name":"角标","slug":"角标","permalink":"https://tangyanqiong.com/tags/角标/"}]},{"title":"iOS纯播放器（适配器）","slug":"iOS播放器适配器","date":"2018-10-06T02:45:35.000Z","updated":"2019-06-06T09:48:36.082Z","comments":true,"path":"post/4d0d70a6.html","link":"","permalink":"https://tangyanqiong.com/post/4d0d70a6.html","excerpt":"前言背景以前写过一套播放器，详见iOS流媒体播放器，结合了UI与播放层，集成使用很方便，但是呢，定制性很强，想要修改UI层或新增另外的功能，比较不好拓展，还因为公司播放类的项目很多，也为了能适用到其他项目，不同项目不同UI层或者有些定制化的需求，所以我将UI与播放层进行了拆分，使播放器变得更纯粹。 诞生由此，一个纯播放层播放器TDPlayerLite应运而生，哈哈，该播放器采取适配器模式，有基于AVPlayer封装的，也可集成其他播放器，例DRM播放器，或者音乐播放器，都可以，这样对在项目中不同地方使用不同播放器提供很大便利。","text":"前言背景以前写过一套播放器，详见iOS流媒体播放器，结合了UI与播放层，集成使用很方便，但是呢，定制性很强，想要修改UI层或新增另外的功能，比较不好拓展，还因为公司播放类的项目很多，也为了能适用到其他项目，不同项目不同UI层或者有些定制化的需求，所以我将UI与播放层进行了拆分，使播放器变得更纯粹。 诞生由此，一个纯播放层播放器TDPlayerLite应运而生，哈哈，该播放器采取适配器模式，有基于AVPlayer封装的，也可集成其他播放器，例DRM播放器，或者音乐播放器，都可以，这样对在项目中不同地方使用不同播放器提供很大便利。 集成与使用实现模式TDPlayerLite采用适配器模式，所有对外的方法和代理都放在BasePlayer类，需要集成某播放器时，以集成系统播放器AVPlayer为例，继承BasePlayer类生成ReAVPlayer类，在ReAVPlayer类里实现AVPlayer的装载，也实现BasePlayer类对外暴露的方法。 优点：这种模式能够快速集成不同播放器到项目中，且不会影响到原项目。 导入Demo里PlayerAdapter直接拖往工程里，就可直接使用。 目录PlayerManager12345678910/** 播放器类型，目前有系统播放器及DRM播放器 */typedef enum _PlayerManagerType&#123; PlayerManagerTypeNone = 0, PlayerManagerTypeAVPlayer = 1, PlayerManagerTypeVisualOnPlayer = 2 //DRM //还可添加其他类型的播放器&#125; PlayerManagerType; 使用PlayerManager类可传入不同类型生成对应播放器： 1self.player = [[PlayerManager manager] getPlayerBy:self.playerView andPlayerType:PlayerManagerTypeVisualOnPlayer]; 若不传入Type，默认生成AVPlayer播放器 BasePlayer它是播放器基类，其实BasePlayer.h里注释已经写得很全面了，每个属性和方法的使用和用途都有注释，这里不赘述了。 说下BasePlayer这个类的作用，写这个类的目录是为了把与外部交互数据统一化，且把播放器产生的数据全面的归整统一对外提供，后面集成进来的播放器，都继承这个基类，实现其方法。 例如： 此自定义的播放器状态基本概括了全部状态，对用户特别友好，能够在不同状态提示用户，提升了用户体验。 BTW：系统播放器AVPlayer经常就有乱调、部分视频状态没有的情况，所以我在ReAVPlayer做了兼容性处理，当你需要集成其他播放器时，也需要做相关处理，保证最外层使用的Player的使用完整性。 BasePlayer_Methods扩展类，可加入BasePlayer的扩展接口或属性。 ReAVPlayer该类继承于BasePlayer，里面装载了系统播放器AVPlayer，使用该类实际就是使用系统播放器，AVPlayer一些兼容性处理也放在了里面。 总结这个播放器我们已经应用到了很多项目中，也已经上线测试了很多版本，已经是很稳定的版本了，不用担心在使用中会出现什么奇怪难解的问题了。 另，目前TDPlayerLite相当于是一个播放器的适配器，如果你只是单纯的想用一个稳定友好的系统播放器，可直接导入Players文件夹使用。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://tangyanqiong.com/categories/iOS/"},{"name":"OC","slug":"iOS/OC","permalink":"https://tangyanqiong.com/categories/iOS/OC/"}],"tags":[{"name":"Object-C","slug":"Object-C","permalink":"https://tangyanqiong.com/tags/Object-C/"},{"name":"AVPlayer","slug":"AVPlayer","permalink":"https://tangyanqiong.com/tags/AVPlayer/"},{"name":"DRMPlayer","slug":"DRMPlayer","permalink":"https://tangyanqiong.com/tags/DRMPlayer/"},{"name":"适配器","slug":"适配器","permalink":"https://tangyanqiong.com/tags/适配器/"}]},{"title":"OC工程怎么转换为Swift工程","slug":"octoswift","date":"2018-08-24T09:42:27.000Z","updated":"2019-05-27T06:32:07.471Z","comments":true,"path":"post/dff23fd2.html","link":"","permalink":"https://tangyanqiong.com/post/dff23fd2.html","excerpt":"前言前段时间用Object-C正在开发一个项目，开发了差不多百分之七八十了，客户通知要求改成Swift语言开发（因为他只会Swift），好吧，一个项目用Swift来写其实也无可厚非，但是这个项目中途来换，可想而知是多么痛苦的事，已经写了好多个OC类。","text":"前言前段时间用Object-C正在开发一个项目，开发了差不多百分之七八十了，客户通知要求改成Swift语言开发（因为他只会Swift），好吧，一个项目用Swift来写其实也无可厚非，但是这个项目中途来换，可想而知是多么痛苦的事，已经写了好多个OC类。 步骤调研之前一开始也在网上找了很多资料，有OC与Swift对应功能的语法解说，也有贴代码用工具直接转的，用过iSwift，但不是很好用，识别率不高，正确率不高。 这些都感觉比较费时（客户只给了一周的时间），然后就在想，有没有一个是直接可以转工程的工具呢？别说，强大的google还真搜出来了，这个软件可以直接转换工程。 实施这个软件叫什么名呢，也不卖关子了，是一个在线转换的网站： OC2Swift 它是提供少量代码免费转换，大家可转换自己的部分代码看看正确性，还可以在线输出Swift代码结果，它可以单文件、文件夹或工程打包在线转换。 不过呢，好的软件都是收费的，具体资费我就不说了（避免托的嫌疑，有需要的上官网自己看吧），对于转换的成本来说这个价格很便宜了。 结果注意点 给大家一个建议，这个购买后使用有流量限制，建议打包的时候把静态库、framwork、SDK、第三方库等相关的剔除后打包上传，转换成功后再放置到对应路径下。 原OC代码留存（原因见下面）。 问题这个工程转换成功后，使用起来就没有一点问题了吗？ 错错错，当初我记得一开始报错不怎么多几十个吧，关键改完后，不断的重编译就暴露更多的错，这样下来估计也改了有几百个错了。 是什么类型的错误 很多都是语法的错误，而Xcode有提示修正的方法，直接鼠标点点点就改好了，比较轻松。 有些是语法不识别的问题，这个就需要自己查资料对应OC代码寻找对应的Swift代码了，所以要留存原OC代码。 有些工程设置的地方报错，但是这个很少，就几处，百度google就能解决。 最后然后，到了这一步，以为万事大吉了吗？哈哈，并没有，有些地方转换虽说没报错，但可能会转错意，需要整体流程跑下，最好找测试再过遍流程，切记。 PS：有些OC库实在没办法转的，就采取桥接的方式使用吧。 总结总体来说，这次的转换是很成功的，原本估时为一周，但是实际2～3天就完成了转换，比较高效率，所以建议大家转换Swift可采取这种方式。 比较遗憾的是，当时时间比较赶，没来得及截图留存给大家，如果觉得文章上有什么疑问，或者实际实践过程中遇到什么问题，欢迎大家在下方留言告诉我，我会第一时间回复你。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://tangyanqiong.com/categories/iOS/"},{"name":"Swift","slug":"iOS/Swift","permalink":"https://tangyanqiong.com/categories/iOS/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://tangyanqiong.com/tags/Swift/"},{"name":"Object-C","slug":"Object-C","permalink":"https://tangyanqiong.com/tags/Object-C/"}]},{"title":"怎么使用Hexo编写博客","slug":"hexo-use","date":"2018-05-18T07:39:43.000Z","updated":"2019-05-27T06:45:04.611Z","comments":true,"path":"post/4f821c45.html","link":"","permalink":"https://tangyanqiong.com/post/4f821c45.html","excerpt":"前言由于网上太多关于github+hexo搭建教程，搭建这里就不多说了，推荐之前搭建参考的网址： 使用hexo+github搭建免费个人博客详细教程 GitPages+Hexo搭建个人博客 搭建完成后，怎么使用hexo这个框架，网页的排版这些就很难找到相关资料了，自己研究了下，具体整理出来，方便后面的人使用。","text":"前言由于网上太多关于github+hexo搭建教程，搭建这里就不多说了，推荐之前搭建参考的网址： 使用hexo+github搭建免费个人博客详细教程 GitPages+Hexo搭建个人博客 搭建完成后，怎么使用hexo这个框架，网页的排版这些就很难找到相关资料了，自己研究了下，具体整理出来，方便后面的人使用。 目录 博客功能配置 根目录_config.yml配置 Hexo常用命令 博客功能配置主题配置官方提供很多主题，这里放两个主题，其他可以自行度娘，博主更偏爱material-x主题，哈哈。到指定目录下clone。 1234$ cd /Users/TangDan/GitHub/MyHexoBlog/themes$ hexo clean$ git clone https://github.com/iissnan/hexo-theme-next$ git clone https://github.com/xaoxuu/hexo-theme-material-x themes/material-x //本博客使用主题 现在themes目录下应该多了两个目录：next、material-x，然后到_config.yml修改theme: material-x，再执行 1234$ cd /Users/TangDan/GitHub/MyHexoBlog$ hexo g$ hexo d //推送到远端$ hexo server //本地查看 PS:运行中出现任何问题，可以先hexo clean再执行。 两个主题配置这两个主题配置其实说难不难，说简单不简单，目前我是只去研究了material-x主题的配置，过程即酸爽又享受。 Next主题官方配置文档Material-X主题官方配置文档PS：请一定要仔细的去读官方文档，不要看了这个文档一半又跑去查其他的资料，其他的资料可能更新没官方那么快，是老版本的，到最后一顿操作猛如虎，结果等于白忙，不要问我怎么知道的，我不会告诉你，= =！ 链接持久化hexo默认的链接是http://xxx.com/2017/08/18/hello-world 这种类型的，这种路径看着也挺low的，这源于站点配置文件_config.yml里的配置: permalink: :year/:month/:day/:title/. 这种默认配置的缺点就是当我们创建的博文名包含中文的名的时候，url 链接地址经常会变成一串很长的难以理解的字符串，不利于博文的链接分享，以及搜索引擎搜索，另外就是年月日都会有分隔符。我们可以让 url 链接持久化来解决这个问。 安装hexo-abbrlink插件 $ sudo npm install hexo-abbrlink 修改站点配置文件 _config.yml permalink: post/:abbrlink.html 添加 abbrlink: 123456permalink: post/:abbrlink.html # :year/:month/:day/:title/ # 文章的永久链接格式permalink_defaults: # 永久链接中个部分的默认值# abbrlink config 需安装插件hexo-abbrlinkabbrlink: alg: crc32 # 算法： crc16(default) and crc32 rep: hex # 进制： dec(default) and hex 站内搜索安装 hexo-generator-search 插件 $ sudo npm install hexo-generator-search 配置站点文件_config.yml: 1234567# 站内搜索search: path: search.xml field: postlocal_search: enable: true 根目录_config.yml配置站点配置（重要）123456title: 博客名 //网站标题subtitle: To strive, to seek, to find //网站副标题description: To strive, to seek, to find, and not to yield. //网站描述author: WenBo //您的名字language: zh-Hans //网站使用的语言 简体中文 zh-Hanstimezone: //网站时区。Hexo 默认使用您电脑的时区 URL配置1234url: http://blogwenbo.com/ //网址root: / //网站根目录permalink: :year/:month/:day/:title/ // 文章的 [永久链接](https://hexo.io/zh-cn/docs/permalinks.html) 格式 | `:year/:month/:day/:title/` |permalink_defaults: //永久链接中各部分的默认值 目录配置12345678source_dir: source //资源文件夹，这个文件夹用来存放内容。默认值：sourcepublic_dir: public //公共文件夹，这个文件夹用于存放生成的站点文件。默认值：publictag_dir: tags //标签文件夹 默认值：tagsarchive_dir: archives //归档文件夹 默认值：archivescategory_dir: categories //分类文件夹 默认值：categoriescode_dir: downloads/code //Include code 文件夹 默认值：downloads/codei18n_dir: :lang //国际化（i18n）文件夹 默认值：:langskip_render: README.md //跳过指定文件的渲染，您可使用 [glob 表达式](https://github.com/isaacs/node-glob)来匹配路径。 Git部署配置（重要）1234deploy: type: git //填git repo: git@github.com:wenmobo/wenmobo.github.io.git //SSH地址 branch: master //分支 Hexo常用命令其实搭建成功后，在/Users/TangDan/GitHub/MyHexoBlog/source/_posts里默认会有生成一个hello-world.md，这个里面描述了常用的哪些命令及意义，可在里面查看。 总体来说，提交一个修改，最好顺序执行以下命令： 123$ hexo clean$ hexo g$ hexo d","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://tangyanqiong.com/categories/Hexo/"}],"tags":[{"name":"Hexo命令","slug":"Hexo命令","permalink":"https://tangyanqiong.com/tags/Hexo命令/"},{"name":"Material-X主题","slug":"Material-X主题","permalink":"https://tangyanqiong.com/tags/Material-X主题/"}]},{"title":"iOS流媒体播放器","slug":"iOS流媒体播放器","date":"2017-03-05T03:02:20.000Z","updated":"2019-06-06T07:07:34.901Z","comments":true,"path":"post/70bc6a39.html","link":"","permalink":"https://tangyanqiong.com/post/70bc6a39.html","excerpt":"前言我写了一个iOS流媒体播放器Demo：TDPlayer，需要的朋友可下载，播放器底层播放这层本文就不做赘述了，本文主要针对TDPlayer（播放与UI）的分解使用讲解，Demo实际效果如下：","text":"前言我写了一个iOS流媒体播放器Demo：TDPlayer，需要的朋友可下载，播放器底层播放这层本文就不做赘述了，本文主要针对TDPlayer（播放与UI）的分解使用讲解，Demo实际效果如下： 集成与使用导入Demo里TDPlayer直接拖往工程里，就可直接使用。 目录TDPlayerConfigTDPlayerConfig.h配置文件，一些自定义配置可在里面设置。 TDPlayerView播放器View层，此层在Player上面，也在播放器UI层的最低层，作为中间层来执行UI层与Player数据交互，对外交互也应是此View来完成。 TDPlayerTopBar播放器Top层，可设置标题，有左右按钮交互事件等。 TDPlayerBottomBar播放器Bottom层，为用户与播放交互层，播放\\暂停，快进\\快退，音量调节，上\\下一页都在这层实现。 TDPlayerStatusView该View简单来所就是用户友好提示页，根据视频的状态来显示加载、正常、结束、失败、错误状态UI，还提供重新播放功能。 TDPlayerLoadingView视频加载过程中出现的加载View，以及还支持显示当前的加载网速。 使用其实对外的接口，我已经封装得比较简单易懂了，外部使用直接使用TDPlayerView这个类，如下：（Demo上还有代理回调的使用） 123456789101112tdPlayerView = [[TDPlayerView alloc] initWithFrame:CGRectMake(0, 0, selfWidth, selfHeight)];tdPlayerView.delegate = self;[self.view addSubview:tdPlayerView]; [tdPlayerView startLoadingWithTitleStr:@&quot;测试视频&quot;]; self.playUrl = @&quot;http://182.138.101.48:5001/nn_vod/nn_x64/aWQ9NWZlOTljZWYwY2Q0Mzk3ZGRlNjI1MDExMTE0OGFlNjMmdXJsX2MxPTZkNmY2OTc2NjU3MzJmMzA2MjYzMzQzODMzNjUzMDY1MzIzMTYzNjYzMTMzMzAzMzYyMzUzNzM3MzkzMjY1NjE2MTM0Mzg2NjY2NjQzMzJlNzQ3MzIwMDAmbm5fYWs9MDFkZTU0YTczNjYxOWZiODdlMzU1NjgxZjEzZGNhYzc4ZCZudHRsPTMmbnBpcHM9MTgyLjEzOC4xMDEuNDg6NTEwMSZuY21zaWQ9MTAwMDAxJm5ncz01NTFlMDQxYTAwMGI5NWYxNWVjZjc1NTg2MDYyMTZiOCZubl91c2VyX2lkPVlZSEQwMDAwMDc3OSZuZHY9MS4wLjAuMC4yLlNDLUpHUy1JUEhPTkUuMC4wX1JlbGVhc2UmbmVhPSZuZXM9/5fe99cef0cd4397dde6250111148ae63.ts&quot;; if ([self.playUrl rangeOfString:@&quot;.ts&quot;].location != NSNotFound) &#123; self.playUrl = [self.playUrl stringByReplacingOccurrencesOfString:@&quot;.ts&quot; withString:@&quot;.m3u8&quot;];&#125;[tdPlayerView playVideoByUrl:self.playUrl]; 值得注意的是：iOS播放器是不支持ts后缀地址播放的，替换成m3u8后缀即可，实际m3u8是一个索引文件，播放时，会根据索引去下载对应的ts分片进行播放。 总结优缺点TDPlayer将播放层及UI层统一进行了封装，如果你的需求仅仅是播放一个视频，对UI要求不高，这套使用起来还是很方便的。 但是，缺点是什么呢？耦合度太高，播放层与UI层粘性高，不利用扩展或修改。 推荐这里提供一个无UI的纯播放适配器TDPlayerLite，这个将AVPlayer一些回调乱调、状态不友好的问题内部解决了，并封装了一套用户友好的代理出来，很好集成与使用。 此纯播放器SDK，具体集成与使用详见：iOS纯播放器（适配器）","categories":[{"name":"iOS","slug":"iOS","permalink":"https://tangyanqiong.com/categories/iOS/"},{"name":"OC","slug":"iOS/OC","permalink":"https://tangyanqiong.com/categories/iOS/OC/"}],"tags":[{"name":"Object-C","slug":"Object-C","permalink":"https://tangyanqiong.com/tags/Object-C/"},{"name":"播放器","slug":"播放器","permalink":"https://tangyanqiong.com/tags/播放器/"}]}]}