{"meta":{"title":"Root's Blog","subtitle":null,"description":null,"author":"Root","url":"https://tangyanqiong.com","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-05-24T08:41:03.975Z","updated":"2019-05-24T08:41:03.963Z","comments":true,"path":"404.html","permalink":"https://tangyanqiong.com/404.html","excerpt":"","text":"404 Not Found 很抱歉，您访问的页面不存在您可以留言告诉我哪个页面找不到，谢谢您的提议！"},{"title":"所有分类","date":"2018-02-23T03:43:30.000Z","updated":"2019-07-26T08:43:38.328Z","comments":true,"path":"categories/index.html","permalink":"https://tangyanqiong.com/categories/index.html","excerpt":"","text":""},{"title":"归档","date":"2018-02-20T03:44:04.000Z","updated":"2019-07-26T08:31:49.000Z","comments":true,"path":"archives/index.html","permalink":"https://tangyanqiong.com/archives/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2018-02-24T03:43:12.000Z","updated":"2019-07-26T08:31:37.530Z","comments":true,"path":"tags/index.html","permalink":"https://tangyanqiong.com/tags/index.html","excerpt":"","text":""},{"title":"关于我","date":"2018-03-18T06:22:35.000Z","updated":"2019-07-26T08:31:54.085Z","comments":true,"path":"about/index.html","permalink":"https://tangyanqiong.com/about/index.html","excerpt":"","text":"自我介绍我大学其实学的是通信工程，大学时期，一次机缘巧合看到土豪朋友在玩iPhone 3GS，天啦，在那个还是手机键盘咔咔敲的年代，突然一个全触屏的科技性手机迅速吸引了我的眼球。大学毕业后看到有公司招iPhone开发实习生，被iPhone影响深刻的我，毫不犹豫的加入了，成为了一名iOS开发攻城师，目前也在搞Web开发和学习小程序开发。我平时其实是一个比较闷的人，喜欢看美剧、旅游、玩游戏，爱好美食。 共勉所谓技多不压身，在互联网这个更新迭代非常迅速的时代，只有不断的提升自己来与时俱进，避免被淘汰，且职场上女性更容易被歧视，其实很不想讲出这样的话，但目前的大环境来说，特别是IT行业，程序员的保鲜程度就在20-35岁，特别对女程序员相关条件更是苛刻。 So，无论你是程序猿还是程序媛，希望我们都能在互联网这个行业继续艰苦的摸爬滚打，无论你是被生活压弯了腰还是兴趣所向在这条路上，希望你一切都好，继续努力，为了你爱的人和爱你的人！ 共勉之有话要说小伙伴你们是怎么进入到互联网的行业呢，是各种机缘巧合还是兴趣所向呢，动动你发财的小手，在评论区告诉我吧，哈哈。"}],"posts":[{"title":"跨平台RN与Flutter对比及学习","slug":"跨平台","date":"2020-03-25T07:42:34.000Z","updated":"2020-03-25T08:31:25.645Z","comments":true,"path":"post/196a8be9.html","link":"","permalink":"https://tangyanqiong.com/post/196a8be9.html","excerpt":"前言最近想学跨平台开发，在RN和Flutter中纠结学哪个，看了资料RN对Web前端比较友好，都是JS开发语言，比较容易上手，但是有个以前的iOS同事，他现在已经用Flutter着手在开发iOS、Android了，据他说很好用。","text":"前言最近想学跨平台开发，在RN和Flutter中纠结学哪个，看了资料RN对Web前端比较友好，都是JS开发语言，比较容易上手，但是有个以前的iOS同事，他现在已经用Flutter着手在开发iOS、Android了，据他说很好用。 对比跨平台，首先考虑的就是性能问题，谁的性能好，未来必将是谁的天下。 RN性能RN的效率由于是将View编译成了原生View，所以效率上要比基于Cordova的HTML5高很多，但是它也有效率问题，RN的渲染机制是基于前端框架的考虑，复杂的UI渲染是需要依赖多个view叠加。比如我们渲染一个复杂的ListView，每一个小的控件，都是一个native的view，然后相互组合叠加，想想此时如果我们的list再需要滑动刷新，会有多少个对象需要渲染，所以也就有了前面所说的RN的列表方案不友好。 RN框架原理图 Flutter性能而Flutter则吸收了前两者的教训之后，在渲染技术上，选择了自己实现(GDI)，有自己的一套UI系统，由于有更好的可控性，使用了新的语言Dart，避免了RN的那种通过桥接器与Javascript通讯导致效率低下的问题，所以在性能方面无可厚非比RN更高一筹，有经验的开发者可以打开Android手机开发者选项里面的显示边界布局，发现Flutter的布局是一个整体，说明Flutter的渲染没用使用原生控件进行渲染。 Flutter框架原理图 异同 Flutter性能会更好无线接近原生的体验,Dart是AOT编译的，编译成快速、可预测的本地代码 RN采用JS语言开发，基于React，对前端工程师更友好。Dart语言受众小 Flutter自己实现了一套UI框架，丢弃了原生的UI框架。而RN还是可以自己利用原生框架，两个各有好处。Flutter的兼容性高，RN可以利用原生已有的优秀UI RN的布局更像css，而Flutter的布局更像native布局，但是去掉xml通过代码直接写需要适应下 总结对比了RN/Flutter后，我觉得对于我来说，RN应该很容易上手，因为有前端基础，RN学习起来应该很快，但是我也不想放弃Flutter，Flutter布局像原生布局，有iOS开发经验的我也不想放弃，因为有iOS同事成功上车的前车之鉴，所以我也很有信心能学好它，从性能来说我也更偏向Flutter，但是也不想浪费RN这个学习机会，所以就我自己的实际情况而言，我会两个都学。 总之，一句话吧，基于自身实际情况，没有更好只有最适合你的框架。","categories":[],"tags":[{"name":"RN","slug":"RN","permalink":"https://tangyanqiong.com/tags/RN/"},{"name":"Flutter","slug":"Flutter","permalink":"https://tangyanqiong.com/tags/Flutter/"}]},{"title":"Vue主题import出错","slug":"vue主题import出错","date":"2019-08-01T03:52:00.000Z","updated":"2019-08-01T06:47:43.497Z","comments":true,"path":"post/52c1147f.html","link":"","permalink":"https://tangyanqiong.com/post/52c1147f.html","excerpt":"问题在main.js文件中import‘../theme/index.css’ 报错： 12345ERROR Failed to compile with 1 errors This relative module was not found:* ../theme/index.css in ./src/main.js","text":"问题在main.js文件中import‘../theme/index.css’ 报错： 12345ERROR Failed to compile with 1 errors This relative module was not found:* ../theme/index.css in ./src/main.js 原因原来在webpack.base.conf.js中有导入过如下代码，可能是webpack.base.conf.js和utils.js重复编译SCSS文件导致报错。 12345// 导入SCSS&#123; test: /\\.(scss|css)?$/, loaders: [&quot;style&quot;, &quot;css&quot;, &quot;sass&quot;]&#125; 解决方案删除上述在webpack.base.conf.js中导入的SCSS代码，即可。","categories":[{"name":"Web","slug":"Web","permalink":"https://tangyanqiong.com/categories/Web/"},{"name":"Vue","slug":"Web/Vue","permalink":"https://tangyanqiong.com/categories/Web/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://tangyanqiong.com/tags/Vue/"},{"name":"CSS","slug":"CSS","permalink":"https://tangyanqiong.com/tags/CSS/"}]},{"title":"Vue项目缩进问题","slug":"vue缩进","date":"2019-07-30T09:50:46.000Z","updated":"2019-07-31T02:01:29.362Z","comments":true,"path":"post/db5c826e.html","link":"","permalink":"https://tangyanqiong.com/post/db5c826e.html","excerpt":"问题WebStorm的缩进规则和ESlint-vue的校验规则冲突引起的问题。 前提条件 Vue项目 安装时打开ESLint校验功能 开发工具WebStorm 代码格式化会出现两种：","text":"问题WebStorm的缩进规则和ESlint-vue的校验规则冲突引起的问题。 前提条件 Vue项目 安装时打开ESLint校验功能 开发工具WebStorm 代码格式化会出现两种： WebStorm格式化： 1234&lt;script&gt; exports default &#123; &#125;&lt;/script&gt; ESlint格式化： 1234&lt;script&gt;exports default &#123;&#125;&lt;/script&gt; 解决方案打开项目根下的.eslintrc.js文件，将rules节点中添加以下配置项，其中’2’是指统一缩进2个空格，’1’是指1倍缩进。 1&apos;vue/script-indent&apos;: [&apos;error&apos;, 2, &#123;&apos;baseIndent&apos;: 1&#125;] 另外需要添加以下节点，与rules节点同级： 1234567overrides: [ &#123; &apos;files&apos;: [&apos;*.vue&apos;], &apos;rules&apos;: &#123; &apos;indent&apos;: &apos;off&apos; &#125; &#125;] 问题搞定。","categories":[{"name":"Web","slug":"Web","permalink":"https://tangyanqiong.com/categories/Web/"},{"name":"Vue","slug":"Web/Vue","permalink":"https://tangyanqiong.com/categories/Web/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://tangyanqiong.com/tags/Vue/"},{"name":"ESLint","slug":"ESLint","permalink":"https://tangyanqiong.com/tags/ESLint/"},{"name":"WebStorm","slug":"WebStorm","permalink":"https://tangyanqiong.com/tags/WebStorm/"}]},{"title":"Github代码下载提速","slug":"github提速","date":"2019-07-25T08:06:27.000Z","updated":"2019-07-26T09:42:14.807Z","comments":true,"path":"post/1e0383f0.html","link":"","permalink":"https://tangyanqiong.com/post/1e0383f0.html","excerpt":"前言之前pod install安装GRPC出现各种错误，在网上找了各种办法，还重装过git以及pod都没有用，还是报类似如下错误。 123456789101112131415161718[!] Error installing !ProtoCompiler[!] /usr/bin/curl -f -L -o /var/folders/1s/jw93vj050vq92gbrjv1c3x880000gn/T/d20190718-18563-1fzxwnx/file.zip https://github.com/google/protobuf/releases/download/v3.8.0/protoc-3.8.0-osx-x86_64.zip --create-dirs --netrc-optional --retry 2 % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 162 0 162 0 0 11 0 --:--:-- 0:00:14 --:--:-- 39100 617 0 617 0 0 40 0 --:--:-- 0:00:15 --:--:-- 602k 10 2794k 10 305k 0 0 835 0 0:57:06 0:06:14 0:50:52 0curl: (56) LibreSSL SSL_read: SSL_ERROR_SYSCALL, errno 54[!] Error installing BoringSSL-GRPC[!] /usr/bin/git clone https://github.com/google/boringssl.git /var/folders/1s/jw93vj050vq92gbrjv1c3x880000gn/T/d20190718-18162-1vck5op --template=Cloning into &apos;/var/folders/1s/jw93vj050vq92gbrjv1c3x880000gn/T/d20190718-18162-1vck5op&apos;...error: RPC failed; curl 18 transfer closed with outstanding read data remainingfatal: The remote end hung up unexpectedlyfatal: early EOFfatal: index-pack failed 之前没想过是网络的原因导致，因为挂VPN也出现了这种情况，后来一一排除，pod install –verbose 打印log，才发现根本就是github下载速度过慢，甚至连接超时导致。 那怎么来提高github下载代码的速度呢？","text":"前言之前pod install安装GRPC出现各种错误，在网上找了各种办法，还重装过git以及pod都没有用，还是报类似如下错误。 123456789101112131415161718[!] Error installing !ProtoCompiler[!] /usr/bin/curl -f -L -o /var/folders/1s/jw93vj050vq92gbrjv1c3x880000gn/T/d20190718-18563-1fzxwnx/file.zip https://github.com/google/protobuf/releases/download/v3.8.0/protoc-3.8.0-osx-x86_64.zip --create-dirs --netrc-optional --retry 2 % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 162 0 162 0 0 11 0 --:--:-- 0:00:14 --:--:-- 39100 617 0 617 0 0 40 0 --:--:-- 0:00:15 --:--:-- 602k 10 2794k 10 305k 0 0 835 0 0:57:06 0:06:14 0:50:52 0curl: (56) LibreSSL SSL_read: SSL_ERROR_SYSCALL, errno 54[!] Error installing BoringSSL-GRPC[!] /usr/bin/git clone https://github.com/google/boringssl.git /var/folders/1s/jw93vj050vq92gbrjv1c3x880000gn/T/d20190718-18162-1vck5op --template=Cloning into &apos;/var/folders/1s/jw93vj050vq92gbrjv1c3x880000gn/T/d20190718-18162-1vck5op&apos;...error: RPC failed; curl 18 transfer closed with outstanding read data remainingfatal: The remote end hung up unexpectedlyfatal: early EOFfatal: index-pack failed 之前没想过是网络的原因导致，因为挂VPN也出现了这种情况，后来一一排除，pod install –verbose 打印log，才发现根本就是github下载速度过慢，甚至连接超时导致。 那怎么来提高github下载代码的速度呢？ 实现获取IP地址点击进入获取IP网址，获取到本机对应以下三个网址的IP地址。 github.com github.global.ssl.fastly.net codeload.github.com 每个人的都不一样，这是我获取到的IP地址： 123140.82.113.4 github.com151.101.185.194 github.global.ssl.fastly.net140.82.114.9 codeload.github.com 修改系统hosts文件Windows系统 hosts文件路径：C:\\Windows\\System32\\drivers\\etc\\hosts , 添加上面查询到的IP到hosts文件中（此时可能需要管理员权限,可以将hosts复制到桌面，修改好了再复制回去覆盖原来的） 修改完成后刷新DNS1ipconfig /flushdns Mac系统在Finder-&gt;前往-&gt;前往文件夹，在框里输入/etc/hosts，找到hosts文件，可以将hosts文件复制到桌面，将ip地址添加到里面，修改好了再复制回去覆盖原来的hosts文件。 最后在终端执行刷新DNS命令 1dscacheutil -flushcache 效果提速前的效果未截图，反正最快就是10多kb的样子，提速后效果如下： GRPC报错的相关问题也迎刃而解。","categories":[{"name":"Others","slug":"Others","permalink":"https://tangyanqiong.com/categories/Others/"}],"tags":[{"name":"GRPC","slug":"GRPC","permalink":"https://tangyanqiong.com/tags/GRPC/"},{"name":"Github","slug":"Github","permalink":"https://tangyanqiong.com/tags/Github/"}]},{"title":"Swift上View手势控制","slug":"Swift中View手势控制","date":"2019-06-03T07:31:20.000Z","updated":"2019-06-06T02:00:27.137Z","comments":true,"path":"post/a17aa0f4.html","link":"","permalink":"https://tangyanqiong.com/post/a17aa0f4.html","excerpt":"前言对View进行放大缩小、移动、旋转，其实是很常见的需求，最开始在OC上，很早的几年，还是用的touch事件来实现，这种实现方式很繁琐，呈现的效果也不是很好。 后来，苹果也逐步的淘汰了这种方式，出了手势这种模式，极大程度上的缩减了代码量，而且操作简单，上手迅速，OC上手势的使用方式网上比比皆是，这里就不细说，着重介绍Swift View手势控制方法。","text":"前言对View进行放大缩小、移动、旋转，其实是很常见的需求，最开始在OC上，很早的几年，还是用的touch事件来实现，这种实现方式很繁琐，呈现的效果也不是很好。 后来，苹果也逐步的淘汰了这种方式，出了手势这种模式，极大程度上的缩减了代码量，而且操作简单，上手迅速，OC上手势的使用方式网上比比皆是，这里就不细说，着重介绍Swift View手势控制方法。 实现添加旋转、缩放、移动手势，如下： 1234567891011//Rotationlet rotationGestureRecognizer = UIRotationGestureRecognizer(target: self, action: #selector(EditPhotoViewController.rotateView(_:)))photoImageView?.addGestureRecognizer(rotationGestureRecognizer)//Scale pinchlet pinchGestureRecognizer = UIPinchGestureRecognizer(target: self, action: #selector(EditPhotoViewController.pinchView(_:)))photoImageView?.addGestureRecognizer(pinchGestureRecognizer)//Movelet panGestureRecognizer = UIPanGestureRecognizer(target: self, action: #selector(EditPhotoViewController.panView(_:)))photoImageView?.addGestureRecognizer(panGestureRecognizer) 以下代码使用变量如下： private var cropFrame = CGRect.zero //图片上限制框的frame private var latestFrame = CGRect.zero //最大缩放frame private var rotationAngle: CGFloat = 0.0 //旋转的角度 给变量设置初始值： 12345678910111213141516171819202122private func resetShowImageViewFrame() &#123; rotationAngle = 0.0 photoImageView?.image = originalImage photoImageView?.transform = .identity // scale to fit the screen cropFrame = photoOverLayView?.transparentArea ?? CGRect.zero var oriWidth: CGFloat = cropFrame.size.width var oriHeight: CGFloat = (originalImage?.size.height ?? 0.0) * (oriWidth / (originalImage?.size.width ?? 0.0)) if ((originalImage?.size.width)!/(originalImage?.size.height)!) &gt; (CGFloat)(standardPostImgWidth)/(CGFloat)(standardPostImgHeight) &#123; oriHeight = cropFrame.size.height oriWidth = (originalImage?.size.width ?? 0.0) * (oriHeight / (originalImage?.size.height ?? 0.0)) &#125; let oriX: CGFloat = cropFrame.origin.x + (cropFrame.size.width - oriWidth) / 2 let oriY: CGFloat = cropFrame.origin.y + (cropFrame.size.height - oriHeight) / 2 oldFrame = CGRect(x: oriX, y: oriY, width: oriWidth, height: oriHeight) latestFrame = oldFrame photoImageView?.frame = oldFrame largeFrame = CGRect(x: 0, y: 0, width: limitRatio * oldFrame.size.width, height: limitRatio * oldFrame.size.height)&#125; 旋转实现12345678910@objc func rotateView(_ rotationGestureRecognizer: UIRotationGestureRecognizer?) &#123; let view: UIView? = photoImageView if rotationGestureRecognizer?.state == .began || rotationGestureRecognizer?.state == .changed &#123; view?.transform = (view?.transform.rotated(by: (rotationGestureRecognizer?.rotation)!))! rotationAngle = rotationAngle + (rotationGestureRecognizer?.rotation ?? 0.0) rotationGestureRecognizer?.rotation = 0 &#125; else if rotationGestureRecognizer?.state == .ended &#123; latestFrame = photoImageView?.frame ?? CGRect.zero &#125;&#125; 缩放实现1234567891011121314151617181920212223242526272829@objc func pinchView(_ pinchGestureRecognizer: UIPinchGestureRecognizer?) &#123; let view: UIView? = photoImageView if pinchGestureRecognizer?.state == .began || pinchGestureRecognizer?.state == .changed &#123; if rotationAngle == 0 &#123; //narrow if (pinchGestureRecognizer?.scale)! &lt;= CGFloat(1.0) &amp;&amp; ((photoImageView?.width)! &lt;= cropFrame.size.width || (photoImageView?.height)! &lt;= cropFrame.size.height) &#123; return &#125; &#125; //amplification if (pinchGestureRecognizer?.scale)! &gt; CGFloat(1.0) &amp;&amp; ((photoImageView?.width)! &gt; 5000 || (photoImageView?.height)! &gt; 5000) &#123; return &#125; view?.transform = (view?.transform.scaledBy(x: (pinchGestureRecognizer?.scale)!, y: (pinchGestureRecognizer?.scale)!))! pinchGestureRecognizer?.scale = 1 &#125; else if pinchGestureRecognizer?.state == .ended &#123; if rotationAngle == 0 &#123; var newFrame: CGRect? = photoImageView?.frame //newFrame = handleScaleOverflow(newFrame ?? CGRect.zero) newFrame = handleBorderOverflow(newFrame ?? CGRect.zero) UIView.animate(withDuration: TimeInterval(BOUNDCE_DURATION), animations: &#123; self.photoImageView?.frame = newFrame ?? CGRect.zero self.latestFrame = newFrame ?? CGRect.zero &#125;) &#125; else &#123; latestFrame = photoImageView?.frame ?? CGRect.zero &#125; &#125;&#125; 平移实现123456789101112131415161718192021@objc func panView(_ panGestureRecognizer: UIPanGestureRecognizer?)&#123; let view = panGestureRecognizer?.view; if (panGestureRecognizer?.state == .began || panGestureRecognizer?.state == .changed) &#123; let translation = panGestureRecognizer?.translation(in: view?.superview) view?.center = CGPoint(x: (view?.center.x)! + (translation?.x)!, y: (view?.center.y)! + (translation?.y)!) panGestureRecognizer?.setTranslation(CGPoint.zero, in: view?.superview) &#125; else if panGestureRecognizer?.state == .ended &#123; if rotationAngle == 0 &#123; //bounce to original frame var newFrame: CGRect? = photoImageView?.frame newFrame = handleBorderOverflow(newFrame ?? CGRect.zero) UIView.animate(withDuration: TimeInterval(BOUNDCE_DURATION), animations: &#123; self.photoImageView?.frame = newFrame ?? CGRect.zero self.latestFrame = newFrame ?? CGRect.zero &#125;) &#125; else &#123; latestFrame = photoImageView?.frame ?? CGRect.zero &#125; &#125;&#125; 最终效果","categories":[{"name":"iOS","slug":"iOS","permalink":"https://tangyanqiong.com/categories/iOS/"},{"name":"Swift","slug":"iOS/Swift","permalink":"https://tangyanqiong.com/categories/iOS/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://tangyanqiong.com/tags/Swift/"},{"name":"手势控制","slug":"手势控制","permalink":"https://tangyanqiong.com/tags/手势控制/"}]},{"title":"iPad控制多屏电视","slug":"ipad控制多屏","date":"2019-05-30T07:46:42.000Z","updated":"2019-07-26T09:48:49.382Z","comments":true,"path":"post/a503d77d.html","link":"","permalink":"https://tangyanqiong.com/post/a503d77d.html","excerpt":"前言背景我们公司有4个电视（内置机顶盒），用来展示公司的业务，平时经常会有客户来参观，电视下面是通过HDMI线连接的电脑，展示的实际是网页。 需求昨天下午领导提一个需求，因为演示的时候，需要操作，就得用电脑的鼠标在电视上点，屏幕太大鼠标又在电视下方，很不方便，不好操作，然后想借鉴别人公司，直接用iPad里控制4个电视来操作。","text":"前言背景我们公司有4个电视（内置机顶盒），用来展示公司的业务，平时经常会有客户来参观，电视下面是通过HDMI线连接的电脑，展示的实际是网页。 需求昨天下午领导提一个需求，因为演示的时候，需要操作，就得用电脑的鼠标在电视上点，屏幕太大鼠标又在电视下方，很不方便，不好操作，然后想借鉴别人公司，直接用iPad里控制4个电视来操作。 实现讨论用iPad来控制电视屏幕，是不是一听就很高大？ 哈哈，怎么控制？都不是一个系统，一个是windows系统，一个是iOS系统。讨论时，我提出了两个方案： 做个APP，把网页内嵌到里面，直接用自带的AirPlay把iPad投屏到电视，不用的电视，再切换投屏，这样在iPad上操作就会同步到电视。 因为展示的业务是web页，那么就用APP，在同一局域网给Web端发指令，或通过后台中转指令，以控制在电视上展示的网页。 调研1. 投屏方案这个方案，实际是时间成本最少的，说干就干，然后马上我这边就起了一个项目，嵌了一个网页在APP里，好吧，正式开始投屏，然后… 结果： 投屏是成功了的，但是呢，因为电视的屏幕比是16:9，而iPad是4:3，导致了在电视上，iPad的投屏屏幕显示不全，两边还有间隙，不是全屏，而且当初web端开发的网页尺寸也是固定的1920x1080，也就是为电视量身定做的，这个网页在iPad上也不能全屏显示。 这种硬件上及网页端的限制，不好改变，就放弃了这种方式。 2. 指令控制方案这个方案，需要和web端约定很多指令，基本指令像点击不同按钮的不同指令，而且比如上下滑动网页的距离，由于屏幕分辨率不一样，需要经过一定转换，才能是web端的对应距离等等问题。 结果： 诚如上面所说，这个开发成本会很大，而且有局限性，一旦网页内容改变，APP端需改动代码升级才能使用，这种做法不符合产品经理的预期，所以直接淘汰了。 另辟蹊径上面的两个方案告吹后，给产品经理说了结果，然后产品经理在网上找到了另一种方案，就是市面上这种类似TeamViewer的远程操控桌面软件，直接在iPad上安装软件，然后在PC上安装同样软件，使用iPad操控PC桌面。 两种方案有了这个方案，就在网上找到了向日葵、Splashtop，这两个软件支持多端连接。 1. 向日葵安装和使用都比较简单，APP风格符合中国人的操作习惯，每次连接PC端都需要输入验证码（PC端的向日葵软件上），这样的话，每次切换连接不同电脑比较慢，操作体验不好。 2. Splashtop同样的，安装和使用都比较简单，是国外软件，风格偏欧美风，我其实比较喜欢这种操作方式，简单易懂，连接同一个电脑，连续输入两次验证码，下次再点击接该电脑就直接连接了。 对比这两个软件，Splashtop切换不同电脑连接要更快些，而且不用每次都输验证码，相对方便些，所以就给产品经理推荐了这个软件来操作。 最终实施哈哈，以为这就OK了吗，NO，今天来公司，产品经理说昨晚给CEO看了，CEO觉得这样切换还是太慢，给了个建议，让4个电视通过HDMI方式连到一个电脑上，这样的话就用iPad操控一台电脑就可以了，不存在切换慢的问题了，仔细想了下，这种方案还真不错，有可行性，然后开撸，将4台电视连接到了一台电脑上（专门有HDMI拓展外接，所以接口足够），然后分屏显示。 1. Splashtop连接其实我真的是蛮喜欢Splashtop的，操作简单，可惜的是Splashtop只支持双屏显示，切换分屏始终只显示第1第2分屏。 2. 向日葵连接换了向日葵来连接，满怀期望的希望它支持多屏，结果不负众望，4台分屏完美切换，速度流畅，好，就用它了。 总结总的来说，这次需求完成还是比较满意的，上面领导也满意这个结果，这次分享希望能给需要iPad控制多屏电视的人带来帮助，有什么问题请在评论区告诉我吧。","categories":[{"name":"Others","slug":"Others","permalink":"https://tangyanqiong.com/categories/Others/"}],"tags":[{"name":"iPad控制多屏","slug":"iPad控制多屏","permalink":"https://tangyanqiong.com/tags/iPad控制多屏/"},{"name":"远程桌面控制","slug":"远程桌面控制","permalink":"https://tangyanqiong.com/tags/远程桌面控制/"},{"name":"向日葵","slug":"向日葵","permalink":"https://tangyanqiong.com/tags/向日葵/"},{"name":"Splashtop","slug":"Splashtop","permalink":"https://tangyanqiong.com/tags/Splashtop/"}]},{"title":"Vue框架底层原理","slug":"vue-use","date":"2019-03-20T09:58:17.000Z","updated":"2019-07-26T09:44:56.004Z","comments":true,"path":"post/d32be447.html","link":"","permalink":"https://tangyanqiong.com/post/d32be447.html","excerpt":"前言Vue框架是什么，怎么用，相信大家都已经很熟悉了，诚如Vue教程所说，它是一套构建用户界面的渐进式Web前端框架。 但是很多人就是拿来主义，就只管用，博主也是这类人 = =!, 但是随着深入使用Vue，越发觉得深知其原理的重要性，那么，本文来探讨一下Vue的底层原理到底是什么，是怎么实现的。","text":"前言Vue框架是什么，怎么用，相信大家都已经很熟悉了，诚如Vue教程所说，它是一套构建用户界面的渐进式Web前端框架。 但是很多人就是拿来主义，就只管用，博主也是这类人 = =!, 但是随着深入使用Vue，越发觉得深知其原理的重要性，那么，本文来探讨一下Vue的底层原理到底是什么，是怎么实现的。 目录概括Vue的底层原理总体来说就是深入响应式原理，它最独特的特性之一就是非侵入性的响应式系统。数据模型仅仅是普通的 JavaScript 对象。而当你修改它们时，视图会进行更新，这使得状态管理非常简单直接。 详解双向绑定下面是一段代码，较直观的体现了Vue特点，如下： 1234567891011121314151617181920212223&lt;div id=&quot;mvvm-app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;word&quot;&gt; &lt;p&gt;&#123;&#123;word&#125;&#125;&lt;/p&gt; &lt;button v-on:click=&quot;sayHi&quot;&gt;change model&lt;/button&gt; //点击这个button，word的值会发生改变&lt;/div&gt;&lt;script src=&quot;./js/observer.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./js/watcher.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./js/compile.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./js/mvvm.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var vm = new MVVM(&#123; el: &apos;#mvvm-app&apos;, data: &#123; word: &apos;Hello World!&apos; &#125;, methods: &#123; sayHi: function() &#123; this.word = &apos;Hi, everybody!&apos;; &#125; &#125; &#125;);&lt;/script&gt; 实现效果如下： 而Vue实现数据双向绑定的效果，需要三大模块： Observer：对数据对象的所有属性进行监听，如有变动可拿到最新值并通知观察者 Compile：对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数 Watcher：作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图 ObserverObserver的核心是通过Obeject.defineProperty()来监听数据的变动，这个函数内部可以定义setter和getter，每当数据发生变化，就会触发setter。这时候Observer就要通知订阅者，订阅者就是Watcher。 WatcherWatcher订阅者作为Observer和Compile之间通信的桥梁，主要做的事情是： 在自身实例化时往属性订阅器(dep)里面添加自己 自身必须有一个update()方法 待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调 CompileCompile主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图。 总结MVVM 是Model-View-ViewModel 的缩写，它是一种基于前端开发的架构模式，其核心是提供对View 和 ViewModel 的双向数据绑定，这使得ViewModel 的状态改变可以自动传递给 View，即所谓的数据双向绑定。 而Vue框架则是一个提供了 MVVM 风格的双向数据绑定的 Javascript 库，专注于View 层。它的核心是 MVVM 中的 VM，也就是 ViewModel。 ViewModel负责连接 View 和 Model，保证视图和数据的一致性，这种轻量级的架构让前端开发更加高效、便捷。","categories":[{"name":"Web","slug":"Web","permalink":"https://tangyanqiong.com/categories/Web/"},{"name":"Vue","slug":"Web/Vue","permalink":"https://tangyanqiong.com/categories/Web/Vue/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://tangyanqiong.com/tags/JavaScript/"},{"name":"Vue","slug":"Vue","permalink":"https://tangyanqiong.com/tags/Vue/"},{"name":"MVVM","slug":"MVVM","permalink":"https://tangyanqiong.com/tags/MVVM/"}]},{"title":"初探JavaScript的变量","slug":"js-var","date":"2019-02-25T08:12:34.000Z","updated":"2019-07-26T09:43:36.296Z","comments":true,"path":"post/6e5ac6c0.html","link":"","permalink":"https://tangyanqiong.com/post/6e5ac6c0.html","excerpt":"基本类型和引用类型的值ECMAScript变量一般有两种数据类型的值：基本类型和引用类型。 基本类型： 简单的数据段：Undefined, Null, Boolean, Number, String 引用类型：多个值构成的对象；","text":"基本类型和引用类型的值ECMAScript变量一般有两种数据类型的值：基本类型和引用类型。 基本类型： 简单的数据段：Undefined, Null, Boolean, Number, String 引用类型：多个值构成的对象； 1. 动态的属性定义两者的值：创建一个变量并为其变量赋值； 执行两者的值： 引用类型：可以添加、删除属性和方法； 基本类型：不能添加、删除属性和方法； 比如：引用类型 a，可以添加属性 name age1234var a = new Object();a.name = \"杨子龙\";a.age = 24;console.log(a.name); //杨子龙 基本类型 name 无法添加属性 age123var name = \"杨子龙\";name.age = 24;console.log(name.age); //undefined 代码中可知：只能给引用类型值动态地添加属性，以便将来使用。 2. 赋值变量值从一个变量向另一个变量复制基本类型值和引用类型值时： 基本类型：在变量对象上创建一个新值，并将其值复制给新变量分配的位置上；（完全独立的两个变量）例如： 123var a = 111;var b = a;console.log(b); //111 代码中可知：变量b的值只是变量a的值的一个副本，两者的值111是完全独立的。 引用类型：将存储在变量对象中的值复制一份放到为新变量分配的空间中；（引用同一个对象的两个变量） 引用类型的值的副本实际是一个指针，指向存储在堆中的一个对象。例如：1234var obj1 = new Object;var obj2 = obj1;obj1.name = \"杨子龙\";console.log(obj2,name); // Object &#123; name=\"杨子龙\"&#125; 杨子龙 代码中可知：obj1和obj2都指向同一个对象Object；所以，为obj1添加的name属性，通过obj2也可以访问的到。 3. 传递参数我们都知道基本类型是按值访问的，因为可以访问保存在变量中的实际的值。所有函数的参数都是按值传递的。 基本类型：基本类型值的传递如同基本类型变量的复制一样；在向参数传递值，被传递的值会被复制给一个局部变量（命名参数），因此这个局部变量的变化不会反映在函数的外部。 例如： 12345678function fn(num) &#123; num += 10; return num;&#125;var a = 10;var result = fn(a);console.log(result); //20console.log(a); //10 代码中可知：参数num和变量a互不相识，只是有着相同的值而已，用完之后，你还是你，我还是我，互不干政。 引用类型：引用类型的传递如同引用类型变量的复制一样；在向参数传递值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。 例如：123456function fn(obj) &#123; obj.name = '杨子龙';&#125;var person = new Object();fn(person);console.log(person.name); //杨子龙 代码中可知：在这个函数内部，参数obj和变量person引用的是同一个对象Object，所以，你不动我也不动，你动我也动，你中有我，我中有你，情义绵绵，经久不息…… 也就是说：即使变量person是按值传递的，但是参数obj（想象成局部变量）还是会按引用来访问同一个对象。 访问变量有按值和按引用两种方式，参数只能按值传递。 4. 检测类型 基本类型：typeof 引用类型：instanceof（对象或null） 例如： 1234567891011121314151617var a = 'Yang Zilong';var b = 24;var c = '';var d = true;var e;var g = undefined;var f = null; // 比较特殊var h = new Object();console.log(typeof a); //stringconsole.log(typeof b); //number console.log(typeof c); //stringconsole.log(typeof d); //booleanconsole.log(typeof e); //undefinedconsole.log(typeof g); //undefinedconsole.log(typeof f); //objectconsole.log(typeof h); //object 所用引用类型的值都是Object的实例。 如下：12345678var person = new Object();var num = [1,2, 3];var pattern = /.at/i;console.log(person instanceof Object); //trueconsole.log(num instanceof Object); //trueconsole.log(num instanceof Array); //trueconsole.log(pattern instanceof Object); //trueconsole.log(pattern instanceof RegExp); //true 使用instanceof检测基本类型，会返回false，基本类型不是对象。 参考资料：《JavaScript高级程序设计》（第三版）第四章 同步于： 掘金、慕课网","categories":[{"name":"Web","slug":"Web","permalink":"https://tangyanqiong.com/categories/Web/"},{"name":"JS","slug":"Web/JS","permalink":"https://tangyanqiong.com/categories/Web/JS/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://tangyanqiong.com/tags/JavaScript/"}]},{"title":"Swift中UILabel设置角标","slug":"Swift设置角标","date":"2018-12-20T07:10:08.000Z","updated":"2019-06-06T01:48:00.876Z","comments":true,"path":"post/f0789496.html","link":"","permalink":"https://tangyanqiong.com/post/f0789496.html","excerpt":"项目开发中，我们往往会遇到客户提出设置角标的需求，如下图： 这种是怎么实现的呢？","text":"项目开发中，我们往往会遇到客户提出设置角标的需求，如下图： 这种是怎么实现的呢？ 其实也很简单，我们用富文本就能实现这种方式。 12345678let text = (textLabel.text)!let attrText = NSMutableAttributedString(string: text)var: scaleRange = (text as NSString).range(of: &quot;r&quot;)attrText.addAttribute(NSAttributedString.Key.font, value: UIFont.systemFont(ofSize: textLabel.font.pointSize*0.8), range: scaleRange) //设置角标的字体大小 attrText.addAttribute(NSAttributedString.Key.foregroundColor, value: textLabel.textColor, range: scaleRange) //设置角标的字体颜色textLabel.attributedText = attrText 那-1在右上角的这种方式又是怎么实现的呢？ 如下： 12scaleRange = (text as NSString).range(of: &quot;-1&quot;)attrText.addAttribute(NSAttributedString.Key.baselineOffset, value: (textLabel.font.pointSize*0.4), range: scaleRange) 同理，在OC里，同样用富文本也可实现角标显示。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://tangyanqiong.com/categories/iOS/"},{"name":"Swift","slug":"iOS/Swift","permalink":"https://tangyanqiong.com/categories/iOS/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://tangyanqiong.com/tags/Swift/"},{"name":"角标","slug":"角标","permalink":"https://tangyanqiong.com/tags/角标/"}]},{"title":"Git使用命令行管理","slug":"Git-常用命令练习","date":"2018-12-14T14:45:16.000Z","updated":"2019-07-26T09:48:25.243Z","comments":true,"path":"post/c0119d4f.html","link":"","permalink":"https://tangyanqiong.com/post/c0119d4f.html","excerpt":"前言平时项目中很常用的代码管理工具就是git了，其实有很好的类似SourceTree这样的工具来管理git，但是本文所讲的是通过终端命令行来管理git。 原理 Workspace: 工作区 Index / Stage: 暂存区 Repository: 仓库区（或本地仓库） Remote: 远程仓库","text":"前言平时项目中很常用的代码管理工具就是git了，其实有很好的类似SourceTree这样的工具来管理git，但是本文所讲的是通过终端命令行来管理git。 原理 Workspace: 工作区 Index / Stage: 暂存区 Repository: 仓库区（或本地仓库） Remote: 远程仓库 管理新建12345678# 在当前目录 git-command 下新建 Git 代码库，（会生成 .git 文件）git init# 新建目录 git-command 并将其初始化为 Git 代码库git init git-command# 从线上获取一个完整的项目代码git clone https://github.com/yangtao2o/git-command.git 配置Git的设置文件为 .gitconfig ，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 12345678# 显示配置信息git config --list# 修改git config --globalgit config --global user.name \"yangtao\"git config --global user.email \"xxx@.qq.com\" 增加、删除文件123456789101112131415161718192021# 添加指定文件到暂存区git add index.html# 添加指定目录到暂存区，包括子目录git add assets# 添加当前目录的所有文件到暂存区git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交git add -p# 删除工作区文件，并将这次删除加入暂存区git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区git rm --cached [file]# 修改文件名，并放入暂存区git mv index.html index-new.html 代码提交123456789101112131415161718# 暂存区提交到仓库区 ( -m (msg) )git commit -m \"My first commit\"# 指定文件提交git commit [file1] [file2] ... -m [message]# 提交工作区自上次 commit 之后的变化，直接到仓库区git commit -a# 提交时显示所有的 diff 信息git commit -v# 使用一次新的 commit ，提交上一次提交# 如果代码没有任何变化，则用来改写上一次 commit 的提交信息git commit --amend -m \"new commit\"# 重做上一次 commit ，并包括指定文件的新变化git commit --amend [file1] [file2] ... 分支123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有的本地分支git branch# 列出所有的远程分支 ( -r (remotes))git branch -r# 列出所有的本地分支和远程分支git branch -a# 新建一个分支，但依然停留在当前分支git branch primary# 新建，并切换至 该分支git checkout -b primary-yt# 新建，指向指定 commitgit branch [branch] [commitID]# 新建，与指定的远程分支建立追踪关系git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区git checkout [branch-name]# 切换到上一个分支git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间git branch --set-upstream [branch] [remote-branch]# 合并指定分支 master-yt 到当前分支 mastergit merge master-yt# 选择一个\b commit，合并进当前分支git cherry-pick [commitid]# 删除分支git branch -d master-ytt# 删除远程分支git push origin --delete [branch-name]git branch -dr [remote/branch] 标签12# 列出标签git tag 查看信息12345# 显示有变更的文件git status# 显示当前分支的版本历史git log 参考目录 Git常用命令 Git教程 - 廖雪峰的官方网站","categories":[{"name":"Others","slug":"Others","permalink":"https://tangyanqiong.com/categories/Others/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://tangyanqiong.com/tags/Git/"},{"name":"代码管理工具","slug":"代码管理工具","permalink":"https://tangyanqiong.com/tags/代码管理工具/"}]},{"title":"iOS纯播放器（适配器）","slug":"iOS播放器适配器","date":"2018-12-06T02:45:35.000Z","updated":"2019-07-26T08:18:34.541Z","comments":true,"path":"post/4d0d70a6.html","link":"","permalink":"https://tangyanqiong.com/post/4d0d70a6.html","excerpt":"前言背景以前写过一套播放器，详见iOS流媒体播放器，结合了UI与播放层，集成使用很方便，但是呢，定制性很强，想要修改UI层或新增另外的功能，比较不好拓展，还因为公司播放类的项目很多，也为了能适用到其他项目，不同项目不同UI层或者有些定制化的需求，所以我将UI与播放层进行了拆分，使播放器变得更纯粹。 诞生由此，一个纯播放层播放器TDPlayerLite应运而生，哈哈，该播放器采取适配器模式，有基于AVPlayer封装的，也可集成其他播放器，例DRM播放器，或者音乐播放器，都可以，这样对在项目中不同地方使用不同播放器提供很大便利。","text":"前言背景以前写过一套播放器，详见iOS流媒体播放器，结合了UI与播放层，集成使用很方便，但是呢，定制性很强，想要修改UI层或新增另外的功能，比较不好拓展，还因为公司播放类的项目很多，也为了能适用到其他项目，不同项目不同UI层或者有些定制化的需求，所以我将UI与播放层进行了拆分，使播放器变得更纯粹。 诞生由此，一个纯播放层播放器TDPlayerLite应运而生，哈哈，该播放器采取适配器模式，有基于AVPlayer封装的，也可集成其他播放器，例DRM播放器，或者音乐播放器，都可以，这样对在项目中不同地方使用不同播放器提供很大便利。 集成与使用实现模式TDPlayerLite采用适配器模式，所有对外的方法和代理都放在BasePlayer类，需要集成某播放器时，以集成系统播放器AVPlayer为例，继承BasePlayer类生成ReAVPlayer类，在ReAVPlayer类里实现AVPlayer的装载，也实现BasePlayer类对外暴露的方法。 优点：这种模式能够快速集成不同播放器到项目中，且不会影响到原项目。 导入Demo里PlayerAdapter直接拖往工程里，就可直接使用。 目录PlayerManager12345678910/** 播放器类型，目前有系统播放器及DRM播放器 */typedef enum _PlayerManagerType&#123; PlayerManagerTypeNone = 0, PlayerManagerTypeAVPlayer = 1, PlayerManagerTypeVisualOnPlayer = 2 //DRM //还可添加其他类型的播放器&#125; PlayerManagerType; 使用PlayerManager类可传入不同类型生成对应播放器： 1self.player = [[PlayerManager manager] getPlayerBy:self.playerView andPlayerType:PlayerManagerTypeVisualOnPlayer]; 若不传入Type，默认生成AVPlayer播放器 BasePlayer它是播放器基类，其实BasePlayer.h里注释已经写得很全面了，每个属性和方法的使用和用途都有注释，这里不赘述了。 说下BasePlayer这个类的作用，写这个类的目录是为了把与外部交互数据统一化，且把播放器产生的数据全面的归整统一对外提供，后面集成进来的播放器，都继承这个基类，实现其方法。 例如： 此自定义的播放器状态基本概括了全部状态，对用户特别友好，能够在不同状态提示用户，提升了用户体验。 BTW：系统播放器AVPlayer经常就有乱调、部分视频状态没有的情况，所以我在ReAVPlayer做了兼容性处理，当你需要集成其他播放器时，也需要做相关处理，保证最外层使用的Player的使用完整性。 BasePlayer_Methods扩展类，可加入BasePlayer的扩展接口或属性。 ReAVPlayer该类继承于BasePlayer，里面装载了系统播放器AVPlayer，使用该类实际就是使用系统播放器，AVPlayer一些兼容性处理也放在了里面。 总结这个播放器我们已经应用到了很多项目中，也已经上线测试了很多版本，已经是很稳定的版本了，不用担心在使用中会出现什么奇怪难解的问题了。 另，目前TDPlayerLite相当于是一个播放器的适配器，如果你只是单纯的想用一个稳定友好的系统播放器，可直接导入Players文件夹使用。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://tangyanqiong.com/categories/iOS/"},{"name":"OC","slug":"iOS/OC","permalink":"https://tangyanqiong.com/categories/iOS/OC/"}],"tags":[{"name":"Object-C","slug":"Object-C","permalink":"https://tangyanqiong.com/tags/Object-C/"},{"name":"AVPlayer","slug":"AVPlayer","permalink":"https://tangyanqiong.com/tags/AVPlayer/"},{"name":"DRMPlayer","slug":"DRMPlayer","permalink":"https://tangyanqiong.com/tags/DRMPlayer/"},{"name":"适配器","slug":"适配器","permalink":"https://tangyanqiong.com/tags/适配器/"}]},{"title":"学习JavaScript深入系列简要总结","slug":"学习JavaScript深入系列简要总结","date":"2018-10-31T15:07:42.000Z","updated":"2019-07-26T09:41:49.806Z","comments":true,"path":"post/6ec5e01.html","link":"","permalink":"https://tangyanqiong.com/post/6ec5e01.html","excerpt":"从原型到原型链原文地址：JavaScript深入之从原型到原型链 每一个函数都有一个prototype属性，该属性指向了一个对象，此对象为调用该函数而创建的实例的原型","text":"从原型到原型链原文地址：JavaScript深入之从原型到原型链 每一个函数都有一个prototype属性，该属性指向了一个对象，此对象为调用该函数而创建的实例的原型 每一个对象（除null）都具有一个属性：__proto__，这个属性指向该对象的原型 每个原型都有一个constructor属性指向关联的构造函数 原型对象是通过 Object 构造函数生成的，最后Object.prototype.__proto__ = null 词法作用域和动态作用域原文链接：JavaScript深入之词法作用域和动态作用域 javascript采用的是词法作用域(lexical scoping)，函数的作用域是在函数定义的时候就决定了，而不是调用的时候才决定 词法作用域，即静态作用域，函数的作用域在函数定义的时候就决定了 动态作用域，函数的作用域是在函数调用的时候才决定 执行上下文栈当执行一个函数的时候，就会创建一个执行上下文(execution context)，并且压入执行上下文栈(Execution context stack, ESC) 当函数执行完毕的时候，会将函数的执行上下文栈中弹出 变量对象1、全局上下文的变量对象初始化：全局对象 2、函数上下文的变量对象初始化：只包括Arguments对象 3、进入执行上下文时：给变量对象添加形参、函数声明、变量声明等初始的属性值 4、代码执行阶段：再次修改变量对象的属性值 总结：未进入执行阶段之前，变量对象(VO)中的属性都不能访问！但是进入执行阶段之后，变量对象(VO)转变为了活动对象(AO)，里面的属性都能被访问了，然后开始进行执行阶段的操作。它们其实都是同一个对象，只是处于执行上下文的不同生命周期。 最后，函数是“第一等公民”，记住这个，变量名称和函数名称相同的声明，优先执行函数声明 作用域从ECMAScript规范解读this执行上下文闭包闭包是指那些能够访问自由变量的函数。 自由变量是指在函数中使用的，但既不是参数也不是函数的局部变量的变量。 那么，闭包 = 函数 + 函数能够访问的自由变量。 参数按值传递ECMAScript中所有函数的参数都是按值传递的。 即，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制给另一个变量一样。 参数如果是基本类型是按值传递，如果是引用类型按共享传递。 共享传递是指，在传递对象的时候，传递对象的引用的副本。 call和apply的模拟实现call()在使用一个指定的this值和若干个指定的参数值的前提下，调用某个函数或方法。 12345678910111213Function.prototype.mycall = function(context) &#123; var context = context || window; //获取调用call的函数，用this可以获取 context.fn = this; var args = []; for (var i = 1, l = arguments.length; i &lt; l; i++) &#123; args.push('arguments[' + i + ']'); &#125; // 把传给call的参数传递给了context.fn函数 var result = eval('context.fn(' + args + ')'); delete context.fn; return result;&#125; apply()同call()，只不过将多个参数值，以数组的形式传入而已。 12345678910111213141516Function.prototype.myapply = function(context, arr) &#123; var context = Object(context) || window; context.fn = this; var result; if (!arr) &#123; result = context.fn(); &#125; else &#123; var args = []; for (var index = 0; index &lt; arr.length; index++) &#123; args.push('arr[' + index + ']'); &#125; result = eval('context.fn(' + args + ')'); &#125; delete context.fn; return result;&#125; bind的模拟实现bind()方法会创建一个新函数。当这个新函数被调用，bind()第一个参数将作为它运行时的this，之后的一系列参数将会在传递的实参前传入，作为它的参数。 new的模拟实现new运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象类型之一。","categories":[{"name":"Web","slug":"Web","permalink":"https://tangyanqiong.com/categories/Web/"},{"name":"JS","slug":"Web/JS","permalink":"https://tangyanqiong.com/categories/Web/JS/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://tangyanqiong.com/tags/JavaScript/"}]},{"title":"【转】高效学习JavaScript的六个思维技巧","slug":"js-learn","date":"2018-10-22T14:11:53.000Z","updated":"2019-07-26T09:42:39.319Z","comments":true,"path":"post/f78e3d89.html","link":"","permalink":"https://tangyanqiong.com/post/f78e3d89.html","excerpt":"初始整理于慕课网手记高效学习JavaScript的六个思维技巧","text":"初始整理于慕课网手记高效学习JavaScript的六个思维技巧 更快学习JavaScript的六个思维技巧 当人们试图学习JavaScript或其他编程语言的时候，他们通常会遇到如下挑战。 1234567891. 一些概念让他们感到困惑，特别是如果之前学过其他类型的语言。2. 很难找到学习的时间（或者动力）去学习。3. 你很容易忘掉之前学到的东西。4. JavaScript工具太多并且经常更新，以至于很难找到学习的切入点。5. ... 幸运的是，这些难题最终能够被克服。在这篇文章，我将展示六个能够帮助你更快、更开心、更高效地学习JavaScript的六个思维技巧。 1、不要让对未来的忧虑干扰你现在的学习 有些JavaScript初学者会问刚开始要学习哪种框架，但是如果你还没能熟练使用原生JavaScript，你就不应该问这种问题。因为你会花很多时间研究各种框架而得不到进步。 走出这个陷阱的一个方法是制定一个学习路径图。例如，要成为前端开发，你的路径图可能是下图。在将来你能够使用HTML和CSS制作动态页面。 2、不要让自信骗你进入持续遗忘的陷阱快速理解一个概念会是JavaScript进步的最大阻碍，下面我将解释。 当你遇到一个知识点，而你好像理解了，你很可能抑制不住内心跳到下一个知识点的冲动。 现实可能是你会理解下一个知识点然后继续跳到下一个知识点。 但是，很快你会到达一个节点，在这个节点你发现自己已经忘了前面所学，于是你需要回过头复习，你快速瞟了一下之前所学然后又继续学习新的知识。 但是现在，你忘记了其他东西。 你一直重复这种继续-回顾-继续-回顾模式直到你发现自己完全迷失。 你开始沮丧，想要休息，然后当你开始重振旗鼓，却发现自己已经忘掉所有。 幸运的是，我们有两个应对上述问题的方法： 一次只学一样东西； 做练习——实际就是敲代码； 当你学习一个新的概念，你要将它实践出来，练习它，与它和善相处，甚至能够将它与其他概念联系到一起。 当你学习一个示例，最重要的是你要自己将代码敲出来，这样能帮助你吸收它。另外，一次只学一个东西能够帮助你巩固所学，因为记忆更少的东西更容易。 这个过程看起来貌似比阅读然后快速跳到下一个知识点要花费更长的时间，但是实际上它所花的时间更少，因为这样你就不需要频繁复习之前所学。我在好几个场合后才艰难的领悟到这个道理。 3、使用正确的思维方式练习很多人认为敲代码是烦人的重复性工作，所以他们通常会跳过这个步骤试着寻找捷径。如果你试图为JavaScript练习寻找捷径，你将会为此花费更多的时间。 但是我们如何才能使得敲代码更加的有趣，使得我们愿意去敲代码呢？ 试着改变为下面的思维模式： 如果你刚学了一个JavaScript概念，然而你被告知不能使用它，对此你感觉如何？个人来说我会感到有点恼火，特别是为了弄懂它我花费了宝贵的时间。这就像是一个小孩得到了一个新的玩具，但却被限制不能玩它。 当你学习JavaScript的新知识，试着将这个知识点视作一个新玩具，例如新车、一双新鞋、或任何你觉得值得有趣的东西。然后，不要把敲代码当成工作，将敲代码视作你正在玩游戏。你正在使用刚学的技能做一些很酷的事情。给自己惊喜，把成果展示给你的朋友。 带着游戏的思维模式你将学得更快，将记忆的更牢，同时你将体会到更多乐趣。 4、使用Facebook技巧为编程腾时间 人们遇到的一个普遍问题是，他们通常找不到时间去敲代码。通常，这些人会花好几个小时浏览例如Facebook、YouTube、Wikipedia或者Reddit这样的网站。无论你是否符合上述描述，我们都能从中学到一些东西。 我当然有时间只浏览Facebook一会儿，但通常我会在上面待好几个小时浏览往返。这是如何发生的？我认为原因在于，刚开始我并没打算花在这上面花费那么多时间。开始行动是做一件事情最困难的部分，所以将目标设定的足够小能够帮助我们进入状态。如果有人问我是不是打算花几个小时浏览Facebook，我会回答不，因为我没有时间。然而，对于仅仅尝试一下我是能够接受的，这也是我能够沉浸其中的方法。 好消息是，你能够对敲代码运用同样的心理技巧。 不要计划花几个小时敲代码，因为你会发现自己没有时间。 相反的，告诉自己只敲三分钟代码。这样你就不需要为寻找敲代码的时间烦心。 5、思考的更慢你将学得更快 这一条听起来违反直觉，所以下面我将用一个故事来解释。 我的一个朋友又一次对JavaScript的一个特性感到困惑。我让他将他知道的解释给我听，然后告诉我哪儿让他困惑。当它向我解释代码，我发现他在跳步。 “等会儿！”我说道。“慢慢来，然后将这些一步步解释给我听。” 我的朋友直接将整个代码的功能总结给我听。 我再次让他暂停。“你还是在跳步。再解释一次，这次我需要你一步步将每一行代码发生了什么解释给我听。” 这一次，我的朋友能够更好的解释代码是如何运行的。关键在于他花时间去理解每一行代码而不是试图一下理解所有。 在上述这种案例中，思考的更慢实际上让你学得更快。 6、在写复杂代码前先用简单语言写下 如果你要写的代码是复杂并且不常见的，先用简单语言将代码写下。这样，你能够你能够在真正写之前知道自己要做什么。下面是使用这个方法的两个好处： 你将更容易更快速的写代码，因为你不需要时刻停下来思考自己将要怎么做。 由于你知道代码要干什么，能够更好的排除错误。 总结 我们已经讲了好几个更快速学习JavaScript的方法，但是你也能将上述方法运用于学习其他东西。下面是上述方法的概括： 1234567（1）、不要再想将要学什么，沉浸于现在；（2）、通过把新技能当做玩具使得练习更有趣；（3）、就像浏览Facebook、YouTube之类的网站一样，在敲代码前告诉自己只敲几分钟，这样你就拥有了敲代码的时间；（4）、慢下来，小步向前，你将学得更快。 本文转载自：众成翻译 译者：Ryan 链接：http://www.zcfy.cc/article/436","categories":[{"name":"Web","slug":"Web","permalink":"https://tangyanqiong.com/categories/Web/"},{"name":"JS","slug":"Web/JS","permalink":"https://tangyanqiong.com/categories/Web/JS/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://tangyanqiong.com/tags/JavaScript/"}]},{"title":"JS设计模式学习之单例模式","slug":"mode-单例模式","date":"2018-10-03T13:24:26.000Z","updated":"2019-07-26T09:44:33.675Z","comments":true,"path":"post/23158cb2.html","link":"","permalink":"https://tangyanqiong.com/post/23158cb2.html","excerpt":"什么是单例模式？ 保证一个类仅有一个实例，并提供一个访问它的全局访问点 用一个变量标志当前是否已经为某个类型创建过对象，如果是，则下次直接返回之前创建的对象。 1234567891011121314151617181920var Singleton = function (name) &#123; this.name = name; this.instance = null;&#125;Singleton.prototype.getName = function () &#123; console.log(this.name);&#125;Singleton.getInstance = function (name) &#123; if (!this.instance) &#123; this.instance = new Singleton(name); &#125; return this.instance;&#125;var a = Singleton.getInstance('Tony1');var b = Singleton.getInstance('Tony2');console.log(a === b); // true 通过 Singleton.getInstance来获取 Singleton 类的唯一对象，里边使用了 new 来获取，导致了这个类的“不透明性”。","text":"什么是单例模式？ 保证一个类仅有一个实例，并提供一个访问它的全局访问点 用一个变量标志当前是否已经为某个类型创建过对象，如果是，则下次直接返回之前创建的对象。 1234567891011121314151617181920var Singleton = function (name) &#123; this.name = name; this.instance = null;&#125;Singleton.prototype.getName = function () &#123; console.log(this.name);&#125;Singleton.getInstance = function (name) &#123; if (!this.instance) &#123; this.instance = new Singleton(name); &#125; return this.instance;&#125;var a = Singleton.getInstance('Tony1');var b = Singleton.getInstance('Tony2');console.log(a === b); // true 通过 Singleton.getInstance来获取 Singleton 类的唯一对象，里边使用了 new 来获取，导致了这个类的“不透明性”。 透明的单例模式创建一个“透明”的单例类，就是让我们从这个类中创建对象的时候可以和使用其他普通类一样：var aa = new CreateDiv(&#39;Sisi1&#39;); 1234567891011121314151617181920212223242526var CreateDiv = (function () &#123; var instance; var CreateDiv = function (html) &#123; if (instance) &#123; return instance; &#125; this.html = html; this.init(); return instance = this; &#125;; CreateDiv.prototype.init = function () &#123; var div = document.createElement('div'); div.innerHTML = this.html; document.body.appendChild(div); &#125;; return CreateDiv;&#125;)();var aa = new CreateDiv('Sisi1');var bb = new CreateDiv('Sisi2');console.log(aa === bb); // true 下面这段代码中，CreateDiv 的构造函数负责了两件事：创建对象和执行初始化 init 方法，及保证只有一个对象： 12345678var CreateDiv = function (html) &#123; if (instance) &#123; return instance; &#125; this.html = html; this.init(); return instance = this;&#125;; 但是，如果我们要创建很多的div，这里的 return instance = this; 就需要删掉。 用代理实现单例模式这时候，为了避免上面不能复用的尴尬，通过引入代理类的方式，把负责管理单例的逻辑移交至代理类ProxySingletonCreateDiv，这样CreateDiv只是一个普通的类。 12345678910111213141516171819202122232425var CreateDiv = function (html) &#123; this.html = html; this.init();&#125;;CreateDiv.prototype.init = function () &#123; var div = document.createElement('div'); div.innerHTML = this.html; document.body.appendChild(div);&#125;var ProxySingletonCreateDiv = (function () &#123; var instance; return function (html) &#123; if (!instance) &#123; instance = new CreateDiv(html); &#125; return instance; &#125;&#125;)();var aa = new ProxySingletonCreateDiv('Tony1');var bb = new ProxySingletonCreateDiv('Tony2');console.log(aa === bb); // true JavaScript 中的单例模式单例模式的核心是：确保只有一个实例，并提供全局访问。 使用命名空间 对象字面量的方式: 12345678910var namespace1 = &#123; a: function() &#123; console.log(1); &#125;, b: function() &#123; console.log(2); &#125;&#125;namespace1.a(); //1 把a和b都定义为 namespace1 的属性，减少了变量和全局作用域打交道的机会，还可以动态地创建命名空间： 1234567891011121314151617181920212223242526272829303132333435363738394041424344var MyApp = &#123;&#125;;MyApp.namespace = function (name) &#123; var parts = name.split('.'); var current = MyApp; for (var i in parts) &#123; if (!current[parts[i]]) &#123; current[parts[i]] = &#123;&#125;; &#125; current = current[parts[i]]; &#125;&#125;MyApp.namespace('event');MyApp.namespace('dom.style');console.log(MyApp);// 相当于：var MyApp = &#123; event: &#123;&#125;, dom: &#123; style: &#123;&#125; &#125;&#125;``` 2. 使用闭包封装私有变量使用下划线约定私有变量 _name 和 _age。```jsvar user = (function () &#123; var _name = 'Seven'; var _age = 27; return &#123; getUserInfo: function () &#123; return _name + '-' + _age; &#125; &#125;&#125;)();console.log(user.getUserInfo()) // Seven-27 惰性单例宗旨：在需要的时候才创建对象！！！ 栗子：QQ的登录浮窗 第一种方案：页面加载完成的时候便创建好浮窗。 1234567891011var loginLayer = (function () &#123; var div = document.createElement('div'); div.innerHTML = '我是一个小小的悬浮框'; div.style.display = 'none'; document.body.appendChild(div); return div;&#125;)();document.getElementById('loginBtn').addEventListener('click', function () &#123; loginLayer.style.display = 'block';&#125;); 但是，不管我们登录与否，都会创建悬浮窗，所以我们可以修改为：在点击登录的时候再创建悬浮窗。 123456789101112var createLoginLayer = function () &#123; var div = document.createElement('div'); div.innerHTML = '我是一个小小的悬浮框'; div.style.display = 'none'; document.body.appendChild(div); return div;&#125;;document.getElementById('loginBtn').addEventListener('click', function () &#123; var loginLayer = createLoginLayer(); loginLayer.style.display = 'block';&#125;); 这时候，虽然达到了惰性的目的，却失去了单例的效果，每次点击登录，都会创建一个新的悬浮窗。 所以我们需要一个变量来判断是否已经创建过悬浮窗： 1234567891011121314151617var createLoginLayer = (function () &#123; var div; return function () &#123; if (!div) &#123; // 判断是否已创建 div = document.createElement('div'); div.innerHTML = '我是一个小小的悬浮框'; div.style.display = 'none'; document.body.appendChild(div); &#125; return div; &#125;&#125;)();document.getElementById('loginBtn').addEventListener('click', function () &#123; var loginLayer = createLoginLayer(); loginLayer.style.display = 'block';&#125;); 通用的惰性单例虽然上面的悬浮框是一个可用的惰性单例，但是仍然违反了单一职责原则，如果我们要创建其他的标签，就需要把创建悬浮窗的函数复制一份，再修修改改，无法做到复用。 所以，我们需要把不变的部分隔离出来，进行抽象，无论创建什么标签，都是一样的逻辑： 1234var obj;if(!obj) &#123; obj = xxx;&#125; 接着，继续： 123456789101112131415161718192021var getSingle = function (fn) &#123; var result; return function () &#123; return result || (result = fn.apply(this, arguments)); &#125;&#125;var createLoginLayer = function () &#123; var div = document.createElement('div'); div.innerHTML = '我是一个小小的悬浮框'; div.style.display = 'none'; document.body.appendChild(div); return div;&#125;var createSingleLoginLayer = getSingle(createLoginLayer);document.getElementById('loginBtn').addEventListener('click', function () &#123; var loginLayer = createSingleLoginLayer(); loginLayer.style.display = 'block';&#125;); 这时，我们创建其他标签就只需要关系如何创建该标签就可以： 123456789101112var createIframe = function () &#123; var iframe = document.createElement('iframe'); iframe.src = 'https://baidu.com'; document.body.appendChild(iframe); return iframe;&#125;var createSingleIframe = getSingle(createIframe);document.getElementById('loginBtn2').addEventListener('click', function () &#123; createSingleIframe();&#125;); 总结单例模式是一种简单却非常常用的模式，特别是惰性单例技术，在合适的时候才创建对象，并且只创建唯一的一个。 创建对象和管理单例的职责被分布在两个不同的方法中，两个方法组合起来才具有单例模式的威力。","categories":[{"name":"Web","slug":"Web","permalink":"https://tangyanqiong.com/categories/Web/"},{"name":"JS","slug":"Web/JS","permalink":"https://tangyanqiong.com/categories/Web/JS/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://tangyanqiong.com/tags/JavaScript/"},{"name":"单例模式","slug":"单例模式","permalink":"https://tangyanqiong.com/tags/单例模式/"}]},{"title":"页面滑动时的动画插件WOW.js","slug":"wow","date":"2018-09-04T03:16:42.000Z","updated":"2019-07-26T09:53:02.100Z","comments":true,"path":"post/9ac2330d.html","link":"","permalink":"https://tangyanqiong.com/post/9ac2330d.html","excerpt":"当初次加载页面的时候，需要一些动画渐入，并且当滑动到当前内容时也会出现动画，之后就恢复正常，所以就用到了 WOW.js。 比如：RT-Thread 再比如设计师必备：sketchapp","text":"当初次加载页面的时候，需要一些动画渐入，并且当滑动到当前内容时也会出现动画，之后就恢复正常，所以就用到了 WOW.js。 比如：RT-Thread 再比如设计师必备：sketchapp WOW.js文档：WOW Animate.css模拟：Animate animate.css 包含了一组炫酷、有趣、跨浏览器的动画，可以在你的项目中直接使用。 CDN12&lt;link href=\"https://cdn.bootcss.com/animate.css/3.7.0/animate.min.css\" rel=\"stylesheet\"&gt;&lt;script src=\"https://cdn.bootcss.com/wow/1.1.2/wow.min.js\"&gt;&lt;/script&gt; 用法文档：Setup WOW.js 12345678```html&lt;div class=&quot;wow bounceInUp&quot; data-wow-duration=&quot;2s&quot; data-wow-delay=&quot;5s&quot;&gt; Content to Reveal Here&lt;/div&gt;&lt;script&gt; new WOW().init();&lt;/script&gt; ps：初始加载页面的时候，很有可能会出现内容再动画渲染，所以直接设置：`css.wow { visibility: hidden;}","categories":[{"name":"Web","slug":"Web","permalink":"https://tangyanqiong.com/categories/Web/"},{"name":"CSS","slug":"Web/CSS","permalink":"https://tangyanqiong.com/categories/Web/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://tangyanqiong.com/tags/CSS/"}]},{"title":"OC工程怎么转换为Swift工程","slug":"octoswift","date":"2018-08-24T09:42:27.000Z","updated":"2019-05-27T06:32:07.471Z","comments":true,"path":"post/dff23fd2.html","link":"","permalink":"https://tangyanqiong.com/post/dff23fd2.html","excerpt":"前言前段时间用Object-C正在开发一个项目，开发了差不多百分之七八十了，客户通知要求改成Swift语言开发（因为他只会Swift），好吧，一个项目用Swift来写其实也无可厚非，但是这个项目中途来换，可想而知是多么痛苦的事，已经写了好多个OC类。","text":"前言前段时间用Object-C正在开发一个项目，开发了差不多百分之七八十了，客户通知要求改成Swift语言开发（因为他只会Swift），好吧，一个项目用Swift来写其实也无可厚非，但是这个项目中途来换，可想而知是多么痛苦的事，已经写了好多个OC类。 步骤调研之前一开始也在网上找了很多资料，有OC与Swift对应功能的语法解说，也有贴代码用工具直接转的，用过iSwift，但不是很好用，识别率不高，正确率不高。 这些都感觉比较费时（客户只给了一周的时间），然后就在想，有没有一个是直接可以转工程的工具呢？别说，强大的google还真搜出来了，这个软件可以直接转换工程。 实施这个软件叫什么名呢，也不卖关子了，是一个在线转换的网站： OC2Swift 它是提供少量代码免费转换，大家可转换自己的部分代码看看正确性，还可以在线输出Swift代码结果，它可以单文件、文件夹或工程打包在线转换。 不过呢，好的软件都是收费的，具体资费我就不说了（避免托的嫌疑，有需要的上官网自己看吧），对于转换的成本来说这个价格很便宜了。 结果注意点 给大家一个建议，这个购买后使用有流量限制，建议打包的时候把静态库、framwork、SDK、第三方库等相关的剔除后打包上传，转换成功后再放置到对应路径下。 原OC代码留存（原因见下面）。 问题这个工程转换成功后，使用起来就没有一点问题了吗？ 错错错，当初我记得一开始报错不怎么多几十个吧，关键改完后，不断的重编译就暴露更多的错，这样下来估计也改了有几百个错了。 是什么类型的错误 很多都是语法的错误，而Xcode有提示修正的方法，直接鼠标点点点就改好了，比较轻松。 有些是语法不识别的问题，这个就需要自己查资料对应OC代码寻找对应的Swift代码了，所以要留存原OC代码。 有些工程设置的地方报错，但是这个很少，就几处，百度google就能解决。 最后然后，到了这一步，以为万事大吉了吗？哈哈，并没有，有些地方转换虽说没报错，但可能会转错意，需要整体流程跑下，最好找测试再过遍流程，切记。 PS：有些OC库实在没办法转的，就采取桥接的方式使用吧。 总结总体来说，这次的转换是很成功的，原本估时为一周，但是实际2～3天就完成了转换，比较高效率，所以建议大家转换Swift可采取这种方式。 比较遗憾的是，当时时间比较赶，没来得及截图留存给大家，如果觉得文章上有什么疑问，或者实际实践过程中遇到什么问题，欢迎大家在下方留言告诉我，我会第一时间回复你。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://tangyanqiong.com/categories/iOS/"},{"name":"Swift","slug":"iOS/Swift","permalink":"https://tangyanqiong.com/categories/iOS/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://tangyanqiong.com/tags/Swift/"},{"name":"Object-C","slug":"Object-C","permalink":"https://tangyanqiong.com/tags/Object-C/"}]},{"title":"iOS流媒体播放器","slug":"iOS流媒体播放器","date":"2018-08-05T03:02:20.000Z","updated":"2019-07-26T08:18:46.256Z","comments":true,"path":"post/70bc6a39.html","link":"","permalink":"https://tangyanqiong.com/post/70bc6a39.html","excerpt":"前言我写了一个iOS流媒体播放器Demo：TDPlayer，需要的朋友可下载，播放器底层播放这层本文就不做赘述了，本文主要针对TDPlayer（播放与UI）的分解使用讲解，Demo实际效果如下：","text":"前言我写了一个iOS流媒体播放器Demo：TDPlayer，需要的朋友可下载，播放器底层播放这层本文就不做赘述了，本文主要针对TDPlayer（播放与UI）的分解使用讲解，Demo实际效果如下： 集成与使用导入Demo里TDPlayer直接拖往工程里，就可直接使用。 目录TDPlayerConfigTDPlayerConfig.h配置文件，一些自定义配置可在里面设置。 TDPlayerView播放器View层，此层在Player上面，也在播放器UI层的最低层，作为中间层来执行UI层与Player数据交互，对外交互也应是此View来完成。 TDPlayerTopBar播放器Top层，可设置标题，有左右按钮交互事件等。 TDPlayerBottomBar播放器Bottom层，为用户与播放交互层，播放\\暂停，快进\\快退，音量调节，上\\下一页都在这层实现。 TDPlayerStatusView该View简单来所就是用户友好提示页，根据视频的状态来显示加载、正常、结束、失败、错误状态UI，还提供重新播放功能。 TDPlayerLoadingView视频加载过程中出现的加载View，以及还支持显示当前的加载网速。 使用其实对外的接口，我已经封装得比较简单易懂了，外部使用直接使用TDPlayerView这个类，如下：（Demo上还有代理回调的使用） 123456789101112tdPlayerView = [[TDPlayerView alloc] initWithFrame:CGRectMake(0, 0, selfWidth, selfHeight)];tdPlayerView.delegate = self;[self.view addSubview:tdPlayerView]; [tdPlayerView startLoadingWithTitleStr:@&quot;测试视频&quot;]; self.playUrl = @&quot;http://182.138.101.48:5001/nn_vod/nn_x64/aWQ9NWZlOTljZWYwY2Q0Mzk3ZGRlNjI1MDExMTE0OGFlNjMmdXJsX2MxPTZkNmY2OTc2NjU3MzJmMzA2MjYzMzQzODMzNjUzMDY1MzIzMTYzNjYzMTMzMzAzMzYyMzUzNzM3MzkzMjY1NjE2MTM0Mzg2NjY2NjQzMzJlNzQ3MzIwMDAmbm5fYWs9MDFkZTU0YTczNjYxOWZiODdlMzU1NjgxZjEzZGNhYzc4ZCZudHRsPTMmbnBpcHM9MTgyLjEzOC4xMDEuNDg6NTEwMSZuY21zaWQ9MTAwMDAxJm5ncz01NTFlMDQxYTAwMGI5NWYxNWVjZjc1NTg2MDYyMTZiOCZubl91c2VyX2lkPVlZSEQwMDAwMDc3OSZuZHY9MS4wLjAuMC4yLlNDLUpHUy1JUEhPTkUuMC4wX1JlbGVhc2UmbmVhPSZuZXM9/5fe99cef0cd4397dde6250111148ae63.ts&quot;; if ([self.playUrl rangeOfString:@&quot;.ts&quot;].location != NSNotFound) &#123; self.playUrl = [self.playUrl stringByReplacingOccurrencesOfString:@&quot;.ts&quot; withString:@&quot;.m3u8&quot;];&#125;[tdPlayerView playVideoByUrl:self.playUrl]; 值得注意的是：iOS播放器是不支持ts后缀地址播放的，替换成m3u8后缀即可，实际m3u8是一个索引文件，播放时，会根据索引去下载对应的ts分片进行播放。 总结优缺点TDPlayer将播放层及UI层统一进行了封装，如果你的需求仅仅是播放一个视频，对UI要求不高，这套使用起来还是很方便的。 但是，缺点是什么呢？耦合度太高，播放层与UI层粘性高，不利用扩展或修改。 推荐这里提供一个无UI的纯播放适配器TDPlayerLite，这个将AVPlayer一些回调乱调、状态不友好的问题内部解决了，并封装了一套用户友好的代理出来，很好集成与使用。 此纯播放器SDK，具体集成与使用详见：iOS纯播放器（适配器）","categories":[{"name":"iOS","slug":"iOS","permalink":"https://tangyanqiong.com/categories/iOS/"},{"name":"OC","slug":"iOS/OC","permalink":"https://tangyanqiong.com/categories/iOS/OC/"}],"tags":[{"name":"Object-C","slug":"Object-C","permalink":"https://tangyanqiong.com/tags/Object-C/"},{"name":"播放器","slug":"播放器","permalink":"https://tangyanqiong.com/tags/播放器/"}]},{"title":"JavaScript算法初级练习","slug":"js算法","date":"2018-08-01T07:43:10.000Z","updated":"2019-07-26T09:44:05.928Z","comments":true,"path":"post/f4b98ba6.html","link":"","permalink":"https://tangyanqiong.com/post/f4b98ba6.html","excerpt":"# 需要定义一个最小值和一个最大值之间的随机数12345function ourFunction(ourMin, ourMax) &#123; return Math.floor(Math.random() * (ourMax - ourMin + 1)) + ourMin;&#125;ourFunction(1, 9);","text":"# 需要定义一个最小值和一个最大值之间的随机数12345function ourFunction(ourMin, ourMax) &#123; return Math.floor(Math.random() * (ourMax - ourMin + 1)) + ourMin;&#125;ourFunction(1, 9); # 计算一个整数的阶乘12345678910function factorialize(num) &#123; // 请把你的代码写在这里 if(num &lt;= 1) &#123; return 1; &#125; else &#123; return num *= factorialize(num - 1); &#125;&#125;factorialize(5); # 来一段回文 JavaScript算法练习： JavaScript中回文(Palindromes)处理 123456789101112131415161718192021222324252627//方法一function palindrome(str) &#123; // 请把你的代码写在这里 var re = /[\\W_]/g; var lowRegStr = str.toLowerCase().replace(re, ''); var reveRegStr = lowRegStr.split('').reverse().join(''); return lowRegStr == reveRegStr;&#125;palindrome(\"eye\");//方法二function palindrome(str) &#123; // 请把你的代码写在这里 var re = /[\\W_]/g; var lowRegStr = str.toLowerCase().replace(re, ''); for(var i=0, l=lowRegStr.length; i&lt;l/2; i++) &#123; if(lowRegStr[i] != lowRegStr[l - 1 -i]) &#123; return false; &#125; &#125; return true;&#125;palindrome(\"eye\"); # 在句子中找出最长的单词，并返回它的长度。 js 数组排序和算法排序 12345678910111213function findLongestWord(str) &#123; var strArr = str = str.split(' '); var newArr = []; for(var i=0;i&lt;strArr.length; i++) &#123; newArr.push(strArr[i].length); &#125; newArr.sort(function(a, b) &#123; return b - a; &#125;); return newArr[0];&#125;findLongestWord(\"What if we try a super-long word such as otorhinolaryngology\"); # 确保字符串的每个单词首字母都大写，其余部分小写。12345678910111213141516function titleCase(str) &#123; var strArr = str.split(' '); var newStrArr = []; var newStr = ''; for(var i=0; i&lt;strArr.length; i++) &#123; newStr = strArr[i][0].toUpperCase(); newStr += strArr[i].substr(1).toLowerCase(); newStrArr.push(newStr); &#125; newStrArr = newStrArr.join(' '); return newStrArr;&#125;titleCase(\"I'm a little tea pot\"); # 找出多个数组中的最大数12345678910111213function largestOfFour(arr) &#123; var newArr = []; var num = []; for(var i=0; i&lt;arr.length; i++) &#123; num = arr[i].sort(function(a, b) &#123; return b - a; &#125;); newArr.push(num[0]); &#125; return newArr;&#125;largestOfFour([[4, 5, 1, 3], [13, 27, 18, 26], [32, 35, 37, 39], [1000, 1001, 857, 1]]); # 判断一个字符串(str)是否以指定的字符串(target)结尾。123456789101112function confirmEnding(str, target) &#123; var len = target.length; if(str.substr(-len) == target) &#123; return true; &#125; else &#123; return false; &#125; &#125;confirmEnding(\"He has to give me a new name\", \"name\");confirmEnding(\"Bastian\", \"n\"); # 重复一个指定的字符串 num次，如果num是一个负数则返回一个空字符串。12345678910111213141516function repeat(str, num) &#123; // 请把你的代码写在这里 var newArr = []; var newStr = ''; if(num &lt; 0) &#123; newStr = ''; &#125; else &#123; for(var i=0; i&lt;num; i++) &#123; newArr.push(str); &#125; newStr = newArr.join(''); &#125; return newStr;&#125;repeat(\"abc\", 4); # 如果字符串的长度比指定的参数num长… 如果字符串的长度比指定的参数num长，则把多余的部分用…来表示。切记，插入到字符串尾部的三个点号也会计入字符串的长度。但是，如果指定的参数num小于或等于3，则添加的三个点号不会计入字符串的长度。 12345678910111213function truncate(str, num) &#123; var newStr=''; if(num &gt;= str.length) &#123; newStr = str.slice(0); &#125; else if(num &gt; 3) &#123; newStr = str.slice(0, num-3) + '...'; &#125; else &#123; newStr = str.slice(0, num) + '...'; &#125; return newStr;&#125;truncate(\"A-tisket a-tasket A green and yellow basket\", 11); # 把一个数组arr按照指定的数组大小size分割成若干个数组块。 js将一位数组分割成每三个一组 123456789function chunk(arr, size) &#123; var newArr = []; for(var i=0; i&lt;arr.length; i+=size) &#123; newArr.push(arr.slice(i, i+size)); &#125; return newArr;&#125;chunk([\"a\", \"b\", \"c\", \"d\"], 2); # 返回一个数组被截断n个元素后还剩余的元素，截断从索引0开始。123456function slasher(arr, howMany) &#123; arr.splice(0, howMany); return arr;&#125;slasher([1, 2, 3], 2); # 如果数组第一个字符串元素包含了第二个字符串元素的所有字符，函数返回true。123456789101112function mutation(arr) &#123; var str1 = arr[0].toLowerCase(); var str2 = arr[1].toLowerCase(); for(var i=0; i&lt;str2.length; i++) &#123; if(str1.indexOf(str2[i]) == -1) &#123; return false; &#125; &#125; return true;&#125;mutation([\"hello\", \"hey\"]); # 删除数组中的所有假值。1234567891011function bouncer(arr) &#123; var newArr = []; newArr = arr.filter(function(val) &#123; if(val !== (undefined &amp;&amp; null &amp;&amp; \"\" &amp;&amp; NaN &amp;&amp; false &amp;&amp; 0)) &#123; return val; &#125; &#125;); return newArr;&#125;bouncer([7, \"ate\", \"\", false, 9]); # 数组排序并找出元素索引，先给数组排序，然后找到指定的值在数组的位置，最后返回位置对应的索引。123456789function where(arr, num) &#123; arr.push(num); arr.sort(function(a, b) &#123; return a-b; &#125;); return arr.indexOf(num);&#125;where([40, 60], 50); # 实现一个摧毁(destroyer)函数，第一个参数是待摧毁的数组，其余的参数是待摧毁的值。 FCC–Seek and Destroy（摧毁数组） Seek and Destroy(算法) 12345678910111213function destroyer(arr) &#123; var newArr = []; var arg = arguments; for(var i=1; i&lt;arg.length; i++) &#123; newArr.push(arg[i]); &#125; arr = arr.filter(function(val) &#123; return newArr.indexOf(val) &lt; 0; &#125;); return arr;&#125;destroyer([1, 2, 3, 1, 2, 3], 2, 3); 发表于慕课网手记 题目来自： FreeCodeCamp BasicAlgorithmScripting参考资料： JavaScript标准库","categories":[{"name":"Web","slug":"Web","permalink":"https://tangyanqiong.com/categories/Web/"},{"name":"JS","slug":"Web/JS","permalink":"https://tangyanqiong.com/categories/Web/JS/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://tangyanqiong.com/tags/JavaScript/"},{"name":"算法","slug":"算法","permalink":"https://tangyanqiong.com/tags/算法/"}]},{"title":"《Vue.js实战》之前端路由与vue-router","slug":"vue-router","date":"2018-07-04T03:23:17.000Z","updated":"2019-07-26T09:44:45.535Z","comments":true,"path":"post/8734e386.html","link":"","permalink":"https://tangyanqiong.com/post/8734e386.html","excerpt":"前言什么是前端路由 每次 GET 或者 POST 请求在服务端有一个专门的正则配置列表，然后匹配到具体的一条路径后，分发到不同的 Controller，进行各种操作，最终将 html 或数据返回给前端，这就完成了一次 IO。 前端路由的实现\b有两种： URL的hash，即锚点（#），js 通过 hashChange 事件监听 url 的变化 HTML5 的 History 模式 优点： 页面持久性，如音乐网站 前后端彻底分离，如 Angular 的 ngRouter，\bReact 的 ReactRouter，还有 Vue 的 vue-router 需要考虑的问题： 页面的拔插性 页面的生命周期 内存管理等","text":"前言什么是前端路由 每次 GET 或者 POST 请求在服务端有一个专门的正则配置列表，然后匹配到具体的一条路径后，分发到不同的 Controller，进行各种操作，最终将 html 或数据返回给前端，这就完成了一次 IO。 前端路由的实现\b有两种： URL的hash，即锚点（#），js 通过 hashChange 事件监听 url 的变化 HTML5 的 History 模式 优点： 页面持久性，如音乐网站 前后端彻底分离，如 Angular 的 ngRouter，\bReact 的 ReactRouter，还有 Vue 的 vue-router 需要考虑的问题： 页面的拔插性 页面的生命周期 内存管理等 vue-router 基本用法1234567# 新建目录 router# 安装 vue-routernpm i -S vue-router# index.js添加import VueRouter from 'vue-router';Vue.use(VueRouter); 在目录 \brouter 新建 views 目录，接着新建 about.vue、 index.vue、 user.vue等 123456789101112131415161718192021222324252627282930// index.jsconst Routers = [ &#123; path: '/index', component: (resolve) =&gt; require(['../router/views/index.vue'], resolve) &#125;, &#123; path: '/about', component: (resolve) =&gt; require(['../router/views/about.vue'], resolve) &#125;, &#123; path: '*', redirect: '../index' // 404指向首页 &#125;];const RouterConfig = &#123; // 使用HTML5的history路由模式 mode: 'history', routes: Routers&#125;const router = new VueRouter(RouterConfig);document.body.appendChild(root);new Vue(&#123; router: router, render: h =&gt; h(App)&#125;).$mount(root); 路由模式通过HTML5的History路由模式，通过 ‘/’设置路径。修改package.json:123\"scripts\": &#123; \"dev\": \"webpack-dev-server --config webpack.config.js --mode=development --history-api-fallback\"&#125;, 增加了 --history-api-fallback，所有的路由都指向index.html。 然后在根实例App.vue中添加&lt;router-view&gt;&lt;/router-view&gt; 跳转vue-router 有两种跳转页面的方式： &lt;router-link&gt;组件，会渲染成\b &lt;a&gt; 标签，如：&lt;router-link to=&quot;/about&quot;&gt;跳转到 about&lt;/router-link&gt; tag : tag=&quot;li&quot; 标签会被渲染成指定的 &lt;li&gt; replace : 无历史记录 active-class 使用router实例： $router 方法，如：this.$router.push(&#39;/index&#39;); replace : this.$router.replace(&#39;/index&#39;); go : this.$router.go(-1);高级用法 问题：如何在SPA项目中，修改网页的标题？ 一般我们是通过window.document.title = &#39;标题&#39;来修改，但是在什么时候修改，这是个问题。 vue-router 提供了导航钩子 beforeEach() 和 afterEach()，它们会在路由即将改变前和改变后触发。 这样就解决了页面众多，维护麻烦的问题。（mounted钩子） 123456789101112131415router.beforeEach((to, from, next) =&gt; &#123; // 从路由对象 to 里获取 meta 信息 window.document.title = to.meta.title; // 判断页面是否登录 if(window.localStorage.getItem('token')) &#123; next(); &#125; else &#123; next('/login'); &#125;&#125;);router.afterEach((to, from, next) =&gt; &#123; // 页面跳转回来滚动条默认\b在顶端 window.scroll(0, 0);&#125;) 状态管理与 Vuex状态管理与使用场景组件的基本运行模式：一个组件分为数据和视图，数据更新时，视图也跟着更新…视图中又可以绑定一些事件，它们触发methods里指定的方法，从而可以改变数据、更新视图。 如果需要跨组件共享数据的需求，那就需要借助 Vuex 来管理组件状态。 Vuex 基本用法1npm i -S vuex","categories":[{"name":"Web","slug":"Web","permalink":"https://tangyanqiong.com/categories/Web/"},{"name":"Vue","slug":"Web/Vue","permalink":"https://tangyanqiong.com/categories/Web/Vue/"}],"tags":[{"name":"Vue-router","slug":"Vue-router","permalink":"https://tangyanqiong.com/tags/Vue-router/"}]},{"title":"SDWebImage实现原理","slug":"SDWebImage原理","date":"2018-06-25T03:02:32.000Z","updated":"2019-07-26T06:44:47.650Z","comments":true,"path":"post/7ae6af5d.html","link":"","permalink":"https://tangyanqiong.com/post/7ae6af5d.html","excerpt":"前言平时项目中经常使用到的框架中必有SDWebImage框架，这是一个很成熟图片缓存框架，而且使用非常的方便，只需一行代码就可以实现设置占位图以及在网络图片拉取成功后替换占位图的功能。虽然，乍一看只是现实了拉取网络图片的小小功能，但是，里面还包含了很多逻辑代码，也是很复杂的，你有没有深究它的实现原理呢？","text":"前言平时项目中经常使用到的框架中必有SDWebImage框架，这是一个很成熟图片缓存框架，而且使用非常的方便，只需一行代码就可以实现设置占位图以及在网络图片拉取成功后替换占位图的功能。虽然，乍一看只是现实了拉取网络图片的小小功能，但是，里面还包含了很多逻辑代码，也是很复杂的，你有没有深究它的实现原理呢？ 实现原理 在网络获取图片前，取消并移除当前对象的图片下载线程。 动态关联该图片url（用于图片存缓存的key），一般默认选项有占位图则先显示占位图（其中有个options选项可以不显示或者延时显示占位图等等，稍后再讲）。 使用关联的key作为路径，在内存中寻找该图片，找不到，再到本地中找，还是找不到，则通过url去服务器中下载。 在上一步中，如果在内存中找到了该图片，则直接返回；如果在本地找到了该图片，则先加载到内存中，再返回；如果需要到服务器拉取，则先把拉取到的图片加载到内存中，再存到本地，最后才返回。 设置对象的图片并显示。 具体逻辑如下图： 详解 取消当前对象的下载线程 1234567891011//通过key（一般都是url）获取下载线程- (void)sd_cancelImageLoadOperationWithKey:(NSString *)key &#123; // Cancel in progress downloader from queue NSMutableDictionary *operationDictionary = [self operationDictionary]; //获取下载队列字典 id operations = [operationDictionary objectForKey:key]; //取出当前key的所有队列 ··· [operation cancel]; //取消当前线程 ··· [operationDictionary removeObjectForKey:key]; //所有队列执行完cancel操作后，在所在数组移除 &#125;&#125; 设置关联的key 1objc_setAssociatedObject(self, &amp;imageURLKey, url, OBJC_ASSOCIATION_RETAIN_NONATOMIC); 设置占位图 12345if (!(options &amp; SDWebImageDelayPlaceholder)) &#123; dispatch_main_async_safe(^&#123; self.image = placeholder; &#125;);&#125; 下载图片（在缓存或者本地缓存获取也算在这里面，这里只列出了核心代码，完整代码在Github上下载SDWebImage库了解） 1234567891011121314151617181920212223242526272829//下载图片，返回一个实现SDWebImageOperation协议的对象。注：该协议只有一个cancel函数id &lt;SDWebImageOperation&gt; operation = [SDWebImageManager.sharedManager downloadImageWithURL:url options:options progress:progressBlock completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123; dispatch_main_sync_safe(^&#123; completedBlock(image, error, cacheType, url); &#125; &#125;);&#125;];//图片下载- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url options:(SDWebImageOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageCompletionWithFinishedBlock)completedBlock &#123; ... //获取图片 operation.cacheOperation = [self.imageCache queryDiskCacheForKey:key done:^(UIImage *image, SDImageCacheType cacheType) &#123;...&#125;]; return operation;&#125;//queryDiskCacheForkey函数里面首先会先去内存中寻找图片，没有再去本地找，最后才去服务器下载- (NSOperation *)queryDiskCacheForKey:(NSString *)key done:(SDWebImageQueryCompletedBlock)doneBlock &#123; //获取内存中的图片 UIImage *image = [self imageFromMemoryCacheForKey:key]; ... //获取本地储存的图片 UIImage *diskImage = [self diskImageForKey:key]; ... return operation;&#125; options作用1234567891011121314typedef NS_OPTIONS(NSUInteger, SDWebImageOptions) &#123; SDWebImageRetryFailed = 1 &lt;&lt; 0, SDWebImageLowPriority = 1 &lt;&lt; 1, SDWebImageCacheMemoryOnly = 1 &lt;&lt; 2, SDWebImageProgressiveDownload = 1 &lt;&lt; 3, SDWebImageRefreshCached = 1 &lt;&lt; 4, SDWebImageContinueInBackground = 1 &lt;&lt; 5, SDWebImageHandleCookies = 1 &lt;&lt; 6, SDWebImageAllowInvalidSSLCertificates = 1 &lt;&lt; 7, SDWebImageHighPriority = 1 &lt;&lt; 8, SDWebImageDelayPlaceholder = 1 &lt;&lt; 9, SDWebImageTransformAnimatedImage = 1 &lt;&lt; 10, SDWebImageAvoidAutoSetImage = 1 &lt;&lt; 11&#125;; 就说说SDWebImageRetryFailed有什么作用，先看一下注释： By default, when a URL fail to be downloaded, the URL is blacklisted so the library won’t keep trying.This flag disable this blacklisting. 默认options=0，也就是如果不传SDWebImageRetryFailed，图片下载失败了就会被加入黑名单，不会再重新下载，除非设置options=SDWebImageRetryFailed。 1234567891011if ( error.code != NSURLErrorNotConnectedToInternet &amp;&amp; error.code != NSURLErrorCancelled &amp;&amp; error.code != NSURLErrorTimedOut &amp;&amp; error.code != NSURLErrorInternationalRoamingOff &amp;&amp; error.code != NSURLErrorDataNotAllowed &amp;&amp; error.code != NSURLErrorCannotFindHost &amp;&amp; error.code != NSURLErrorCannotConnectToHost) &#123; @synchronized (self.failedURLs) &#123; [self.failedURLs addObject:url]; &#125;&#125; 其他 AutoPurgeCacheNSCache子类，初始化的时候注册通知，监听内存报警，会在接收到通知后清除内存，代码如下： 1[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(removeAllObjects) name:UIApplicationDidReceiveMemoryWarningNotification object:nil]; 设置image在获取图片后没有立即刷新，而是设置刷新标志，下一次runloop的时候刷新，代码如下： 12wself.image = image;[wself setNeedsLayout]; 总结其实SDWebImage的源码很好理解，核心逻辑代码条理清晰，只不过，作者在这基础上完善了很多功能逻辑，功能模块分离，降低耦合度，除了UIImageView控件，还有UIButton控件也能用来设置Image。源码不多，建议感兴趣的都可以去看一下，了解一下。最后，来说一下缓存和本地缓存的区别： 本地缓存顾名思义是存在本地的，具体是存在应用沙盒的cache文件里，而cache里面会在某些情况下被系统自动清除，比如，内存报警，所以一般放不太重要的，不需要备份的文件。s 缓存是一个大概念，本地缓存也算缓存，这里NSCahce指的应该是内存，看是否已经加在到内存里了，如果已经存在内存，就可以直接从内存中获取设置图片了。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://tangyanqiong.com/categories/iOS/"},{"name":"OC","slug":"iOS/OC","permalink":"https://tangyanqiong.com/categories/iOS/OC/"}],"tags":[{"name":"SDWebImage","slug":"SDWebImage","permalink":"https://tangyanqiong.com/tags/SDWebImage/"},{"name":"图片缓存","slug":"图片缓存","permalink":"https://tangyanqiong.com/tags/图片缓存/"}]},{"title":"Web设置Cookie","slug":"设置Cookie","date":"2018-05-03T03:32:13.000Z","updated":"2019-07-26T06:46:04.507Z","comments":true,"path":"post/e189a0d8.html","link":"","permalink":"https://tangyanqiong.com/post/e189a0d8.html","excerpt":"设置Cookie总结","text":"设置Cookie总结 代码记录 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 收藏功能 function addFavorite() &#123; var title = '意法半导体STM32/STM8技术社区 - 提供最新的ST资讯和技术交流'; var URL = 'http://www.stmcu.org.cn/'; // IE10 if(document.all) &#123; window.external.addFavorite(URL, title); &#125; else &#123; alert('手动 Ctrl+D 可以收藏我们的网站哦'); &#125; &#125; // 设置cookie，同一域名都可获取 function setCookie(name, value, exdays) &#123; var exdays = exdays || 1024; var d = new Date(); d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000)); document.cookie = name + \"=\" + escape(value) + \";path=/;expires=\" + d.toGMTString(); &#125; // 读取cookies，判断是否存在设置的name function getCookie(name) &#123; var name = name + \"=\"; var ca = document.cookie.split(';'); for (var i = 0; i &lt; ca.length; i++) &#123; var c = ca[i].trim(); if (c.indexOf(name) == 0) &#123; return c.substring(name.length, c.length); &#125; &#125; return \"\"; &#125; function checkCookie() &#123; var user = getCookie(\"msgCookie\"); var width = window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth; if(width &gt;= 1080) &#123; if (user != \"\") &#123; msgHide(); &#125; else &#123; msgShow(); &#125; &#125; &#125; // 关闭时设置cookie function closeModal() &#123; msgHide(); setCookie(\"msgCookie\", 'msgCookie'); &#125; function msgHide() &#123; document.getElementById('newsTipsModal').style.display = 'none'; &#125; function msgShow() &#123; document.getElementById('newsTipsModal').style.display = 'block'; &#125; // init checkCookie();","categories":[{"name":"Web","slug":"Web","permalink":"https://tangyanqiong.com/categories/Web/"},{"name":"JS","slug":"Web/JS","permalink":"https://tangyanqiong.com/categories/Web/JS/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://tangyanqiong.com/tags/JavaScript/"},{"name":"Cookie","slug":"Cookie","permalink":"https://tangyanqiong.com/tags/Cookie/"},{"name":"Web","slug":"Web","permalink":"https://tangyanqiong.com/tags/Web/"}]},{"title":"《Vue.js实战》之使用webpack","slug":"vue-webpack","date":"2018-03-04T03:22:59.000Z","updated":"2019-07-26T09:46:02.735Z","comments":true,"path":"post/e8ff02eb.html","link":"","permalink":"https://tangyanqiong.com/post/e8ff02eb.html","excerpt":"前端工程化与webpack前端工程化主要解决的问题： JavaScript、css 代码的合并与压缩 CSS 预处理：Less、Sass、Stylus 的编译 生成雪碧图 ES6 -&gt; ES5 模块化等 webpack 的主要使用场景是单页面富应用（SPA），将一些诸如：typescript、less、jpg、vue等格式的文件通过特定的加载器（Loader）编译后，最终统一生成 .js、.css、.png等静态资源文件。 如何文件都可称为是一个模块。webpack就是处理模块间的依赖关系，并把他们进行打包。","text":"前端工程化与webpack前端工程化主要解决的问题： JavaScript、css 代码的合并与压缩 CSS 预处理：Less、Sass、Stylus 的编译 生成雪碧图 ES6 -&gt; ES5 模块化等 webpack 的主要使用场景是单页面富应用（SPA），将一些诸如：typescript、less、jpg、vue等格式的文件通过特定的加载器（Loader）编译后，最终统一生成 .js、.css、.png等静态资源文件。 如何文件都可称为是一个模块。webpack就是处理模块间的依赖关系，并把他们进行打包。 webpack 基础配置安装 webpack 与 webpack-dev-server初始化12npm init # 按照提示一步步往下走 本地局部安装 webpack:（书中是v2，我的\b需要下载脚手架 -cli）1234567npm install webpack --save-devnpm i -D webpack-cli# 会多出下面一项“\"devDependencies\": &#123; \"webpack\": \"^4.28.4\"&#125; 安装 webpack-dev-server，可以启动一个服务器、热更新、接口代理等1npm install webpack-dev-server --save-dev 最终的 package.json 文件内容如下：1234567891011121314151617181920212223242526272829&#123; \"name\": \"vue-webpack-iview\", \"version\": \"1.0.0\", \"description\": \"学习《Vue.js实战》之进阶篇\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"repository\": &#123; \"type\": \"git\", \"url\": \"git+https://github.com/yangtao2o/vue-webpack-iview.git\" &#125;, \"keywords\": [ \"vue\", \"webpack\", \"iview\" ], \"author\": \"yangtao\", \"license\": \"ISC\", \"bugs\": &#123; \"url\": \"https://github.com/yangtao2o/vue-webpack-iview/issues\" &#125;, \"homepage\": \"https://github.com/yangtao2o/vue-webpack-iview#readme\", \"devDependencies\": &#123; \"webpack\": \"^4.28.4\", \"webpack-cli\": \"^3.2.1\", \"webpack-dev-server\": \"^3.1.14\" &#125;&#125; 就是一个 js 文件而已创建 webpack.config.js，并初始化： 12345var config = &#123;&#125;module.exports = config; 接着，在 package.json 里配置启动项： 123456789\"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"dev\": \"webpack-dev-server --open --config webpack.config.js --mode=development\"&#125;// --open：会在启动服务时自动\b打开浏览器// --config：指向 webpack-dev-server 读取的配置文件路径// --host --port：可配置 IP 和端口，如：--host 172.172.172.1 --port 8888// --mode=development：需要说明是什么环境，不然会显示警告 webpack 的入口\b（Entry）和出口（Output），重中之重，新建 main.js，并在 webpack.config.js 中进行\b\b入口和输出的配置：123456789101112var config = &#123; entry: &#123; main: &apos;./main&apos; // 入口文件为 main.js &#125;, output: &#123; path: path.join(__dirname, &apos;./dist&apos;), // 输出目录 publicPath: &apos;./dist&apos;, //指定资源文件引用的目录 filename: &apos;main.js&apos; // 指定输出文件的名称 &#125;&#125;module.exports = config; 然后：npm run dev，浏览器会自动打开页面了。 逐步完善配置文件webpack 对于不同的\b模块需要不同的加载器来处理，通过安装不同的加载器，就可以对各种后缀名的文件进行处理。 如处理 .css 文件：123456789101112131415161718# cssnpm install css-loader --save-devnpm install style-loader --save-dev# rules 属性中可以指定一系列的 loaders# 每一个 loader 都必须包含 test 和 use # \b处理名为 .css 的文件时，先通过 css-loader 转换，再通过 style-loader 转换，然后继续打包module: &#123; rules: [ &#123; test: '/\\.css$/', use: [ 'style-loader', 'css-loader' ] &#125; ]&#125; 在实际的业务中，需要使用插件 extract-text-webpack-plugin 把各处的css文件提取出来。，并生成一个 main.css 文件，最终在 index.html 里加载它。 1npm install extract-text-webpack-plugin@next --save-dev config12345678910111213141516var ExtractTextPlugin = require('extract-text-webpack-plugin');module: &#123; rules: [ &#123; test: '/\\.css$/', use: ExtractTextPlugin.extract(&#123; use: 'css-loader', fallback: 'style-loader' &#125;) &#125; ]&#125;,plugins: [ new ExtractTextPlugin('main.css'),] 单文件组件与 vue-loader安装加载器：123456npm install --save-dev vue vue-loader vue-style-loadernpm install --save-dev vue-template-compilernpm install --save-dev vue-hot-reload-apinpm i -D babel babel-loadernpm i -D @babel/corenpm i -D @babel/preset-env 配置：Babel-loader、Vue-loader 结合自己配置的过程中关于版本冲突的解决办法参考：webpack4配置vue环境和一些小坑 主要修改： index.js(之前的 main.js，目录也放在了/src/下) 1234567import Vue from 'vue';import App from './App.vue';const root = document.createElement('div');document.body.appendChild(root);new Vue(&#123; render: h =&gt; h(App)&#125;).$mount(root); App.vue 12345678910111213141516171819&lt;template&gt; &lt;div&gt; Hello &#123;&#123; name &#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; name: 'Vue.js' &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; package.js 12345678910111213141516171819202122\"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"dev\": \"webpack-dev-server --config webpack.config.js --mode=development\", \"build\": \"webpack --progress --hide-modules --mode=production\"&#125;,\"devDependencies\": &#123; \"@babel/core\": \"^7.2.2\", \"@babel/preset-env\": \"^7.2.3\", \"babel\": \"^6.23.0\", \"babel-loader\": \"^8.0.5\", \"css-loader\": \"^2.1.0\", \"extract-text-webpack-plugin\": \"^4.0.0-beta.0\", \"style-loader\": \"^0.23.1\", \"vue\": \"^2.5.22\", \"vue-hot-reload-api\": \"^2.3.1\", \"vue-loader\": \"^15.5.1\", \"vue-style-loader\": \"^4.1.2\", \"vue-template-compiler\": \"^2.5.22\", \"webpack\": \"^4.28.4\", \"webpack-cli\": \"^3.2.1\", \"webpack-dev-server\": \"^3.1.14\"&#125;, webpack.config.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344const path = require('path');const VueLoaderPlugin = require('vue-loader/lib/plugin');const ExtractTextPlugin = require('extract-text-webpack-plugin');module.exports = &#123; entry: path.join(__dirname, './src/index.js'), output: &#123; path: path.join(__dirname, './dist'), // 输出目录 publicPath: '/dist', //指定资源文件引用的目录 filename: 'main.js' // 指定输出文件的名称 &#125;, module: &#123; rules: [ &#123; test: /\\.vue$/, loader: 'vue-loader', options: &#123; loaders: &#123; css: ExtractTextPlugin.extract(&#123; use: 'css-loader', fallback: 'vue-style-loader' &#125;) &#125; &#125; &#125;, &#123; test: /\\.js$/, loader: 'babel-loader', exclude: /node_modules/ &#125;, &#123; test: /\\.css$/, use: ExtractTextPlugin.extract(&#123; use: 'css-loader', fallback: 'style-loader' &#125;) &#125; ] &#125;, plugins: [ new VueLoaderPlugin(), new ExtractTextPlugin('main.css'), ]&#125; .babelrc 1234&#123; \"presets\": [\"@babel/preset-env\"], \"plugins\": [\"@babel/plugin-transform-runtime\"]&#125; index.html 123456...&lt;link rel=\"stylesheet\" href=\"./dist/main.css\"&gt;...&lt;body&gt; &lt;script src=\"./dist/main.js\"&gt;&lt;/script&gt;&lt;/body&gt; 用于生产环境 练习地址","categories":[{"name":"Web","slug":"Web","permalink":"https://tangyanqiong.com/categories/Web/"},{"name":"Vue","slug":"Web/Vue","permalink":"https://tangyanqiong.com/categories/Web/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://tangyanqiong.com/tags/Vue/"},{"name":"Webpack","slug":"Webpack","permalink":"https://tangyanqiong.com/tags/Webpack/"}]},{"title":"怎么使用Hexo编写博客","slug":"hexo-use","date":"2018-01-18T07:39:43.000Z","updated":"2019-07-26T08:31:18.591Z","comments":true,"path":"post/4f821c45.html","link":"","permalink":"https://tangyanqiong.com/post/4f821c45.html","excerpt":"前言由于网上太多关于github+hexo搭建教程，搭建这里就不多说了，推荐之前搭建参考的网址： 使用hexo+github搭建免费个人博客详细教程 GitPages+Hexo搭建个人博客 搭建完成后，怎么使用hexo这个框架，网页的排版这些就很难找到相关资料了，自己研究了下，具体整理出来，方便后面的人使用。","text":"前言由于网上太多关于github+hexo搭建教程，搭建这里就不多说了，推荐之前搭建参考的网址： 使用hexo+github搭建免费个人博客详细教程 GitPages+Hexo搭建个人博客 搭建完成后，怎么使用hexo这个框架，网页的排版这些就很难找到相关资料了，自己研究了下，具体整理出来，方便后面的人使用。 目录 博客功能配置 根目录_config.yml配置 Hexo常用命令 博客功能配置主题配置官方提供很多主题，这里放两个主题，其他可以自行度娘，博主更偏爱material-x主题，哈哈。到指定目录下clone。 1234$ cd /Users/TangDan/GitHub/MyHexoBlog/themes$ hexo clean$ git clone https://github.com/iissnan/hexo-theme-next$ git clone https://github.com/xaoxuu/hexo-theme-material-x themes/material-x //本博客使用主题 现在themes目录下应该多了两个目录：next、material-x，然后到_config.yml修改theme: material-x，再执行 1234$ cd /Users/TangDan/GitHub/MyHexoBlog$ hexo g$ hexo d //推送到远端$ hexo server //本地查看 PS:运行中出现任何问题，可以先hexo clean再执行。 两个主题配置这两个主题配置其实说难不难，说简单不简单，目前我是只去研究了material-x主题的配置，过程即酸爽又享受。 Next主题官方配置文档Material-X主题官方配置文档PS：请一定要仔细的去读官方文档，不要看了这个文档一半又跑去查其他的资料，其他的资料可能更新没官方那么快，是老版本的，到最后一顿操作猛如虎，结果等于白忙，不要问我怎么知道的，我不会告诉你，= =！ 链接持久化hexo默认的链接是http://xxx.com/2017/08/18/hello-world 这种类型的，这种路径看着也挺low的，这源于站点配置文件_config.yml里的配置: permalink: :year/:month/:day/:title/. 这种默认配置的缺点就是当我们创建的博文名包含中文的名的时候，url 链接地址经常会变成一串很长的难以理解的字符串，不利于博文的链接分享，以及搜索引擎搜索，另外就是年月日都会有分隔符。我们可以让 url 链接持久化来解决这个问。 安装hexo-abbrlink插件 $ sudo npm install hexo-abbrlink 修改站点配置文件 _config.yml permalink: post/:abbrlink.html 添加 abbrlink: 123456permalink: post/:abbrlink.html # :year/:month/:day/:title/ # 文章的永久链接格式permalink_defaults: # 永久链接中个部分的默认值# abbrlink config 需安装插件hexo-abbrlinkabbrlink: alg: crc32 # 算法： crc16(default) and crc32 rep: hex # 进制： dec(default) and hex 站内搜索安装 hexo-generator-search 插件 $ sudo npm install hexo-generator-search 配置站点文件_config.yml: 1234567# 站内搜索search: path: search.xml field: postlocal_search: enable: true 根目录_config.yml配置站点配置（重要）123456title: 博客名 //网站标题subtitle: To strive, to seek, to find //网站副标题description: To strive, to seek, to find, and not to yield. //网站描述author: WenBo //您的名字language: zh-Hans //网站使用的语言 简体中文 zh-Hanstimezone: //网站时区。Hexo 默认使用您电脑的时区 URL配置1234url: http://blogwenbo.com/ //网址root: / //网站根目录permalink: :year/:month/:day/:title/ // 文章的 [永久链接](https://hexo.io/zh-cn/docs/permalinks.html) 格式 | `:year/:month/:day/:title/` |permalink_defaults: //永久链接中各部分的默认值 目录配置12345678source_dir: source //资源文件夹，这个文件夹用来存放内容。默认值：sourcepublic_dir: public //公共文件夹，这个文件夹用于存放生成的站点文件。默认值：publictag_dir: tags //标签文件夹 默认值：tagsarchive_dir: archives //归档文件夹 默认值：archivescategory_dir: categories //分类文件夹 默认值：categoriescode_dir: downloads/code //Include code 文件夹 默认值：downloads/codei18n_dir: :lang //国际化（i18n）文件夹 默认值：:langskip_render: README.md //跳过指定文件的渲染，您可使用 [glob 表达式](https://github.com/isaacs/node-glob)来匹配路径。 Git部署配置（重要）1234deploy: type: git //填git repo: git@github.com:wenmobo/wenmobo.github.io.git //SSH地址 branch: master //分支 Hexo常用命令其实搭建成功后，在/Users/TangDan/GitHub/MyHexoBlog/source/_posts里默认会有生成一个hello-world.md，这个里面描述了常用的哪些命令及意义，可在里面查看。 常用创建命令： 12$ hexo new &quot;xxx&quot; //创建一篇文章$ hexo new page &quot;xxx&quot; //创建一个分类 总体来说，提交一个修改到github，最好顺序执行以下命令： 1234$ hexo clean$ hexo g// $ hexo s //这个是提交到本地$ hexo d //推送到github","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://tangyanqiong.com/categories/Hexo/"}],"tags":[{"name":"Hexo命令","slug":"Hexo命令","permalink":"https://tangyanqiong.com/tags/Hexo命令/"},{"name":"Material-X","slug":"Material-X","permalink":"https://tangyanqiong.com/tags/Material-X/"}]}]}