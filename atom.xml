<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Root&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.tea-room.cn/"/>
  <updated>2019-05-27T09:04:02.663Z</updated>
  <id>https://blog.tea-room.cn/</id>
  
  <author>
    <name>Root</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue框架底层原理</title>
    <link href="https://blog.tea-room.cn/post/d32be447.html"/>
    <id>https://blog.tea-room.cn/post/d32be447.html</id>
    <published>2019-03-20T09:58:17.000Z</published>
    <updated>2019-05-27T09:04:02.663Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Vue框架是什么，怎么用，相信大家都已经很熟悉了，诚如<a href="https://www.runoob.com/vue2/vue-tutorial.html" target="_blank" rel="noopener">Vue教程</a>所说，它是一套构建用户界面的渐进式Web前端框架。</p><fancybox><img src="https://i.loli.net/2019/05/27/5ceb976f6b4eb74810.png" alt="image"></fancybox><p>但是很多人就是拿来主义，就只管用，博主也是这类人 = =!, 但是随着深入使用Vue，越发觉得深知其原理的重要性，那么，本文来探讨一下Vue的底层原理到底是什么，是怎么实现的。</p><a id="more"></a><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h2><p>Vue的底层原理总体来说就是深入响应式原理，它最独特的特性之一就是非侵入性的响应式系统。数据模型仅仅是普通的 JavaScript 对象。而当你修改它们时，视图会进行更新，这使得状态管理非常简单直接。</p><h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><h3 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h3><p>下面是一段代码，较直观的体现了Vue特点，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;mvvm-app&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&quot;word&quot;&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;word&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button v-on:click=&quot;sayHi&quot;&gt;change model&lt;/button&gt; //点击这个button，word的值会发生改变</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script src=&quot;./js/observer.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;./js/watcher.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;./js/compile.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;./js/mvvm.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var vm = new MVVM(&#123;</span><br><span class="line">        el: &apos;#mvvm-app&apos;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            word: &apos;Hello World!&apos;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            sayHi: function() &#123;</span><br><span class="line">                this.word = &apos;Hi, everybody!&apos;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>实现效果如下：</strong></p><p><img src="https://i.loli.net/2019/05/27/5ceba18d75b1079687.gif" alt="vue_test.gif"></p><p>而Vue实现数据双向绑定的效果，需要<strong>三大模块：</strong></p><ul><li><ol><li>Observer：对数据对象的所有属性进行监听，如有变动可拿到最新值并通知观察者</li></ol></li><li><ol start="2"><li>Compile：对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数</li></ol></li><li><ol start="3"><li>Watcher：作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图</li></ol></li></ul><p><img src="https://i.loli.net/2019/05/27/5ceba2641810f80268.png" alt="vue_test2.png"></p><h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><p>Observer的核心是通过Obeject.defineProperty()来监听数据的变动，这个函数内部可以定义setter和getter，每当数据发生变化，就会触发setter。这时候Observer就要通知订阅者，订阅者就是Watcher。</p><h3 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h3><p>Watcher订阅者作为Observer和Compile之间通信的桥梁，主要做的事情是：</p><ul><li><ol><li>在自身实例化时往属性订阅器(dep)里面添加自己</li></ol></li><li><ol start="2"><li>自身必须有一个update()方法</li></ol></li><li><ol start="3"><li>待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调</li></ol></li></ul><h3 id="Compile"><a href="#Compile" class="headerlink" title="Compile"></a>Compile</h3><p>Compile主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>MVVM 是Model-View-ViewModel 的缩写，它是一种基于前端开发的架构模式，其核心是提供对View 和 ViewModel 的双向数据绑定，这使得ViewModel 的状态改变可以自动传递给 View，即所谓的数据双向绑定。</p><p>而Vue框架则是一个提供了 MVVM 风格的双向数据绑定的 Javascript 库，专注于View 层。它的核心是 MVVM 中的 VM，也就是 ViewModel。 ViewModel负责连接 View 和 Model，保证视图和数据的一致性，这种轻量级的架构让前端开发更加高效、便捷。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Vue框架是什么，怎么用，相信大家都已经很熟悉了，诚如&lt;a href=&quot;https://www.runoob.com/vue2/vue-tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Vue教程&lt;/a&gt;所说，它是一套构建用户界面的渐进式Web前端框架。&lt;/p&gt;
&lt;fancybox&gt;&lt;img src=&quot;https://i.loli.net/2019/05/27/5ceb976f6b4eb74810.png&quot; alt=&quot;image&quot;&gt;&lt;/fancybox&gt;

&lt;p&gt;但是很多人就是拿来主义，就只管用，博主也是这类人 = =!, 但是随着深入使用Vue，越发觉得深知其原理的重要性，那么，本文来探讨一下Vue的底层原理到底是什么，是怎么实现的。&lt;/p&gt;
    
    </summary>
    
      <category term="Web前端" scheme="https://blog.tea-room.cn/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="https://blog.tea-room.cn/categories/Web%E5%89%8D%E7%AB%AF/Vue/"/>
    
    
      <category term="Vue" scheme="https://blog.tea-room.cn/tags/Vue/"/>
    
      <category term="Web" scheme="https://blog.tea-room.cn/tags/Web/"/>
    
      <category term="MVVM" scheme="https://blog.tea-room.cn/tags/MVVM/"/>
    
  </entry>
  
  <entry>
    <title>OC工程怎么转换为Swift工程</title>
    <link href="https://blog.tea-room.cn/post/dff23fd2.html"/>
    <id>https://blog.tea-room.cn/post/dff23fd2.html</id>
    <published>2018-08-24T09:42:27.000Z</published>
    <updated>2019-05-27T06:32:07.471Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前段时间用Object-C正在开发一个项目，开发了差不多百分之七八十了，客户通知要求改成Swift语言开发（因为他只会Swift），好吧，一个项目用Swift来写其实也无可厚非，但是这个项目中途来换，可想而知是多么痛苦的事，已经写了好多个OC类。</p><a id="more"></a><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h2 id="调研"><a href="#调研" class="headerlink" title="调研"></a>调研</h2><p>之前一开始也在网上找了很多资料，有OC与Swift对应功能的语法解说，也有贴代码用工具直接转的，用过iSwift，但不是很好用，识别率不高，正确率不高。</p><p>这些都感觉比较费时（客户只给了一周的时间），然后就在想，有没有一个是直接可以转工程的工具呢？别说，强大的google还真搜出来了，这个软件可以直接转换工程。</p><h2 id="实施"><a href="#实施" class="headerlink" title="实施"></a>实施</h2><p>这个软件叫什么名呢，也不卖关子了，是一个在线转换的网站：</p><p><a href="https://objectivec2swift.com/#/converter/code/" target="_blank" rel="noopener">OC2Swift</a></p><p>它是提供少量代码免费转换，大家可转换自己的部分代码看看正确性，还可以在线输出Swift代码结果，它可以单文件、文件夹或工程打包在线转换。</p><p>不过呢，好的软件都是收费的，具体资费我就不说了（避免托的嫌疑，有需要的上官网自己看吧），对于转换的成本来说这个价格很便宜了。</p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul><li><ol><li>给大家一个建议，这个购买后使用有流量限制，建议打包的时候把静态库、framwork、SDK、第三方库等相关的剔除后打包上传，转换成功后再放置到对应路径下。</li></ol></li><li><ol start="2"><li>原OC代码留存（原因见下面）。</li></ol></li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p><strong>这个工程转换成功后，使用起来就没有一点问题了吗？</strong></p><p>错错错，当初我记得一开始报错不怎么多几十个吧，关键改完后，不断的重编译就暴露更多的错，这样下来估计也改了有几百个错了。</p><h4 id="是什么类型的错误"><a href="#是什么类型的错误" class="headerlink" title="是什么类型的错误"></a>是什么类型的错误</h4><ul><li><ol><li>很多都是语法的错误，而Xcode有提示修正的方法，直接鼠标点点点就改好了，比较轻松。</li></ol></li><li><ol start="2"><li>有些是语法不识别的问题，这个就需要自己查资料对应OC代码寻找对应的Swift代码了，所以要留存原OC代码。</li></ol></li><li><ol start="3"><li>有些工程设置的地方报错，但是这个很少，就几处，百度google就能解决。</li></ol></li></ul><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>然后，到了这一步，以为万事大吉了吗？哈哈，并没有，有些地方转换虽说没报错，但可能会转错意，需要整体流程跑下，最好找测试再过遍流程，切记。</p><p>PS：有些OC库实在没办法转的，就采取<strong>桥接</strong>的方式使用吧。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总体来说，这次的转换是很成功的，原本估时为一周，但是实际2～3天就完成了转换，比较高效率，所以建议大家转换Swift可采取这种方式。</p><p>比较遗憾的是，当时时间比较赶，没来得及截图留存给大家，如果觉得文章上有什么疑问，或者实际实践过程中遇到什么问题，欢迎大家在下方留言告诉我，我会第一时间回复你。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前段时间用Object-C正在开发一个项目，开发了差不多百分之七八十了，客户通知要求改成Swift语言开发（因为他只会Swift），好吧，一个项目用Swift来写其实也无可厚非，但是这个项目中途来换，可想而知是多么痛苦的事，已经写了好多个OC类。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://blog.tea-room.cn/categories/iOS/"/>
    
      <category term="Swift" scheme="https://blog.tea-room.cn/categories/iOS/Swift/"/>
    
    
      <category term="Object-C" scheme="https://blog.tea-room.cn/tags/Object-C/"/>
    
      <category term="Swift" scheme="https://blog.tea-room.cn/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>怎么使用Hexo编写博客</title>
    <link href="https://blog.tea-room.cn/post/4f821c45.html"/>
    <id>https://blog.tea-room.cn/post/4f821c45.html</id>
    <published>2018-05-18T07:39:43.000Z</published>
    <updated>2019-05-27T06:45:04.611Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于网上太多关于github+hexo搭建教程，搭建这里就不多说了，推荐之前搭建参考的网址：</p><p><a href="https://www.jianshu.com/p/201283bcd64a.html" target="_blank" rel="noopener">使用hexo+github搭建免费个人博客详细教程</a></p><p><a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html" target="_blank" rel="noopener">GitPages+Hexo搭建个人博客</a></p><p>搭建完成后，怎么使用hexo这个框架，网页的排版这些就很难找到相关资料了，自己研究了下，具体整理出来，方便后面的人使用。</p><a id="more"></a><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li>博客功能配置</li><li>根目录_config.yml配置</li><li>Hexo常用命令</li></ul><h2 id="博客功能配置"><a href="#博客功能配置" class="headerlink" title="博客功能配置"></a>博客功能配置</h2><h3 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h3><p>官方提供很多主题，这里放两个主题，其他可以自行度娘，博主更偏爱material-x主题，哈哈。到指定目录下clone。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /Users/TangDan/GitHub/MyHexoBlog/themes</span><br><span class="line">$ hexo clean</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/xaoxuu/hexo-theme-material-x themes/material-x  //本博客使用主题</span><br></pre></td></tr></table></figure><p>现在themes目录下应该多了两个目录：next、material-x，然后到_config.yml修改theme: material-x，再执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cd /Users/TangDan/GitHub/MyHexoBlog</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo d  //推送到远端</span><br><span class="line">$ hexo server //本地查看</span><br></pre></td></tr></table></figure><p>PS:运行中出现任何问题，可以先hexo clean再执行。</p><h3 id="两个主题配置"><a href="#两个主题配置" class="headerlink" title="两个主题配置"></a>两个主题配置</h3><p>这两个主题配置其实说难不难，说简单不简单，目前我是只去研究了material-x主题的配置，过程即酸爽又享受。</p><h4 id="Next主题官方配置文档"><a href="#Next主题官方配置文档" class="headerlink" title="Next主题官方配置文档"></a><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">Next主题官方配置文档</a></h4><h4 id="Material-X主题官方配置文档"><a href="#Material-X主题官方配置文档" class="headerlink" title="Material-X主题官方配置文档"></a><a href="https://xaoxuu.com/wiki/material-x/index.html" target="_blank" rel="noopener">Material-X主题官方配置文档</a></h4><p>PS：请一定要仔细的去读官方文档，不要看了这个文档一半又跑去查其他的资料，其他的资料可能更新没官方那么快，是老版本的，到最后一顿操作猛如虎，结果等于白忙，不要问我怎么知道的，我不会告诉你，= =！</p><h3 id="链接持久化"><a href="#链接持久化" class="headerlink" title="链接持久化"></a>链接持久化</h3><p>hexo默认的链接是<a href="http://xxx.com/2017/08/18/hello-world" target="_blank" rel="noopener">http://xxx.com/2017/08/18/hello-world</a> 这种类型的，这种路径看着也挺low的，这源于站点配置文件_config.yml里的配置: permalink: :year/:month/:day/:title/. 这种默认配置的缺点就是当我们创建的博文名包含中文的名的时候，url 链接地址经常会变成一串很长的难以理解的字符串，不利于博文的链接分享，以及搜索引擎搜索，另外就是年月日都会有分隔符。我们可以让 url 链接持久化来解决这个问。</p><p>安装hexo-abbrlink插件</p><p><code>$ sudo npm install hexo-abbrlink</code></p><p>修改站点配置文件 _config.yml</p><ul><li><p>permalink: post/:abbrlink.html</p></li><li><p>添加 abbrlink:</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">permalink: post/:abbrlink.html  # :year/:month/:day/:title/     # 文章的永久链接格式</span><br><span class="line">permalink_defaults:     # 永久链接中个部分的默认值</span><br><span class="line"># abbrlink config 需安装插件hexo-abbrlink</span><br><span class="line">abbrlink:</span><br><span class="line">  alg: crc32  # 算法： crc16(default) and crc32</span><br><span class="line">  rep: hex    # 进制： dec(default) and hex</span><br></pre></td></tr></table></figure><h3 id="站内搜索"><a href="#站内搜索" class="headerlink" title="站内搜索"></a>站内搜索</h3><p>安装 hexo-generator-search 插件</p><p><code>$ sudo npm install hexo-generator-search</code></p><p>配置站点文件_config.yml:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 站内搜索</span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line"></span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure><h2 id="根目录-config-yml配置"><a href="#根目录-config-yml配置" class="headerlink" title="根目录_config.yml配置"></a>根目录_config.yml配置</h2><h3 id="站点配置（重要）"><a href="#站点配置（重要）" class="headerlink" title="站点配置（重要）"></a>站点配置（重要）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">title: 博客名   //网站标题</span><br><span class="line">subtitle: To strive, to seek, to find   //网站副标题</span><br><span class="line">description: To strive, to seek, to find, and not to yield.  //网站描述</span><br><span class="line">author: WenBo  //您的名字</span><br><span class="line">language: zh-Hans  //网站使用的语言 简体中文 zh-Hans</span><br><span class="line">timezone:   //网站时区。Hexo 默认使用您电脑的时区</span><br></pre></td></tr></table></figure><h3 id="URL配置"><a href="#URL配置" class="headerlink" title="URL配置"></a>URL配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">url: http://blogwenbo.com/   //网址</span><br><span class="line">root: /  //网站根目录</span><br><span class="line">permalink: :year/:month/:day/:title/  // 文章的 [永久链接](https://hexo.io/zh-cn/docs/permalinks.html) 格式 | `:year/:month/:day/:title/` |</span><br><span class="line">permalink_defaults:  //永久链接中各部分的默认值</span><br></pre></td></tr></table></figure><h3 id="目录配置"><a href="#目录配置" class="headerlink" title="目录配置"></a>目录配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">source_dir: source  //资源文件夹，这个文件夹用来存放内容。默认值：source</span><br><span class="line">public_dir: public  //公共文件夹，这个文件夹用于存放生成的站点文件。默认值：public</span><br><span class="line">tag_dir: tags  //标签文件夹 默认值：tags</span><br><span class="line">archive_dir: archives  //归档文件夹 默认值：archives</span><br><span class="line">category_dir: categories  //分类文件夹  默认值：categories</span><br><span class="line">code_dir: downloads/code  //Include code 文件夹 默认值：downloads/code</span><br><span class="line">i18n_dir: :lang  //国际化（i18n）文件夹 默认值：:lang</span><br><span class="line">skip_render: README.md  //跳过指定文件的渲染，您可使用 [glob 表达式](https://github.com/isaacs/node-glob)来匹配路径。</span><br></pre></td></tr></table></figure><h3 id="Git部署配置（重要）"><a href="#Git部署配置（重要）" class="headerlink" title="Git部署配置（重要）"></a>Git部署配置（重要）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git //填git</span><br><span class="line">  repo: git@github.com:wenmobo/wenmobo.github.io.git  //SSH地址</span><br><span class="line">  branch: master  //分支</span><br></pre></td></tr></table></figure><h2 id="Hexo常用命令"><a href="#Hexo常用命令" class="headerlink" title="Hexo常用命令"></a>Hexo常用命令</h2><p>其实搭建成功后，在/Users/TangDan/GitHub/MyHexoBlog/source/_posts里默认会有生成一个hello-world.md，这个里面描述了常用的哪些命令及意义，可在里面查看。</p><p>总体来说，提交一个修改，最好顺序执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;由于网上太多关于github+hexo搭建教程，搭建这里就不多说了，推荐之前搭建参考的网址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/201283bcd64a.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;使用hexo+github搭建免费个人博客详细教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitPages+Hexo搭建个人博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;搭建完成后，怎么使用hexo这个框架，网页的排版这些就很难找到相关资料了，自己研究了下，具体整理出来，方便后面的人使用。&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="https://blog.tea-room.cn/categories/Hexo/"/>
    
    
      <category term="Hexo命令" scheme="https://blog.tea-room.cn/tags/Hexo%E5%91%BD%E4%BB%A4/"/>
    
      <category term="Material-X主题" scheme="https://blog.tea-room.cn/tags/Material-X%E4%B8%BB%E9%A2%98/"/>
    
  </entry>
  
</feed>
