<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Root&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://tangyanqiong.com/"/>
  <updated>2022-07-24T08:58:23.456Z</updated>
  <id>https://tangyanqiong.com/</id>
  
  <author>
    <name>Root</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue2升级Vue3的必要性</title>
    <link href="https://tangyanqiong.com/post/64d00251.html"/>
    <id>https://tangyanqiong.com/post/64d00251.html</id>
    <published>2022-07-15T03:11:22.000Z</published>
    <updated>2022-07-24T08:58:23.456Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>就在前两天，一篇反对Vue2升级到Vue3的文章在vue官方社区引起了热议。（原文链接：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fmedium.com%2Fjs-dojo%2Fvue-3-was-a-mistake-that-we-should-not-repeat-81cc65484954" target="_blank" rel="noopener">Vue 3 was a mistake that we should not repeat</a>），该文章从实际应用角度出发，分析了Vue2到Vue3在真实项目中实操升级的痛点，提出了一个反对的声音：<strong>Vue3的升级是一个错误的选择</strong>。</p><p>在一片热议中，甚至vue作者<strong>尤雨溪</strong>都出来亲自解释并承认了一些问题。原作者首先声明了他并没有贬低Vue3的意思。他认为Vue3是非常非常棒的框架，解决了Vue2中很多潜在问题，技术层面改善了开发人员的开发体验，并显著提高了性能。原作者主要的问题，是从Vue3突破性的改变以及周边生态圈未能及时跟上的角度，重点强调了迁移升级成本+风险较大。</p><blockquote><p>关于升级成本问题：尤大也承认了Vue3升级体验并没有想象中的那么流畅，Vue4会吸取经验，做好平稳迭代。这一点本文会在下面详细说明。</p></blockquote><a id="more"></a><h1 id="原文提出Vue2升级Vue3问题"><a href="#原文提出Vue2升级Vue3问题" class="headerlink" title="原文提出Vue2升级Vue3问题"></a>原文提出Vue2升级Vue3问题</h1><h2 id="破坏性的api变更"><a href="#破坏性的api变更" class="headerlink" title="破坏性的api变更"></a>破坏性的api变更</h2><ul><li><p>Events API的弃用让这个问题首当其冲。（straightforward like the depreciation of the Events API）。Vue实例再也不能作为事件总线做事件通信，$on，$off，$once的彻底移除意味着之前所有有关代码都必须重新推翻重写，虽然有很好的插件工具让这件事变得没那么复杂，但是仍然会带来不小的迁移成本。</p></li><li><p>代码构建问题。 你会经常遇到用Vue2写法写出来的代码在构建(build) 失败或抛出警告。因为这些api写法在Vue3中已经被废弃。这问题在已存在的大型项目中的尤为突出（In an existing large-scale application built with Vue 2, you would probably use some of the deprecated or changed APIs）。下图展示了一部分Breaking changes，可以看到破坏性的api变更数确实很多：</p></li></ul><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4fa6fa0646044507b581cb93e2f349a2~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" alt></p><h2 id="颠覆式的设计模式"><a href="#颠覆式的设计模式" class="headerlink" title="颠覆式的设计模式"></a>颠覆式的设计模式</h2><p>颠覆式的composition-api慢慢向面向函数思想转变，导致很多原有习惯于options-api的开发者反感Vue正在像react靠拢，没有坚持住Vue特色。它提出了一种新的基于函数的 Vue 组件编写方式，引起了Vue社区大量的争议和分裂，甚至将社区分隔为两种观点阵营针锋相对，最终导致了Vue 最黑暗的一天事件。这很令人沮丧。</p><h2 id="生态系统"><a href="#生态系统" class="headerlink" title="生态系统"></a>生态系统</h2><p>生态系统和框架本身一样重要。因为没有责任机制，在有争议的决定和在弃用功能的时候，很多框架周边的生态系统的许多贡献者会被迫离开，并导致许多库被放弃或者延迟更新。很多时候，我们没有办法做版本兼容时，我们往往只能把责任归咎于，开源库缺乏同理心和对大局的理解。</p><h2 id="文档系统"><a href="#文档系统" class="headerlink" title="文档系统"></a>文档系统</h2><p>在我们的日常开发中，尤其是在使用框架时，我们会遇到各种各样的问题，这时我们时常需要google或者问答社区作为帮手，但是目前关于Vue搜索出来的结果几乎全是Vue2的结果，这也很难不令人难过。</p><h2 id="过往案例"><a href="#过往案例" class="headerlink" title="过往案例"></a>过往案例</h2><blockquote><p>Vue2到Vue3的升级，有一点像angular1到angular2的升级</p></blockquote><p>过渡到 Vue 3 看起来很像从AngularJS过渡到Angular（版本 1⇒ 2）。大量的延迟和重大更改导致了挫败感，最终 Angular 失去了对 React 和 Vue 的吸引力。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul><li><p>看起来前进的道路其实是倒退。</p></li><li><p>开发满意度看起来并不好。</p></li></ul><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0fae6bf5abe94884b3fc81b8510d33c7~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" alt></p><p>上图可以看到Vue已经有被svelte超越的趋势。</p><ul><li>Vue4应该考虑到整个生态系统并提供迁移路径，否则它将成为没有人愿意使用的最佳框架。</li></ul><h1 id="vue作者尤大回复"><a href="#vue作者尤大回复" class="headerlink" title="vue作者尤大回复"></a>vue作者尤大回复</h1><ol><li>关于破坏性的api:</li></ol><p><strong>这根本不是真的</strong>。</p><p>当我们进行版本切换时，所有核心库和工具都与这两个版本兼容（或为 Vue 2/3 支持提供单独的版本）。</p><p>实际上阻碍升级的依赖都是第三方，主要是 Nuxt 和 Vuetify。</p><ol start="2"><li>颠覆式的设计模式：</li></ol><p>实际使用过 Composition API + &lt; script setup&gt; 的用户在真是开发中的反馈非常积极，证明这是一个有价值的补充，现在他们中的许多人更喜欢它而不是 Options API。</p><p>我们当然可以更好地处理新 API 的引入，但仅仅因为存在争议，并不意味着它是错误的或者不必要的。实际上，引入大的、新的想法的行为，势必会让那些喜欢呆在舒适区的人感到不安，但如果我们迎合这种心态，就永远不会取得真正的进展。</p><ol start="3"><li>关于周边生态和文档系统：</li></ol><p>虽然我们确实创造了 Vue CLI、Vuex、Vetur 和 VuePress 的新替代品，但它们本身都有适用于 Vue 3 的版本。这是夸大事实，不尊重团队为提供这些工具的 Vue 3 兼容版本所做的努力。</p><ol start="4"><li>关于和angular的过往对比：</li></ol><ul><li><p>没有可比性，不能拿Vue升级和angularjs -&gt; angular做对比。</p></li><li><p>Angular 和 AngularJS 是根本不同的框架。几乎没有共享交集，除了完全重写之外没有实际的迁移路径。</p></li><li><p>另一方面，有许多生产 Vue 2 应用程序成功迁移到 Vue 3 的案例。很容易吗，确实不是，但是他们都迁移成功了。</p></li></ul><ol start="5"><li>关于升级问题：</li></ol><p>我们同意，Vue3升级体验并没有想象中的那么流畅。Vue 将随着吸取的经验不断发展，我们绝对不打算在未来的Vue4中，进行这样的破坏性重大升级。</p><ol start="6"><li>关于这篇文章结论：</li></ol><p>在我看来，这篇文章整体上描绘的画面比实际要黑暗(dark)得多，有不必要的夸张，在少数情况下是完全不正确的信息。我希望至少能纠正我在其他评论中指出的一些事实错误。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上述就是原文提出来的问题以及尤大的回复，应该可以给各位正在考虑升级的小伙伴一点真实的参考意见，原有Vue2项目是否能安全平稳升级到Vue3，我还是持有一定保留意见，如果是时间充裕的项目可以升，如果是时间比较赶的项目，建议不升级。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;就在前两天，一篇反对Vue2升级到Vue3的文章在vue官方社区引起了热议。（原文链接：&lt;a href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fmedium.com%2Fjs-dojo%2Fvue-3-was-a-mistake-that-we-should-not-repeat-81cc65484954&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Vue 3 was a mistake that we should not repeat&lt;/a&gt;），该文章从实际应用角度出发，分析了Vue2到Vue3在真实项目中实操升级的痛点，提出了一个反对的声音：&lt;strong&gt;Vue3的升级是一个错误的选择&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在一片热议中，甚至vue作者&lt;strong&gt;尤雨溪&lt;/strong&gt;都出来亲自解释并承认了一些问题。原作者首先声明了他并没有贬低Vue3的意思。他认为Vue3是非常非常棒的框架，解决了Vue2中很多潜在问题，技术层面改善了开发人员的开发体验，并显著提高了性能。原作者主要的问题，是从Vue3突破性的改变以及周边生态圈未能及时跟上的角度，重点强调了迁移升级成本+风险较大。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;关于升级成本问题：尤大也承认了Vue3升级体验并没有想象中的那么流畅，Vue4会吸取经验，做好平稳迭代。这一点本文会在下面详细说明。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Web" scheme="https://tangyanqiong.com/categories/Web/"/>
    
      <category term="Vue" scheme="https://tangyanqiong.com/categories/Web/Vue/"/>
    
    
      <category term="JavaScript" scheme="https://tangyanqiong.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Eslint + Prettier + Husky + Commitlint+ Lint-staged 工程化前端代码</title>
    <link href="https://tangyanqiong.com/post/bcc0035c.html"/>
    <id>https://tangyanqiong.com/post/bcc0035c.html</id>
    <published>2021-10-05T15:35:22.000Z</published>
    <updated>2022-07-23T16:53:48.631Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>你是否会遇到提交代码时，没有改到同事业务模块的任何一行代码，却被提示冲突？提交注释凌乱看不懂的情况？等等。</p><p>那么为了项目代码风格统一，代码格式化规范统一，避免代码冲突，提高代码的规范性，提高CodeReview效率等等。因此结合Eslint + Prettier + Husky + Commitlint+ Lint-staged的前端工程化规范应运而生，最终提升了我们开发效率、项目质量。</p><a id="more"></a><h1 id="配置eslint"><a href="#配置eslint" class="headerlink" title="配置eslint"></a>配置eslint</h1><h2 id="执行安装命令"><a href="#执行安装命令" class="headerlink" title="执行安装命令"></a>执行安装命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm add eslint -D</span><br></pre></td></tr></table></figure><h2 id="执行eslint初始化命令"><a href="#执行eslint初始化命令" class="headerlink" title="执行eslint初始化命令"></a>执行eslint初始化命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm eslint --init</span><br></pre></td></tr></table></figure><h2 id="依次初始化选项"><a href="#依次初始化选项" class="headerlink" title="依次初始化选项"></a>依次初始化选项</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">(1) How would you like to use ESLint?</span><br><span class="line">选择：To check syntax and find problems</span><br><span class="line"></span><br><span class="line">(2) What type of modules does your project use?</span><br><span class="line">选择：JavaScript modules (import/export)</span><br><span class="line"></span><br><span class="line">(3) Which framework does your project use?</span><br><span class="line">选择：Vue.js</span><br><span class="line"></span><br><span class="line">(4) Does your project use TypeScript?</span><br><span class="line">选择：Yes</span><br><span class="line"></span><br><span class="line">(5) Where does your code run?</span><br><span class="line">选择：Browser</span><br><span class="line"></span><br><span class="line">(6) What format do you want your config file to be in?</span><br><span class="line">选择：JavaScript</span><br><span class="line"></span><br><span class="line">(7) Would you like to install them now?</span><br><span class="line">选择：Yes</span><br><span class="line"></span><br><span class="line">(8) Which package manager do you want to use?</span><br><span class="line">选择：npm</span><br></pre></td></tr></table></figure><h2 id="依赖安装完成后，会生成-eslintrc-js配置文件"><a href="#依赖安装完成后，会生成-eslintrc-js配置文件" class="headerlink" title="依赖安装完成后，会生成.eslintrc.js配置文件"></a>依赖安装完成后，会生成.eslintrc.js配置文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    &quot;env&quot;: &#123;</span><br><span class="line">        &quot;browser&quot;: true,</span><br><span class="line">        &quot;es2021&quot;: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;extends&quot;: [</span><br><span class="line">        &quot;eslint:recommended&quot;,</span><br><span class="line">        &quot;plugin:vue/vue3-essential&quot;,</span><br><span class="line">        &quot;plugin:@typescript-eslint/recommended&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;parserOptions&quot;: &#123;</span><br><span class="line">        &quot;ecmaVersion&quot;: &quot;latest&quot;,</span><br><span class="line">        &quot;parser&quot;: &quot;@typescript-eslint/parser&quot;,</span><br><span class="line">        &quot;sourceType&quot;: &quot;module&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;plugins&quot;: [</span><br><span class="line">        &quot;vue&quot;,</span><br><span class="line">        &quot;@typescript-eslint&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;rules&quot;: &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时打开.eslintrc.js配置文件会出现一个报错，需要再env字段中增加node: true配置以解决eslint找不到module的报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    &quot;env&quot;: &#123;</span><br><span class="line">        &quot;browser&quot;: true,</span><br><span class="line">        &quot;es2021&quot;: true,</span><br><span class="line">        // 新增</span><br><span class="line">+        &quot;node&quot;: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;extends&quot;: [</span><br><span class="line">        &quot;eslint:recommended&quot;,</span><br><span class="line">        &quot;plugin:vue/vue3-essential&quot;,</span><br><span class="line">        &quot;plugin:@typescript-eslint/recommended&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;parserOptions&quot;: &#123;</span><br><span class="line">        &quot;ecmaVersion&quot;: &quot;latest&quot;,</span><br><span class="line">        &quot;parser&quot;: &quot;@typescript-eslint/parser&quot;,</span><br><span class="line">        &quot;sourceType&quot;: &quot;module&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;plugins&quot;: [</span><br><span class="line">        &quot;vue&quot;,</span><br><span class="line">        &quot;@typescript-eslint&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;rules&quot;: &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在package-json文件中的script中添加lint命令"><a href="#在package-json文件中的script中添加lint命令" class="headerlink" title="在package.json文件中的script中添加lint命令"></a>在package.json文件中的script中添加lint命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;scripts&quot;: &#123;</span><br><span class="line">        // eslint . 为指定lint当前项目中的文件</span><br><span class="line">        // --ext 为指定lint哪些后缀的文件</span><br><span class="line">        // --fix 开启自动修复</span><br><span class="line">        &quot;lint&quot;: &quot;eslint . --ext .vue,.js,.ts,.jsx,.tsx --fix&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="执行lint命令"><a href="#执行lint命令" class="headerlink" title="执行lint命令"></a>执行lint命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm lint</span><br></pre></td></tr></table></figure><p>这时候命令行中会出现报错，意思就是在解析.vue后缀的文件时候出现解析错误parsing error。</p><p>查阅资料后发现，eslint默认是不会解析.vue后缀文件的。因此，需要一个额外的解析器来解析.vue后缀文件。</p><p>但是我们查看.eslintrc.js文件中的extends会发现已经有继承”plugin:vue/vue3-essential”的配置。然后在node_modules中可以找到eslint-plugin-vue/lib/cinfigs/essential，里面配置了extends是继承于同级目录下的base.js，在里面会发现parser: require.resolve(‘vue-eslint-parser’)这个配置。因此，按道理来说应该是会解析.vue后缀文件的。</p><p>继续往下看.eslintrc.js文件中的extends会发现，extends中还有一个”plugin:@typescript-eslint/recommended”，它是来自于/node_modules/@typescript-eslint/eslint-plugin/dist/configs/recommended.js，查看该文件会发现最终继承于同级目录下的base.js文件。从该文件中可以发现parser: ‘@typescript-eslint/parser’,配置。</p><p>按照.eslintrc.js文件中的extends配置的顺序可知，最终导致报错的原因就是@typescript-eslint/parser把vue-eslint-parser覆盖了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;extends&quot;: [</span><br><span class="line">        &quot;eslint:recommended&quot;,</span><br><span class="line">        &quot;plugin:vue/vue3-essential&quot;,</span><br><span class="line">        &quot;plugin:@typescript-eslint/recommended&quot;</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看eslint-plugin-vue官方文档可知。如果已经使用了另外的解析器（例如”parser”: “@typescript-eslint/parser”），则需要将其移至parseOptions，这样才不会与vue-eslint-parser冲突。</p><p><strong>修改.eslintrc.js文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    &quot;env&quot;: &#123;</span><br><span class="line">        &quot;browser&quot;: true,</span><br><span class="line">        &quot;es2021&quot;: true,</span><br><span class="line">        &quot;node&quot;: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;extends&quot;: [</span><br><span class="line">        &quot;eslint:recommended&quot;,</span><br><span class="line">        &quot;plugin:vue/vue3-essential&quot;,</span><br><span class="line">        &quot;plugin:@typescript-eslint/recommended&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;parser&quot;: &quot;vue-eslint-parser&quot;,</span><br><span class="line">    &quot;parserOptions&quot;: &#123;</span><br><span class="line">        &quot;ecmaVersion&quot;: &quot;latest&quot;,</span><br><span class="line">        &quot;parser&quot;: &quot;@typescript-eslint/parser&quot;,</span><br><span class="line">        &quot;sourceType&quot;: &quot;module&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;plugins&quot;: [</span><br><span class="line">        &quot;vue&quot;,</span><br><span class="line">        &quot;@typescript-eslint&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;rules&quot;: &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个parser的区别在于，外面的parser用来解析.vue后缀文件，使得eslint能解析template标签中的内容，而parserOptions中的parser，即@typescript-eslint/parser用来解析vue文件中script标签中的代码。</p><p>此时，再执行npm lint，就会发现校验通过了。</p><h2 id="安装vscode插件ESLint"><a href="#安装vscode插件ESLint" class="headerlink" title="安装vscode插件ESLint"></a>安装vscode插件ESLint</h2><p>如果写一行代码就要执行一遍lint命令，这效率就太低了。所以我们可以配合vscode的ESLint插件，实现每次保存代码时，自动执行lint命令来修复代码的错误。</p><p>在项目中新建.vscode/settings.json文件，然后在其中加入以下配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // 开启自动修复</span><br><span class="line">    &quot;editor.codeActionsOnSave&quot;: &#123;</span><br><span class="line">        &quot;source.fixAll&quot;: false,</span><br><span class="line">        &quot;source.fixAll.eslint&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="安装依赖说明"><a href="#安装依赖说明" class="headerlink" title="安装依赖说明"></a>安装依赖说明</h2><ul><li>eslint： JavaScript 和 JSX 检查工具</li><li>eslint-plugin-vue： 使用 ESLint 检查 .vue文件 的 template和script，以及.js文件中的Vue代码</li></ul><h1 id="配置prettier"><a href="#配置prettier" class="headerlink" title="配置prettier"></a>配置prettier</h1><h2 id="执行安装命令-1"><a href="#执行安装命令-1" class="headerlink" title="执行安装命令"></a>执行安装命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm add prettier -D</span><br></pre></td></tr></table></figure><h2 id="在根目录下新建-prettierrc-js"><a href="#在根目录下新建-prettierrc-js" class="headerlink" title="在根目录下新建.prettierrc.js"></a>在根目录下新建.prettierrc.js</h2><p>添加以下配置，更多配置可查看官方文档</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    // 一行的字符数，如果超过会进行换行，默认为80</span><br><span class="line">    printWidth: 80, </span><br><span class="line">    // 一个tab代表几个空格数，默认为80</span><br><span class="line">    tabWidth: 2, </span><br><span class="line">    // 是否使用tab进行缩进，默认为false，表示用空格进行缩减</span><br><span class="line">    useTabs: false, </span><br><span class="line">    // 字符串是否使用单引号，默认为false，使用双引号</span><br><span class="line">    singleQuote: true, </span><br><span class="line">    // 行位是否使用分号，默认为true</span><br><span class="line">    semi: false, </span><br><span class="line">    // 是否使用尾逗号，有三个可选值&quot;&lt;none|es5|all&gt;&quot;</span><br><span class="line">    trailingComma: &quot;none&quot;, </span><br><span class="line">    // 对象大括号直接是否有空格，默认为true，效果：&#123; foo: bar &#125;</span><br><span class="line">    bracketSpacing: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在package-json中的script中添加以下命令"><a href="#在package-json中的script中添加以下命令" class="headerlink" title="在package.json中的script中添加以下命令"></a>在package.json中的script中添加以下命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;scripts&quot;: &#123;</span><br><span class="line">        &quot;format&quot;: &quot;prettier --write \&quot;./**/*.&#123;html,vue,ts,js,json,md&#125;\&quot;&quot;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行该命令，会将我们项目中的文件都格式化一遍，后续如果添加其他格式的文件，可在该命令中添加，例如：.less后缀的文件</p><h2 id="安装vscode的Prettier-Code-formatter插件"><a href="#安装vscode的Prettier-Code-formatter插件" class="headerlink" title="安装vscode的Prettier - Code formatter插件"></a>安装vscode的Prettier - Code formatter插件</h2><p>安装该插件的目的是，让该插件在我们保存的时候自动完成格式化</p><p>在.vscode/settings.json中添加一下规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // 保存的时候自动格式化</span><br><span class="line">    &quot;editor.formatOnSave&quot;: true,</span><br><span class="line">    // 默认格式化工具选择prettier</span><br><span class="line">    &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解决eslint与prettier的冲突"><a href="#解决eslint与prettier的冲突" class="headerlink" title="解决eslint与prettier的冲突"></a>解决eslint与prettier的冲突</h1><p>在理想的状态下，eslint与prettier应该各司其职。eslint负责我们的代码质量，prettier负责我们的代码格式。但是在使用的过程中会发现，由于我们开启了自动化的eslint修复与自动化的根据prettier来格式化代码。所以我们已保存代码，会出现屏幕闪一起后又恢复到了报错的状态。</p><p>这其中的根本原因就是eslint有部分规则与prettier冲突了，所以保存的时候显示运行了eslint的修复命令，然后再运行prettier格式化，所以就会出现屏幕闪一下然后又恢复到报错的现象。这时候你可以检查一下是否存在冲突的规则。</p><p>查阅资料会发现，社区已经为我们提供了一个非常成熟的方案，即eslint-config-prettier + eslint-plugin-prettier。</p><ul><li>eslint-plugin-prettier： 基于 prettier 代码风格的 eslint 规则，即使eslint使用pretter规则来格式化代码。</li><li>eslint-config-prettier： 禁用所有与格式相关的 eslint 规则，解决 prettier 与 eslint 规则冲突，确保将其放在 extends 队列最后，这样它将覆盖其他配置</li></ul><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm add eslint-config-prettier eslint-plugin-prettier -D</span><br></pre></td></tr></table></figure><h2 id="在-eslintrc-json中extends的最后添加一个配置"><a href="#在-eslintrc-json中extends的最后添加一个配置" class="headerlink" title="在 .eslintrc.json中extends的最后添加一个配置"></a>在 .eslintrc.json中extends的最后添加一个配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">    extends: [</span><br><span class="line">    &apos;eslint:recommended&apos;,</span><br><span class="line">    &apos;plugin:vue/vue3-essential&apos;,</span><br><span class="line">    &apos;plugin:@typescript-eslint/recommended&apos;,</span><br><span class="line">+    // 新增，必须放在最后面</span><br><span class="line">+    &apos;plugin:prettier/recommended&apos; </span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后重启vscode，你会发现冲突消失了，eslint与prettier也按照我们预想的各司其职了。</p><h1 id="配置stylelint"><a href="#配置stylelint" class="headerlink" title="配置stylelint"></a>配置stylelint</h1><p>stylelint为css的lint工具。可格式化css代码，检查css语法错误与不合理的写法，指定css书写顺序等…</p><h2 id="安装依赖-1"><a href="#安装依赖-1" class="headerlink" title="安装依赖"></a>安装依赖</h2><p>由于我的项目使用的less预处理器，因此配置的为less相关的，项目中使用其他预处理器的可以按照该配置方法改一下就好</p><p>stylelint v13版本将css, parse CSS(如SCSS,SASS),html内的css(如*.vue中的style)等编译工具都包含在内。但是v14版本没有包含在内，所以需要安装需要的工具</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm add stylelint postcss postcss-less postcss-html stylelint-config-prettier stylelint-config-recommended-less stylelint-config-standard stylelint-config-standard-vue stylelint-less stylelint-order -D</span><br></pre></td></tr></table></figure><p>依赖说明：</p><ul><li>stylelint: css样式lint工具</li><li>postcss: 转换css代码工具</li><li>postcss-less: 识别less语法</li><li>postcss-html: 识别html/vue 中的style标签中的样式</li><li>stylelint-config-standard: Stylelint的标准可共享配置规则，详细可查看官方文档</li><li>stylelint-config-prettier: 关闭所有不必要或可能与Prettier冲突的规则</li><li>stylelint-config-recommended-less: less的推荐可共享配置规则，详细可查看官方文档</li><li>stylelint-config-standard-vue: lint.vue文件的样式配置</li><li>stylelint-less: stylelint-config-recommended-less的依赖，less的stylelint规则集合</li><li>stylelint-order: 指定样式书写的顺序，在.stylelintrc.js中order/properties-order指定顺序</li></ul><h2 id="增加-stylelintrc-js配置文件"><a href="#增加-stylelintrc-js配置文件" class="headerlink" title="增加.stylelintrc.js配置文件"></a>增加.stylelintrc.js配置文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  extends: [</span><br><span class="line">    &apos;stylelint-config-standard&apos;,</span><br><span class="line">    &apos;stylelint-config-prettier&apos;,</span><br><span class="line">    &apos;stylelint-config-recommended-less&apos;,</span><br><span class="line">    &apos;stylelint-config-standard-vue&apos;</span><br><span class="line">  ],</span><br><span class="line">  plugins: [&apos;stylelint-order&apos;],</span><br><span class="line">  // 不同格式的文件指定自定义语法</span><br><span class="line">  overrides: [</span><br><span class="line">    &#123;</span><br><span class="line">      files: [&apos;**/*.(less|css|vue|html)&apos;],</span><br><span class="line">      customSyntax: &apos;postcss-less&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      files: [&apos;**/*.(html|vue)&apos;],</span><br><span class="line">      customSyntax: &apos;postcss-html&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  ignoreFiles: [</span><br><span class="line">    &apos;**/*.js&apos;,</span><br><span class="line">    &apos;**/*.jsx&apos;,</span><br><span class="line">    &apos;**/*.tsx&apos;,</span><br><span class="line">    &apos;**/*.ts&apos;,</span><br><span class="line">    &apos;**/*.json&apos;,</span><br><span class="line">    &apos;**/*.md&apos;,</span><br><span class="line">    &apos;**/*.yaml&apos;</span><br><span class="line">  ],</span><br><span class="line">  rules: &#123;</span><br><span class="line">    &apos;no-descending-specificity&apos;: null, // 禁止在具有较高优先级的选择器后出现被其覆盖的较低优先级的选择器</span><br><span class="line">    &apos;selector-pseudo-element-no-unknown&apos;: [</span><br><span class="line">      true,</span><br><span class="line">      &#123;</span><br><span class="line">        ignorePseudoElements: [&apos;v-deep&apos;]</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    &apos;selector-pseudo-class-no-unknown&apos;: [</span><br><span class="line">      true,</span><br><span class="line">      &#123;</span><br><span class="line">        ignorePseudoClasses: [&apos;deep&apos;]</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    // 指定样式的排序</span><br><span class="line">    &apos;order/properties-order&apos;: [</span><br><span class="line">      &apos;position&apos;,</span><br><span class="line">      &apos;top&apos;,</span><br><span class="line">      &apos;right&apos;,</span><br><span class="line">      &apos;bottom&apos;,</span><br><span class="line">      &apos;left&apos;,</span><br><span class="line">      &apos;z-index&apos;,</span><br><span class="line">      &apos;display&apos;,</span><br><span class="line">      &apos;justify-content&apos;,</span><br><span class="line">      &apos;align-items&apos;,</span><br><span class="line">      &apos;float&apos;,</span><br><span class="line">      &apos;clear&apos;,</span><br><span class="line">      &apos;overflow&apos;,</span><br><span class="line">      &apos;overflow-x&apos;,</span><br><span class="line">      &apos;overflow-y&apos;,</span><br><span class="line">      &apos;padding&apos;,</span><br><span class="line">      &apos;padding-top&apos;,</span><br><span class="line">      &apos;padding-right&apos;,</span><br><span class="line">      &apos;padding-bottom&apos;,</span><br><span class="line">      &apos;padding-left&apos;,</span><br><span class="line">      &apos;margin&apos;,</span><br><span class="line">      &apos;margin-top&apos;,</span><br><span class="line">      &apos;margin-right&apos;,</span><br><span class="line">      &apos;margin-bottom&apos;,</span><br><span class="line">      &apos;margin-left&apos;,</span><br><span class="line">      &apos;width&apos;,</span><br><span class="line">      &apos;min-width&apos;,</span><br><span class="line">      &apos;max-width&apos;,</span><br><span class="line">      &apos;height&apos;,</span><br><span class="line">      &apos;min-height&apos;,</span><br><span class="line">      &apos;max-height&apos;,</span><br><span class="line">      &apos;font-size&apos;,</span><br><span class="line">      &apos;font-family&apos;,</span><br><span class="line">      &apos;text-align&apos;,</span><br><span class="line">      &apos;text-justify&apos;,</span><br><span class="line">      &apos;text-indent&apos;,</span><br><span class="line">      &apos;text-overflow&apos;,</span><br><span class="line">      &apos;text-decoration&apos;,</span><br><span class="line">      &apos;white-space&apos;,</span><br><span class="line">      &apos;color&apos;,</span><br><span class="line">      &apos;background&apos;,</span><br><span class="line">      &apos;background-position&apos;,</span><br><span class="line">      &apos;background-repeat&apos;,</span><br><span class="line">      &apos;background-size&apos;,</span><br><span class="line">      &apos;background-color&apos;,</span><br><span class="line">      &apos;background-clip&apos;,</span><br><span class="line">      &apos;border&apos;,</span><br><span class="line">      &apos;border-style&apos;,</span><br><span class="line">      &apos;border-width&apos;,</span><br><span class="line">      &apos;border-color&apos;,</span><br><span class="line">      &apos;border-top-style&apos;,</span><br><span class="line">      &apos;border-top-width&apos;,</span><br><span class="line">      &apos;border-top-color&apos;,</span><br><span class="line">      &apos;border-right-style&apos;,</span><br><span class="line">      &apos;border-right-width&apos;,</span><br><span class="line">      &apos;border-right-color&apos;,</span><br><span class="line">      &apos;border-bottom-style&apos;,</span><br><span class="line">      &apos;border-bottom-width&apos;,</span><br><span class="line">      &apos;border-bottom-color&apos;,</span><br><span class="line">      &apos;border-left-style&apos;,</span><br><span class="line">      &apos;border-left-width&apos;,</span><br><span class="line">      &apos;border-left-color&apos;,</span><br><span class="line">      &apos;border-radius&apos;,</span><br><span class="line">      &apos;opacity&apos;,</span><br><span class="line">      &apos;filter&apos;,</span><br><span class="line">      &apos;list-style&apos;,</span><br><span class="line">      &apos;outline&apos;,</span><br><span class="line">      &apos;visibility&apos;,</span><br><span class="line">      &apos;box-shadow&apos;,</span><br><span class="line">      &apos;text-shadow&apos;,</span><br><span class="line">      &apos;resize&apos;,</span><br><span class="line">      &apos;transition&apos;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="package-json增加命令"><a href="#package-json增加命令" class="headerlink" title="package.json增加命令"></a>package.json增加命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;prepare&quot;: &quot;husky install&quot;,</span><br><span class="line">    &quot;dev&quot;: &quot;vite&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;vue-tsc --noEmit &amp;&amp; vite build&quot;,</span><br><span class="line">    &quot;preview&quot;: &quot;vite preview&quot;,</span><br><span class="line">    &quot;lint&quot;: &quot;eslint . --ext .vue,.js,.ts,.jsx,.tsx --fix&quot;,</span><br><span class="line">    &quot;format&quot;: &quot;prettier --write \&quot;./**/*.&#123;html,vue,ts,js,json,md&#125;\&quot;&quot;,</span><br><span class="line">+   &quot;lint:style&quot;: &quot;stylelint \&quot;./**/*.&#123;css,less,vue,html&#125;\&quot; --fix&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="安装vscode的Stylelint插件"><a href="#安装vscode的Stylelint插件" class="headerlink" title="安装vscode的Stylelint插件"></a>安装vscode的Stylelint插件</h2><p>安装该插件可在我们保存代码时自动执行stylelint</p><p>在.vscode/settings.json中添加一下规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // 开启自动修复</span><br><span class="line">  &quot;editor.codeActionsOnSave&quot;: &#123;</span><br><span class="line">    &quot;source.fixAll&quot;: false,</span><br><span class="line">    &quot;source.fixAll.eslint&quot;: true,</span><br><span class="line">+   &quot;source.fixAll.stylelint&quot;: true</span><br><span class="line">  &#125;,</span><br><span class="line">  // 保存的时候自动格式化</span><br><span class="line">  &quot;editor.formatOnSave&quot;: true,</span><br><span class="line">  // 默认格式化工具选择prettier</span><br><span class="line">  &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;,</span><br><span class="line">  // 配置该项，新建文件时默认就是space：2</span><br><span class="line">  &quot;editor.tabSize&quot;: 2,</span><br><span class="line">  // stylelint校验的文件格式</span><br><span class="line">+ &quot;stylelint.validate&quot;: [&quot;css&quot;, &quot;less&quot;, &quot;vue&quot;, &quot;html&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="配置husky"><a href="#配置husky" class="headerlink" title="配置husky"></a>配置husky</h1><p>虽然上面已经配置好了eslint、preitter与stylelint，但是还是存在以下问题。</p><p>对于不使用vscode的，或者没有安装eslint、preitter与stylelint插件的同学来说，就不能实现在保存的时候自动的去修复与和格式化代码。</p><p>这样提交到git仓库的代码还是不符合要求的。因此需要引入强制的手段来保证提交到git仓库的代码时符合我们的要求的。</p><p>husky是一个用来管理git hook的工具，git hook即在我们使用git提交代码的过程中会触发的钩子。</p><h2 id="安装依赖-2"><a href="#安装依赖-2" class="headerlink" title="安装依赖"></a>安装依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm add husky -D</span><br></pre></td></tr></table></figure><h2 id="在package-json中的script中添加一条脚本命令"><a href="#在package-json中的script中添加一条脚本命令" class="headerlink" title="在package.json中的script中添加一条脚本命令"></a>在package.json中的script中添加一条脚本命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;scripts&quot;: &#123;</span><br><span class="line">        &quot;prepare&quot;: &quot;husky install&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该命令会在npm install之后运行，这样其他克隆该项目的同学就在装包的时候就会自动执行该命令来安装husky。这里我们就不重新执行npm install了，直接执行npm prepare，这个时候你会发现多了一个.husky目录。</p><p>然后使用husky命令添加pre-commit钩子，运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm husky add .husky/pre-commit &quot;npm lint &amp;&amp; npm format &amp;&amp; npm lint:style&quot;</span><br></pre></td></tr></table></figure><p>执行完上面的命令后，会在.husky目录下生成一个pre-commit文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env sh</span><br><span class="line">. &quot;$(dirname -- &quot;$0&quot;)/_/husky.sh&quot;</span><br><span class="line"></span><br><span class="line">npm lint &amp;&amp; npm format</span><br></pre></td></tr></table></figure><p>现在当我们执行git commit的时候就会执行npm lint与npm format，当这两条命令出现报错，就不会提交成功。以此来保证提交代码的质量和格式。</p><h1 id="配置Commitlint"><a href="#配置Commitlint" class="headerlink" title="配置Commitlint"></a>配置Commitlint</h1><h2 id="为什么要用Commitlint"><a href="#为什么要用Commitlint" class="headerlink" title="为什么要用Commitlint"></a>为什么要用Commitlint</h2><p>在使用Git提交代码时，通常都需要填写提交说明，也就是Commit Message。在前面的文章中，已经介绍了如何使用Commitizen或可视化工具编写符合规范的Commit Message。然而有些同学可能还是会使用git commit方式提交一些不符合规范的Commit Message。为了禁止不符合规范的Commit Message的提交，我们就需要采用一些工具，只有当开发者编写了符合规范的Commit Message才能够进行commit。而 Commitlint就是这样一种工具，通过结合husky一起使用，可以在开发者进行commit前就对Commit Message进行检查，只有符合规范，才能够进行commit。</p><h2 id="安装Commitlint"><a href="#安装Commitlint" class="headerlink" title="安装Commitlint"></a>安装Commitlint</h2><p>使用npm安装Commitlint相关依赖包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @commitlint/cli @commitlint/config-conventional --save-dev</span><br></pre></td></tr></table></figure><h2 id="配置Commitlint-1"><a href="#配置Commitlint-1" class="headerlink" title="配置Commitlint"></a>配置Commitlint</h2><p>安装好Commitlint之后，就需要配置Commitlint，可以在根目录创建commitlint.config.js文件进行配置。</p><p>在comminlint.config.js中加入以下代码，表示使用config-conventional规范对提交说明进行检查。具体的规范配置可以查看： <a href="https://github.com/conventional-changelog/commitlint" target="_blank" rel="noopener">https://github.com/conventional-changelog/commitlint</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123; extends: [&apos;@commitlint/config-conventional&apos;] &#125;;</span><br></pre></td></tr></table></figure><p>接下来，需要在package.json中加入commit-msg钩子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;husky&quot;: &#123;</span><br><span class="line">  &quot;hooks&quot;: &#123;</span><br><span class="line">    &quot;commit-msg&quot;: &quot;commitlint -E HUSKY_GIT_PARAMS&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置好了之后，当我们进行git commit时，就会触发commit-msg钩子，执行commintlint命令，并且读取commitlint.config.js中的规则对我们的提交说明进行检查，如果校验不通过，将不能提交。</p><h1 id="配置Lint-staged"><a href="#配置Lint-staged" class="headerlink" title="配置Lint-staged"></a>配置Lint-staged</h1><h2 id="什么是Lint-staged"><a href="#什么是Lint-staged" class="headerlink" title="什么是Lint-staged"></a>什么是Lint-staged</h2><p> Lint-staged可以在git staged阶段的文件上执行Linters，简单说就是当我们运行ESlint或Stylelint命令时，可以通过设置指定只检查我们通过git add添加到暂存区的文件，可以避免我们每次检查都把整个项目的代码都检查一遍，从而提高效率。</p><p>其次，Lint-staged允许指定不同类型后缀文件执行不同指令的操作，并且可以按步骤再额外执行一些其它shell指令。</p><h2 id="安装Lint-staged"><a href="#安装Lint-staged" class="headerlink" title="安装Lint-staged"></a>安装Lint-staged</h2><p>安装Lint-staged，可以使用npm进行安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install lint-staged --save-dev</span><br></pre></td></tr></table></figure><h2 id="配置Lint-staged-1"><a href="#配置Lint-staged-1" class="headerlink" title="配置Lint-staged"></a>配置Lint-staged</h2><p>安装好了Lint-staged之后，就需要配置Lint-staged。我们可以在package.json中加入以下代码，这里需要先安装配置好husky，ESLint和Stylelint。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&quot;husky&quot;: &#123;</span><br><span class="line">  &quot;hooks&quot;: &#123;</span><br><span class="line">    &quot;pre-commit&quot;: &quot;lint-staged&quot;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;lint-staged&quot;: &#123;</span><br><span class="line">  &quot;*.vue&quot;: [</span><br><span class="line">    &quot;eslint --fix&quot;,</span><br><span class="line">    &quot;stylelint --fix&quot;,</span><br><span class="line">    &quot;git add&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;*.&#123;js,jsx,ts,tsx&#125;&quot;: [</span><br><span class="line">    &quot;eslint --fix&quot;,</span><br><span class="line">    &quot;git add&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;*.&#123;htm,html,css,sss,less,scss,sass&#125;&quot;: [</span><br><span class="line">    &quot;stylelint --fix&quot;,</span><br><span class="line">    &quot;git add&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>接下来，我们就可以将这几个工具结合起来，打造完整的Git检查工作流。下面给出了一份示例代码，其中，该项目采用了Vue-cli进行构建，下面是该项目对应的package.json文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;test&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.1.0&quot;,</span><br><span class="line">  &quot;private&quot;: true,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;serve&quot;: &quot;vue-cli-service serve&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;vue-cli-service build&quot;,</span><br><span class="line">    &quot;lint&quot;: &quot;vue-cli-service lint&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;core-js&quot;: &quot;^3.6.5&quot;,</span><br><span class="line">    &quot;vue&quot;: &quot;^2.6.11&quot;,</span><br><span class="line">    &quot;vue-router&quot;: &quot;^3.2.0&quot;,</span><br><span class="line">    &quot;vuex&quot;: &quot;^3.4.0&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;@commitlint/cli&quot;: &quot;^12.1.4&quot;,</span><br><span class="line">    &quot;@commitlint/config-conventional&quot;: &quot;^12.1.4&quot;,&quot;@vue/cli-plugin-babel&quot;: &quot;^4.5.0&quot;,</span><br><span class="line">    &quot;@vue/cli-plugin-eslint&quot;: &quot;^4.5.0&quot;,</span><br><span class="line">    &quot;@vue/cli-service&quot;: &quot;^4.5.0&quot;,</span><br><span class="line">    &quot;@vue/eslint-config-prettier&quot;: &quot;^6.0.0&quot;,</span><br><span class="line">    &quot;babel-eslint&quot;: &quot;^10.1.0&quot;,</span><br><span class="line">    &quot;eslint&quot;: &quot;^6.7.2&quot;,</span><br><span class="line">    &quot;eslint-plugin-prettier&quot;: &quot;^3.3.1&quot;,</span><br><span class="line">    &quot;eslint-plugin-vue&quot;: &quot;^6.2.2&quot;,</span><br><span class="line">    &quot;husky&quot;: &quot;^4.3.8&quot;,</span><br><span class="line">    &quot;less&quot;: &quot;^3.0.4&quot;,</span><br><span class="line">    &quot;less-loader&quot;: &quot;^5.0.0&quot;,</span><br><span class="line">    &quot;lint-staged&quot;: &quot;^11.0.0&quot;,</span><br><span class="line">    &quot;prettier&quot;: &quot;^2.2.1&quot;,</span><br><span class="line">    &quot;stylelint&quot;: &quot;^13.13.1&quot;,</span><br><span class="line">    &quot;stylelint-config-prettier&quot;: &quot;^8.0.2&quot;,&quot;stylelint-config-standard&quot;: &quot;^22.0.0&quot;,</span><br><span class="line">    &quot;stylelint-order&quot;: &quot;^4.1.0&quot;,</span><br><span class="line">    &quot;stylelint-webpack-plugin&quot;: &quot;^2.2.2&quot;,</span><br><span class="line">    &quot;vue-template-compiler&quot;: &quot;^2.6.11&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;husky&quot;: &#123;</span><br><span class="line">    &quot;hooks&quot;: &#123;</span><br><span class="line">      &quot;pre-commit&quot;: &quot;lint-staged&quot;,</span><br><span class="line">      &quot;commit-msg&quot;: &quot;commitlint -E HUSKY_GIT_PARAMS&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;lint-staged&quot;: &#123;</span><br><span class="line">    &quot;*.vue&quot;: [</span><br><span class="line">      &quot;vue-cli-service lint&quot;,</span><br><span class="line">      &quot;stylelint --fix&quot;,</span><br><span class="line">      &quot;git add&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;*.&#123;js,jsx,ts,tsx&#125;&quot;: [</span><br><span class="line">      &quot;vue-cli-service lint&quot;</span><br><span class="line">      &quot;git add&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;*.&#123;htm,html,css,sss,less,scss,saas&#125;&quot;:[</span><br><span class="line">      &quot;stylelint --fix&quot;</span><br><span class="line">      &quot;git add&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置好package.json之后，当我们进行git commit提交时，首先将会触发pre-commit钩子，调用lint-staged命令，并且会对不同后缀的文件执行不同的检查。接着，还将会触发commit-msg钩子，调用commitlint对我们的提交说明进行检查。如果其中一个无法通过检查，将无法提交。</p><p>当校验通过时，就可以放心的将代码提交到代码仓库里。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;你是否会遇到提交代码时，没有改到同事业务模块的任何一行代码，却被提示冲突？提交注释凌乱看不懂的情况？等等。&lt;/p&gt;
&lt;p&gt;那么为了项目代码风格统一，代码格式化规范统一，避免代码冲突，提高代码的规范性，提高CodeReview效率等等。因此结合Eslint + Prettier + Husky + Commitlint+ Lint-staged的前端工程化规范应运而生，最终提升了我们开发效率、项目质量。&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="https://tangyanqiong.com/categories/Web/"/>
    
      <category term="JS" scheme="https://tangyanqiong.com/categories/Web/JS/"/>
    
    
      <category term="JavaScript" scheme="https://tangyanqiong.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JS扁平数据结构转Tree</title>
    <link href="https://tangyanqiong.com/post/6033d016.html"/>
    <id>https://tangyanqiong.com/post/6033d016.html</id>
    <published>2021-08-01T11:05:33.000Z</published>
    <updated>2022-07-23T16:59:06.300Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>假如后台返回一个扁平的数据结构，转成树，应该怎么做呢？</p><p>打平的数据内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let arr = [</span><br><span class="line">    &#123;id: 1, name: &apos;部门1&apos;, pid: 0&#125;,</span><br><span class="line">    &#123;id: 2, name: &apos;部门2&apos;, pid: 1&#125;,</span><br><span class="line">    &#123;id: 3, name: &apos;部门3&apos;, pid: 1&#125;,</span><br><span class="line">    &#123;id: 4, name: &apos;部门4&apos;, pid: 3&#125;,</span><br><span class="line">    &#123;id: 5, name: &apos;部门5&apos;, pid: 4&#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><a id="more"></a><p>期望输出的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;id&quot;: 1,</span><br><span class="line">        &quot;name&quot;: &quot;部门1&quot;,</span><br><span class="line">        &quot;pid&quot;: 0,</span><br><span class="line">        &quot;children&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;id&quot;: 2,</span><br><span class="line">                &quot;name&quot;: &quot;部门2&quot;,</span><br><span class="line">                &quot;pid&quot;: 1,</span><br><span class="line">                &quot;children&quot;: []</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;id&quot;: 3,</span><br><span class="line">                &quot;name&quot;: &quot;部门3&quot;,</span><br><span class="line">                &quot;pid&quot;: 1,</span><br><span class="line">                &quot;children&quot;: [</span><br><span class="line">                    // 结果 ,,,</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>假如先不用考虑性能问题，实现功能即可。</p><p>可能10%的人没思路，没碰到过这种结构；60%的人说用过递归，有思路，给他个笔记本，但就是写不出来；20%的人在引导下，磕磕绊绊能写出来；剩下10%的人能写出来，但性能不是最佳。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>接下来，我们用几种方法来实现这个小算法</p><h2 id="什么是好算法，什么是坏算法"><a href="#什么是好算法，什么是坏算法" class="headerlink" title="什么是好算法，什么是坏算法"></a>什么是好算法，什么是坏算法</h2><p>判断一个算法的好坏，一般从<strong>执行时间</strong>和<strong>占用空间</strong>来看,执行时间越短，占用的内存空间越小，那么它就是好的算法。对应的，我们常常用时间复杂度代表执行时间，空间复杂度代表占用的内存空间。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间复杂度的计算并不是计算程序具体运行的时间，而是算法执行语句的次数。 随着<strong>n</strong>的不断<strong>增大</strong>，时间复杂度不断<strong>增大</strong>，算法<strong>花费时间</strong>越多。 </p><p>常见的时间复杂度有：</p><ul><li>常数阶O(1)</li><li>对数阶O(log2 n)</li><li>线性阶O(n)</li><li>线性对数阶O(n log2 n)</li><li>平方阶O(n^2)</li><li>立方阶O(n^3)</li><li>k次方阶O(n^K)</li><li>指数阶O(2^n)</li></ul><h3 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h3><ol><li>选取相对增长最高的项</li><li>最高项系数是都化为1</li><li>若是常数的话用O(1)表示 举个例子：如f(n)=3*n^4+3n+300 则 O(n)=n^4</li></ol><p>通常我们计算时间复杂度都是计算最坏情况。计算时间复杂度的要注意的几个点</p><ul><li>如果算法的执行时间不随n的增加而增长，假如算法中有上千条语句，执行时间也不过是一个较大的常数。此类算法的时间复杂度是O(1)。 举例如下：代码执行100次，是一个常数，复杂度也是O(1)。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let x = 1;</span><br><span class="line">while (x &lt;100) &#123;</span><br><span class="line"> x++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>有多个循环语句时候，算法的时间复杂度是由嵌套层数最多的循环语句中最内层语句的方法决定的。举例如下：在下面for循环当中，外层循环每执行一次，内层循环要执行n次，执行次数是根据n所决定的，时间复杂度是O(n^2)。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (i = 0; i &lt; n; i++)&#123;</span><br><span class="line">       for (j = 0; j &lt; n; j++) &#123;</span><br><span class="line">           // ...code</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>循环不仅与n有关，还与执行循环判断条件有关。举例如下：在代码中，如果arr[i]不等于1的话，时间复杂度是O(n)。如果arr[i]等于1的话，循环不执行，时间复杂度是O(0)。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(var i = 0; i&lt;n &amp;&amp; arr[i] !=1; i++) &#123;</span><br><span class="line">// ...code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>空间复杂度是对一个算法在运行过程中临时占用存储空间的大小。</p><h3 id="计算方法-1"><a href="#计算方法-1" class="headerlink" title="计算方法"></a>计算方法</h3><ol><li>忽略常数，用O(1)表示</li><li>递归算法的空间复杂度=(递归深度n)*(每次递归所要的辅助空间)<br>计算空间复杂度的简单几点</li></ol><ul><li>仅仅只复制单个变量，空间复杂度为O(1)。举例如下：空间复杂度为O(n) = O(1)。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a = 1;</span><br><span class="line">let b = 2;</span><br><span class="line">let c = 3;</span><br><span class="line">console.log(&apos;输出a,b,c&apos;, a, b, c);</span><br></pre></td></tr></table></figure><ul><li>递归实现，调用fun函数，每次都创建1个变量k。调用n次，空间复杂度O(n*1) = O(n)。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function fun(n) &#123;</span><br><span class="line">   let k = 10;</span><br><span class="line">   if (n == k) &#123;</span><br><span class="line">       return n;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       return fun(++n)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不考虑性能实现，递归遍历查找"><a href="#不考虑性能实现，递归遍历查找" class="headerlink" title="不考虑性能实现，递归遍历查找"></a>不考虑性能实现，递归遍历查找</h2><p>主要思路是提供一个递getChildren的方法，该方法递归去查找子集。 就这样，不用考虑性能，无脑去查，大多数人只知道递归，就是写不出来。。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 递归查找，获取children</span><br><span class="line"> */</span><br><span class="line">const getChildren = (data, result, pid) =&gt; &#123;</span><br><span class="line">  for (const item of data) &#123;</span><br><span class="line">    if (item.pid === pid) &#123;</span><br><span class="line">      const newItem = &#123;...item, children: []&#125;;</span><br><span class="line">      result.push(newItem);</span><br><span class="line">      getChildren(data, newItem.children, item.id);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 转换方法</span><br><span class="line">*/</span><br><span class="line">const arrayToTree = (data, pid) =&gt; &#123;</span><br><span class="line">  const result = [];</span><br><span class="line">  getChildren(data, result, pid)</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码我们分析，该实现的时间复杂度为O(2^n)。</p><h2 id="不用递归，也能搞定"><a href="#不用递归，也能搞定" class="headerlink" title="不用递归，也能搞定"></a>不用递归，也能搞定</h2><p>主要思路是先把数据转成Map去存储，之后遍历的同时借助对象的引用，直接从Map找对应的数据做存储</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function arrayToTree(items) &#123;</span><br><span class="line">  const result = [];   // 存放结果集</span><br><span class="line">  const itemMap = &#123;&#125;;  // </span><br><span class="line">    </span><br><span class="line">  // 先转成map存储</span><br><span class="line">  for (const item of items) &#123;</span><br><span class="line">    itemMap[item.id] = &#123;...item, children: []&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  for (const item of items) &#123;</span><br><span class="line">    const id = item.id;</span><br><span class="line">    const pid = item.pid;</span><br><span class="line">    const treeItem =  itemMap[id];</span><br><span class="line">    if (pid === 0) &#123;</span><br><span class="line">      result.push(treeItem);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      if (!itemMap[pid]) &#123;</span><br><span class="line">        itemMap[pid] = &#123;</span><br><span class="line">          children: [],</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      itemMap[pid].children.push(treeItem)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码我们分析，有两次循环，该实现的时间复杂度为O(2n)，需要一个Map把数据存储起来，空间复杂度O(n)</p><h2 id="最优性能"><a href="#最优性能" class="headerlink" title="最优性能"></a>最优性能</h2><p>主要思路也是先把数据转成Map去存储，之后遍历的同时借助对象的引用，直接从Map找对应的数据做存储。不同点在遍历的时候即做Map存储,有找对应关系。性能会更好。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">function arrayToTree(items) &#123;</span><br><span class="line">  const result = [];   // 存放结果集</span><br><span class="line">  const itemMap = &#123;&#125;;  // </span><br><span class="line">  for (const item of items) &#123;</span><br><span class="line">    const id = item.id;</span><br><span class="line">    const pid = item.pid;</span><br><span class="line"></span><br><span class="line">    if (!itemMap[id]) &#123;</span><br><span class="line">      itemMap[id] = &#123;</span><br><span class="line">        children: [],</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    itemMap[id] = &#123;</span><br><span class="line">      ...item,</span><br><span class="line">      children: itemMap[id][&apos;children&apos;]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const treeItem =  itemMap[id];</span><br><span class="line"></span><br><span class="line">    if (pid === 0) &#123;</span><br><span class="line">      result.push(treeItem);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      if (!itemMap[pid]) &#123;</span><br><span class="line">        itemMap[pid] = &#123;</span><br><span class="line">          children: [],</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      itemMap[pid].children.push(treeItem)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码我们分析，一次循环就搞定了，该实现的时间复杂度为O(n)，需要一个Map把数据存储起来，空间复杂度O(n)</p><h2 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h2><p>方法         1000(条)      10000(条）    20000(条）       50000(条)</p><p>递归实现   154.596ms    1.678s         7.152s               75.412s</p><p>不用递归，两次遍历   0.793ms     16.499ms      45.581ms     97.373ms</p><p>不用递归，一次遍历    0.639ms     6.397ms    25.436ms    44.719ms</p><p><strong>从我们的测试结果来看，随着数量的增大，递归的实现会越来越慢，基本成指数的增长方式。</strong></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>实践出真理，大家共勉进步。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;假如后台返回一个扁平的数据结构，转成树，应该怎么做呢？&lt;/p&gt;
&lt;p&gt;打平的数据内容如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let arr = [&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;id: 1, name: &amp;apos;部门1&amp;apos;, pid: 0&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;id: 2, name: &amp;apos;部门2&amp;apos;, pid: 1&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;id: 3, name: &amp;apos;部门3&amp;apos;, pid: 1&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;id: 4, name: &amp;apos;部门4&amp;apos;, pid: 3&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;id: 5, name: &amp;apos;部门5&amp;apos;, pid: 4&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Web" scheme="https://tangyanqiong.com/categories/Web/"/>
    
      <category term="JS" scheme="https://tangyanqiong.com/categories/Web/JS/"/>
    
    
      <category term="JavaScript" scheme="https://tangyanqiong.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>浏览器输入url到页面渲染过程</title>
    <link href="https://tangyanqiong.com/post/7429757f.html"/>
    <id>https://tangyanqiong.com/post/7429757f.html</id>
    <published>2020-08-28T11:05:33.000Z</published>
    <updated>2022-07-22T13:14:14.232Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>相信很多人都会被面试到一道比较综合的面试题，答案也不是固定的，从浏览器输入地址到页面渲染经过了很多的过程，且每个过程都可以深挖出很多知识点，面试官可以用这一道题区分出不同面试者的水平。下面我们就来具体学习下。</p><p><strong>构建请求</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET/HTTP/1.1;</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="查找强缓存"><a href="#查找强缓存" class="headerlink" title="查找强缓存"></a>查找强缓存</h2><p>浏览器会先检查是否存在缓存，如果存在缓存就直接从缓存里面拿数据，给到浏览器进行渲染</p><h2 id="DNS-解析"><a href="#DNS-解析" class="headerlink" title="DNS 解析"></a>DNS 解析</h2><p>由于我们输入的是域名，而数据包是通过 IP 地址传给对方的。因此我们需要得到域名对应的 IP 地址。这个过程需要依赖一个服务系统，这个系统将域名和 IP 一一映射，我们将这个系统就叫做 DNS（域名系统）。得到具体 IP 的过程就是 DNS 解析。 当然，值得注意的是，浏览器提供了 DNS 数据缓存功能。即如果一个域名已经解析过，那会把解析的结果缓存下来，下次处理直接走缓存，不需要经过 DNS 解析</p><h2 id="建立-TCP-连接"><a href="#建立-TCP-连接" class="headerlink" title="建立 TCP 连接"></a>建立 TCP 连接</h2><p>建立 TCP 连接经历了下面三个阶段</p><ul><li>通过三次握手(即总共发送 3 个数据包确认已经建立连接)建立客户端和服务器之间的连接。</li><li>进行数据传输。这里有一个重要的机制，就是接收方接收到数据包后必须要向发送方确认, 如果发送方没有接到这个确认的消息，就判定为数据包丢失，并重新发送该数据包。当然，发送的过程中还有一个优化策略，就是把大的数据包拆成一个个小包，依次传输到接收方，接收方按照这个小包的顺序把它们组装成完整数据包。</li><li>断开连接的阶段。数据传输完成，现在要断开连接了，通过四次挥手来断开连接。</li></ul><p>TCP 就是通过三次握手确认连接，数据包校验保证数据到达接收方，然后通过四次挥手断开连接保证数据传输的可靠性</p><h2 id="发送-HTTP-请求"><a href="#发送-HTTP-请求" class="headerlink" title="发送 HTTP 请求"></a>发送 HTTP 请求</h2><p>现在 TCP 连接建立完毕，浏览器可以和服务器开始通信，即开始发送 HTTP 请求。浏览器发 HTTP 请求要携带三样东西:请求行、请求头和请求体</p><h2 id="网络响应"><a href="#网络响应" class="headerlink" title="网络响应"></a>网络响应</h2><p>HTTP 请求到达服务器，服务器进行对应的处理。最后要把数据传给浏览器，也就是返回网络响应。</p><p>响应头包含了服务器及其返回数据的一些信息, 服务器生成数据的时间、返回的数据类型以及对即将写入的 Cookie 信息。如果请求头或响应头中包含 Connection: Keep-Alive，表示建立了持久连接，这样 TCP 连接会一直保持，之后请求统一站点的资源会复用这个连接。</p><h2 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a>页面渲染</h2><p>完成以上过程后，数据已经达到浏览器端，接下来就是浏览器解析并渲染数据了</p><h2 id="解析过程"><a href="#解析过程" class="headerlink" title="解析过程"></a>解析过程</h2><ol><li>构建 DOM 树</li></ol><p>由于浏览器无法直接理解 HTML 字符串，因此将这一系列的字节流转换为一种有意义并且方便操作的数据结构，这种数据结构就是 DOM 树。DOM 树本质上是一个以 document 为根节点的多叉树</p><ol start="2"><li>样式计算</li></ol><p>首先，浏览器是无法直接识别 CSS 样式文本的，因此渲染引擎接收到 CSS 文本之后第一件事情就是将其转化为一个结构化的对象，即 styleSheets。 这个格式化的过程过于复杂，而且对于不同的浏览器会有不同的优化策略，这里就不展开了。 在浏览器控制台能够通过 document.styleSheets 来查看这个最终的结构。当然，这个结构包含了以上三种 CSS 来源，为后面的样式操作提供了基础。</p><ol start="3"><li>生成布局树</li></ol><p>现在已经生成了 DOM 树和 DOM 样式，接下来要做的就是通过浏览器的布局系统确定元素的位置，也就是要生成一棵布局树(Layout Tree)。 布局树生成的大致工作如下:</p><ul><li>遍历生成的 DOM 树节点，并把他们添加到布局树中；</li><li>计算布局树节点的坐标位置。</li></ul><p>值得注意的是，布局树只包含可见元素，对于 head 标签和设置了 display: none 的元素，将不会被放入其中。</p><h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><ol><li>构建 DOM 树</li></ol><p>浏览器将 HTML 解析成树形结构的 DOM 树，一般来说，这个过程发生在页面初次加载，或页面 JavaScript 修改了节点结构的时候</p><ol start="2"><li>构建渲染树</li></ol><p>浏览器将 CSS 解析成树形结构的 CSSOM 树，再和 DOM 树合并成渲染树</p><ol start="3"><li>布局（Layout）</li></ol><p>浏览器根据渲染树所体现的节点、各个节点的 CSS 定义以及它们的从属关系，计算出每个节点在屏幕中的位置。Web 页面中元素的布局是相对的，在页面元素位置、大小发生变化，往往会导致其他节点联动，需要重新计算布局，这时候的布局过程一般被称为回流（Reflow）。</p><ol start="4"><li>绘制（Paint）</li></ol><p>遍历渲染树，调用渲染器的 paint() 方法在屏幕上绘制出节点内容，本质上是一个像素填充的过程。这个过程也出现于回流或一些不影响布局的 CSS 修改引起的屏幕局部重画，这时候它被称为重绘（Repaint）。实际上，绘制过程是在多个层上完成的，这些层我们称为 渲染层（RenderLayer）</p><ol start="5"><li>渲染层合成（Composite）</li></ol><p>多个绘制后的渲染层按照恰当的重叠顺序进行合并，而后生成位图，最终通过显卡展示到屏幕上。</p><p><strong>那什么是渲染层合成呢？</strong></p><p>在 DOM 树中每个节点都会对应一个渲染对象（RenderObject），当它们的渲染对象处于相同的坐标空间（z 轴空间）时，就会形成一个 RenderLayers，也就是渲染层。渲染层将保证页面元素以正确的顺序堆叠，这时候就会出现层合成（composite），从而正确处理透明元素和重叠元素的显示。 这个模型类似于 Photoshop 的图层模型，在 Photoshop 中，每个设计元素都是一个独立的图层，多个图层以恰当的顺序在 z 轴空间上叠加，最终构成一个完整的设计图。 对于有位置重叠的元素的页面，这个过程尤其重要，因为一旦图层的合并顺序出错，将会导致元素显示异常。</p><ol start="6"><li>显示器显示内容</li></ol><p>栅格化操作完成后，合成线程会生成一个绘制命令，即”DrawQuad”，并发送给浏览器进程。 浏览器进程中的 viz 组件接收到这个命令，根据这个命令把页面内容绘制到内存，也就是生成了页面，然后把这部分内存发送给显卡，从而展示在屏幕上。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>从浏览器的渲染过程中我们知道，页面 HTML 会被解析成 DOM 树，每个 HTML 元素对应了树结构上的一个 node 节点。而从 DOM 树转化到一个个的渲染层，并最终执行合并、绘制的过程，中间其实还存在一些过渡的数据结构，它们记录了 DOM 树到屏幕图形的转化原理，其本质也就是树结构到层结构的演化。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;相信很多人都会被面试到一道比较综合的面试题，答案也不是固定的，从浏览器输入地址到页面渲染经过了很多的过程，且每个过程都可以深挖出很多知识点，面试官可以用这一道题区分出不同面试者的水平。下面我们就来具体学习下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;构建请求&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;GET/HTTP/1.1;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Web" scheme="https://tangyanqiong.com/categories/Web/"/>
    
      <category term="JS" scheme="https://tangyanqiong.com/categories/Web/JS/"/>
    
    
      <category term="JavaScript" scheme="https://tangyanqiong.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>vue3双向数据绑定原理</title>
    <link href="https://tangyanqiong.com/post/acef5003.html"/>
    <id>https://tangyanqiong.com/post/acef5003.html</id>
    <published>2020-07-18T12:25:45.000Z</published>
    <updated>2022-07-23T15:52:20.496Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>什么是双向数据绑定，这里就不做赘述了，vue的双向数据绑定是什么大家都很了解了，这里主要讲vue2和vue3中双向绑定的区别。</p><p>vue2中使用“Object.defineProperty”对象以及对象属性的劫持实现双向绑定；而vue3中的响应式采用了ES6中的“Proxy”方法实现双向绑定。</p><a id="more"></a><h1 id="为什么要替换vue2的双向数据绑定"><a href="#为什么要替换vue2的双向数据绑定" class="headerlink" title="为什么要替换vue2的双向数据绑定"></a>为什么要替换vue2的双向数据绑定</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>关于对象： Vue 无法检测 property 的添加或移除。<br>关于数组：不能利用索引直接设置一个数组项,也不能修改数组的长度。</p><p>总结来说Object.defineProperty方法存在一定的局限性</p><ol><li>在Vue中，Object.defineProperty无法监控到数组下标的变化，导致直接通过数组的下标给数组设置值，不能实时响应。 为了解决这个问题，经过vue内部处理后可以使用以下几种方法来监听数组（ Vue为什么不能检测数组变动）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">push()</span><br><span class="line">pop()</span><br><span class="line">shift()</span><br><span class="line">unshift()</span><br><span class="line">splice()</span><br><span class="line">sort()</span><br><span class="line">reverse()</span><br></pre></td></tr></table></figure><ol start="2"><li>Object.defineProperty只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历。Vue里，是通过递归以及遍历data对象来实现对数据的监控的，如果属性值也是对象那么需要深度遍历,显然如果能劫持一个完整的对象，不管是对操作性还是性能都会有一个很大的提升。</li></ol><h1 id="vue3双向绑定原理"><a href="#vue3双向绑定原理" class="headerlink" title="vue3双向绑定原理"></a>vue3双向绑定原理</h1><h2 id="什么是Proxy"><a href="#什么是Proxy" class="headerlink" title="什么是Proxy"></a>什么是Proxy</h2><p>Proxy 是ES6中新增的一个特性，可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p><p>基本用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。</span><br><span class="line">var proxy = new Proxy(target, handler);</span><br></pre></td></tr></table></figure><p>参数解释</p><ol><li>target: 是用Proxy包装的被代理对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。</li><li>handler: 是一个对象，其声明了代理target 的一些操作，其属性是当执行一个操作时定义代理的行为的函数。<br>Proxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法</li></ol><h2 id="Proxy的13种拦截"><a href="#Proxy的13种拦截" class="headerlink" title="Proxy的13种拦截"></a>Proxy的13种拦截</h2><ul><li>get(target, propKey, receiver)：拦截对象属性的读取，比如proxy.foo和proxy[‘foo’]。</li><li>set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo = v或proxy[‘foo’] = v，返回一个布尔值。</li><li>has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值。</li><li>deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值。</li><li>ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for…in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。</li><li>getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。</li><li>defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。</li><li>preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值。</li><li>getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象。</li><li>isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值。</li><li>setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</li><li>apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。</li><li>construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。</li></ul><p><strong>例子</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// #注：Proxy 实例也可以作为其他对象的原型对象。</span><br><span class="line">var proxy = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  get: function(target, property) &#123;</span><br><span class="line">    return 35;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">let obj = Object.create(proxy);</span><br><span class="line">obj.time // 35</span><br><span class="line"></span><br><span class="line">var handler = &#123;</span><br><span class="line">  get: function(target, name) &#123;</span><br><span class="line">    if (name === &apos;prototype&apos;) &#123;</span><br><span class="line">      return Object.prototype;</span><br><span class="line">    &#125;</span><br><span class="line">    return &apos;Hello, &apos; + name;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  apply: function(target, thisBinding, args) &#123;</span><br><span class="line">    return args[0];</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  construct: function(target, args) &#123;</span><br><span class="line">    return &#123;value: args[1]&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var fproxy = new Proxy(function(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;, handler);</span><br><span class="line"></span><br><span class="line">fproxy(1, 2) // 1</span><br><span class="line">new fproxy(1, 2) // &#123;value: 2&#125;</span><br><span class="line">fproxy.prototype === Object.prototype // true</span><br><span class="line">fproxy.foo === &quot;Hello, foo&quot; // true</span><br></pre></td></tr></table></figure><h2 id="Proxy实现数据劫持"><a href="#Proxy实现数据劫持" class="headerlink" title="Proxy实现数据劫持"></a>Proxy实现数据劫持</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">observe(data) &#123;</span><br><span class="line">  const that = this;</span><br><span class="line">  let handler = &#123;</span><br><span class="line">   get(target, property) &#123;</span><br><span class="line">      return target[property];</span><br><span class="line">    &#125;,</span><br><span class="line">    set(target, key, value) &#123;</span><br><span class="line">      let res = Reflect.set(target, key, value);</span><br><span class="line">      that.subscribe[key].map(item =&gt; &#123;</span><br><span class="line">        item.update();</span><br><span class="line">      &#125;);</span><br><span class="line">      return res;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  this.$data = new Proxy(data, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;什么是双向数据绑定，这里就不做赘述了，vue的双向数据绑定是什么大家都很了解了，这里主要讲vue2和vue3中双向绑定的区别。&lt;/p&gt;
&lt;p&gt;vue2中使用“Object.defineProperty”对象以及对象属性的劫持实现双向绑定；而vue3中的响应式采用了ES6中的“Proxy”方法实现双向绑定。&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="https://tangyanqiong.com/categories/Web/"/>
    
      <category term="Vue" scheme="https://tangyanqiong.com/categories/Web/Vue/"/>
    
    
      <category term="JavaScript" scheme="https://tangyanqiong.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>什么是闭包及防抖节流</title>
    <link href="https://tangyanqiong.com/post/c980d613.html"/>
    <id>https://tangyanqiong.com/post/c980d613.html</id>
    <published>2020-05-02T10:05:42.000Z</published>
    <updated>2022-07-22T12:55:31.065Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>通常情况下，声明在一个函数中的函数，叫做闭包函数，在Javascript语言中，只有函数内部的子函数才能读取局部变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 闭包函数</span><br><span class="line">function f1()&#123;</span><br><span class="line"> var n;</span><br><span class="line"> return function () &#123;</span><br><span class="line">    n ++;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>让外部访问函数内部变量成为可能<br>可以避免使用全局变量，防止全局变量污染</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>局部变量会常驻在内存中，会造成内存泄漏（有一块内存空间被长期占用，而不被释放）</p><h1 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h1><p>设想有此场景：输入框中内容变化需要实时请求接口以获取最新搜索结果，如果在输入完成前输入框内容每变化一下都去请求接口，会造成很多不必要的请求，大大增加服务器压力。</p><p>解决思路：有变化时延迟一段时间再执行function，若在这段延迟时间内又有新变化，则重新开始延迟</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 定时器期间，有新操作时，清空旧定时器，重设新定时器</span><br><span class="line">var debounce = (fn, wait) =&gt; &#123;</span><br><span class="line">   let timer, timeStamp=0;</span><br><span class="line">   let context, args;</span><br><span class="line">  </span><br><span class="line">    let run = ()=&gt;&#123;</span><br><span class="line">        timer= setTimeout(()=&gt;&#123;</span><br><span class="line">            fn.apply(context,args);</span><br><span class="line">       &#125;,wait);</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   let clean = () =&gt; &#123;</span><br><span class="line">       clearTimeout(timer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   return function() &#123;</span><br><span class="line">      context = this;</span><br><span class="line">      args = arguments;</span><br><span class="line">      let now = (new Date()).getTime();</span><br><span class="line">      if (now-timeStamp &lt; wait) &#123;</span><br><span class="line">          console.log(&apos;reset&apos;,now);</span><br><span class="line">          // 清除定时器，并重新加入延迟 </span><br><span class="line">          clean(); </span><br><span class="line">          run();</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          console.log(&apos;set&apos;,now);</span><br><span class="line">          run();  // last timer alreay executed, set a new timer</span><br><span class="line">      &#125;</span><br><span class="line">       timeStamp = now;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码进一步优化：周期内有新事件触发时，重置定时器开始时间戳，定时器执行时，判断开始时间戳，若开始时间戳被推后，重新设定延时定时器；加入是否立即执行参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// 增加前缘触发功能</span><br><span class="line">var debounce = (fn, wait, immediate=false) =&gt; &#123;</span><br><span class="line">    let timer, startTimeStamp=0;</span><br><span class="line">    let context, args;</span><br><span class="line"> </span><br><span class="line">    let run = (timerInterval) =&gt; &#123;</span><br><span class="line">        timer= setTimeout(() =&gt; &#123;</span><br><span class="line">            let now = (new Date()).getTime();</span><br><span class="line">            let interval = now-startTimeStamp</span><br><span class="line">            if(interval &lt; timerInterval) &#123; // the timer start time has been reset，so the interval is less than timerInterval</span><br><span class="line">                console.log(&apos;debounce reset&apos;,timerInterval-interval);</span><br><span class="line">                startTimeStamp = now;</span><br><span class="line">                run(wait-interval);  // reset timer for left time </span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (!immediate) &#123;</span><br><span class="line">                    fn.apply(context,args);</span><br><span class="line">                &#125;</span><br><span class="line">                clearTimeout(timer);</span><br><span class="line">                timer=null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, timerInterval);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return function() &#123;</span><br><span class="line">        context = this;</span><br><span class="line">        args = arguments;</span><br><span class="line">        let now = (new Date()).getTime();</span><br><span class="line">        startTimeStamp = now; // set timer start time</span><br><span class="line"> </span><br><span class="line">        if(!timer) &#123;</span><br><span class="line">            console.log(&apos;debounce set&apos;,wait);</span><br><span class="line">            if(immediate) &#123;</span><br><span class="line">                fn.apply(context,args);</span><br><span class="line">            &#125;</span><br><span class="line">            run(wait);    // last timer alreay executed, set a new timer</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h1><p>设想有此场景：有‘搜索’按钮，每点击一次都会重新请求接口，获取并渲染页面表格最新数据，假如短时间内连续点击按钮，依然会造成很多不必要的请求<br>解决思路：在一段时间内只执行最后一次function</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">// 定时器期间，只执行最后一次操作</span><br><span class="line">var throttling = (fn, wait) =&gt; &#123;</span><br><span class="line">    let timer;</span><br><span class="line">    let context, args;</span><br><span class="line"> </span><br><span class="line">    let run = () =&gt; &#123;</span><br><span class="line">        timer=setTimeout(()=&gt;&#123;</span><br><span class="line">            fn.apply(context,args);</span><br><span class="line">            clearTimeout(timer);</span><br><span class="line">            timer=null;</span><br><span class="line">        &#125;,wait);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return function () &#123;</span><br><span class="line">        context=this;</span><br><span class="line">        args=arguments;</span><br><span class="line">        if(!timer)&#123;</span><br><span class="line">            console.log(&quot;throttle, set&quot;);</span><br><span class="line">            run();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            console.log(&quot;throttle, ignore&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 增加前缘</span><br><span class="line">var throttling = (fn, wait, immediate) =&gt; &#123;</span><br><span class="line">    let timer, timeStamp=0;</span><br><span class="line">    let context, args;</span><br><span class="line"> </span><br><span class="line">    let run = () =&gt; &#123;</span><br><span class="line">        timer=setTimeout(()=&gt;&#123;</span><br><span class="line">            if(!immediate)&#123;</span><br><span class="line">                fn.apply(context,args);</span><br><span class="line">            &#125;</span><br><span class="line">            clearTimeout(timer);</span><br><span class="line">            timer=null;</span><br><span class="line">        &#125;,wait);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return function () &#123;</span><br><span class="line">        context=this;</span><br><span class="line">        args=arguments;</span><br><span class="line">        if(!timer)&#123;</span><br><span class="line">            console.log(&quot;throttle, set&quot;);</span><br><span class="line">            if(immediate)&#123;</span><br><span class="line">                fn.apply(context,args);</span><br><span class="line">            &#125;</span><br><span class="line">            run();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            console.log(&quot;throttle, ignore&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>防抖及节流都是使用闭包函数来应用的实际场景，平时也应注意合理使用闭包函数，避免性能消耗过多。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;通常情况下，声明在一个函数中的函数，叫做闭包函数，在Javascript语言中，只有函数内部的子函数才能读取局部变量：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 闭包函数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function f1()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; var n;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; return function () &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    n ++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Web" scheme="https://tangyanqiong.com/categories/Web/"/>
    
      <category term="JS" scheme="https://tangyanqiong.com/categories/Web/JS/"/>
    
    
      <category term="JavaScript" scheme="https://tangyanqiong.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Flutter最新版本环境搭建报错</title>
    <link href="https://tangyanqiong.com/post/dc7fb27e.html"/>
    <id>https://tangyanqiong.com/post/dc7fb27e.html</id>
    <published>2020-04-15T06:24:35.000Z</published>
    <updated>2022-07-20T16:53:04.194Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近更新到Mac OS最新系统Catalina，重装了Flutter，出现了些问题，在网上也搜索了，可能是才出的新版本问题，也没找到解决办法，最终自己捣鼓解决了此问题，随笔记录下此问题。 </p><a id="more"></a><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>正常搭建Flutter的过程就不说了，到最后一步执行<code>flutter doctor</code>时报错如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">TangYanQiong-MacbookPro:~ TangDan$ flutter doctor</span><br><span class="line">Doctor summary (to see all details, run flutter doctor -v):</span><br><span class="line">[✓] Flutter (Channel master, v1.18.0-5.0.pre.57, on Mac OS X 10.15.4 19E287,</span><br><span class="line">    locale zh-Hans-CN)</span><br><span class="line">[!] Android toolchain - develop for Android devices (Android SDK version 29.0.3)</span><br><span class="line">    ✗ Android license status unknown.</span><br><span class="line">      Try re-installing or updating your Android SDK Manager.</span><br><span class="line">      See https://developer.android.com/studio/#downloads or visit visit</span><br><span class="line">      https://flutter.dev/docs/get-started/install/macos#android-setup for</span><br><span class="line">      detailed instructions.</span><br><span class="line">[✓] Xcode - develop for iOS and macOS (Xcode 11.4)</span><br><span class="line">[✓] Android Studio (version 3.6)</span><br><span class="line"> </span><br><span class="line">[!] Connected device                          </span><br><span class="line">    ! No devices available</span><br><span class="line"></span><br><span class="line">! Doctor found issues in 2 categories.</span><br></pre></td></tr></table></figure><p>网上查了，大多答案都是让执行<code>flutter doctor --android-licenses</code>，结果又报错如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TangYanQiong-MacbookPro:~ TangDan$ flutter doctor --android-licenses</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Android sdkmanager tool not found</span><br><span class="line">(/Users/TangDan/Library/Android/sdk/tools/bin/sdkmanager).</span><br><span class="line">Try re-installing or updating your Android SDK,</span><br><span class="line">visit https://flutter.dev/docs/get-started/install/macos#android-setup for</span><br><span class="line">detailed instructions.</span><br></pre></td></tr></table></figure><p>这个意思是说，Android sdkmanager tool没找到，然后按照提示的目录信息，去找了一下，发现我的sdk目录下，根本就没有tools这个文件夹，后来调查发现，这个tools文件实际上是android studio安装了Android SDK Tools才会有生成那个文件夹，在这里勾选安装，如果你本地有这个的话，安装了应该就好了。</p><p><img src="https://i.loli.net/2020/04/14/banc4LTCiGfH6uM.png" alt="20190305104220816.png"></p><p>但是我本地并没有这个选项，我这边的Android SDK配置是这样的，根本没有tools这个安装包，只有Command-line Tools这个，有点类似，就也勾选安装了：<br><img src="https://i.loli.net/2020/04/14/VzNalLOkI4bX52F.jpg" alt="921794A9-2AA5-414D-BB73-B2C8E04D6DC6.png"></p><p>安装成功后的目录如下：<br><img src="https://i.loli.net/2020/04/14/AQrYhRKN8gBdO2y.jpg" alt="8C0A4825-8370-4CE2-9421-BEB561E68F24.png"></p><p>还是没有tools这个文件夹，但是sdkmanager有了，后面自己想了下，不是缺tools吗？只是路径不对的问题了，就自己新建了个tools，里面在创建了个bin文件夹，再把sdkmanager拷进去。<br><img src="https://i.loli.net/2020/04/14/RGnK1e3mx4LZIph.jpg" alt="27225CB4-388F-4C7C-8EDD-99A3C0C2C242.png"><br><img src="https://i.loli.net/2020/04/14/JXTMI9Pfw821ySe.jpg" alt="9D0FB5F4-C0DF-44A0-9C8C-421482B40E32.png"></p><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>猜想是，Android Studio最新版本Tools版本、名称及路径修改了，但是flutter最新版本并未更新，还是使用老路径导致找不到。</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>现在再来执行<code>flutter doctor --android-licenses</code>，一路<code>y</code>下去，设置成功。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TangYanQiong-MacbookPro:~ TangDan$ flutter doctor --android-licenses</span><br><span class="line">5 of 7 SDK package licenses not accepted. 100% Computing updates...             </span><br><span class="line">Review licenses that have not been accepted (y/N)? y</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>最后，再执行<code>flutter doctor</code>，大功告成，不报错了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TangYanQiong-MacbookPro:~ TangDan$ flutter doctor</span><br><span class="line">[✓] Flutter (Channel master, v1.18.0-5.0.pre.57, on Mac OS X 10.15.4 19E287,</span><br><span class="line">    locale zh-Hans-CN)</span><br><span class="line"> </span><br><span class="line">[✓] Android toolchain - develop for Android devices (Android SDK version 29.0.3)</span><br><span class="line">[✓] Xcode - develop for iOS and macOS (Xcode 11.4)</span><br><span class="line">[✓] Android Studio (version 3.6)</span><br><span class="line"> </span><br><span class="line">[✓] Connected device (1 available)            </span><br><span class="line"></span><br><span class="line">• No issues found!</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近更新到Mac OS最新系统Catalina，重装了Flutter，出现了些问题，在网上也搜索了，可能是才出的新版本问题，也没找到解决办法，最终自己捣鼓解决了此问题，随笔记录下此问题。 &lt;/p&gt;
    
    </summary>
    
      <category term="Flutter" scheme="https://tangyanqiong.com/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="https://tangyanqiong.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Mac OS Catalina 终端Shell报警告</title>
    <link href="https://tangyanqiong.com/post/bdd80ff3.html"/>
    <id>https://tangyanqiong.com/post/bdd80ff3.html</id>
    <published>2020-02-10T07:18:37.000Z</published>
    <updated>2022-07-20T16:54:26.670Z</updated>
    
    <content type="html"><![CDATA[<h1 id="随笔"><a href="#随笔" class="headerlink" title="随笔"></a>随笔</h1><p>前两天更新了Mac OS Catalina系统，总体来说还是可以，虽然有些只支持32位的应用，比如2015版的Office、WireShark等不能用了，但塞翁失马焉知非福呢，卸掉了Office相关的Word、Excel、PPT，瞬间清了几大个G，然后去下载了WPS多方文档格式支持软件，简直不要太好用，而且才几百兆，扯远了。。。</p><p>今天随笔记一个小事件，对于强迫症人士有用，比如我。</p><p>终端Shell报警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The default interactive shell is now zsh.</span><br><span class="line">To update your account to use zsh, please run `chsh -s /bin/zsh`.</span><br><span class="line">For more details, please visit https://support.apple.com/kb/HT208050.</span><br><span class="line">TangYanQiongdeMacBook-Pro:~ TangDan$</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>从报的警告就可以看出，提示原来使用的是bash风格，然而Catalina系统的shell已更改为zsh，请用 <code>chsh -s /bin/zsh</code> 更新替换，好吧，就run了，结果变成了这个风格</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TangDan@TangYanQiongdeMacBook-Pro ~ %</span><br></pre></td></tr></table></figure><p>对这种爱不起来，然后查看系统支持的shell风格列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TangYanQiongdeMacBook-Pro:~ TangDan$ cat /etc/shells</span><br><span class="line"># List of acceptable shells for chpass(1).</span><br><span class="line"># Ftpd will not allow users to connect who are not using</span><br><span class="line"># one of these shells.</span><br><span class="line"></span><br><span class="line">/bin/bash</span><br><span class="line">/bin/csh</span><br><span class="line">/bin/dash</span><br><span class="line">/bin/ksh</span><br><span class="line">/bin/sh</span><br><span class="line">/bin/tcsh</span><br><span class="line">/bin/zsh</span><br></pre></td></tr></table></figure><p>然后每个都试了，还是<code>/bin/bash</code>这种风格<code>TangYanQiongdeMacBook-Pro:~ TangDan$</code>最喜欢，但是系统会报警告，好，那把这个警告怎么消除？</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><ol><li>vim修改bash_profile文件，在终端输出</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bash_profile</span><br></pre></td></tr></table></figure><ol start="2"><li>在bash_profile文件最下方加上，按<code>i</code>进入编辑模式</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># macOS Catalina</span><br><span class="line">export BASH_SILENCE_DEPRECATION_WARNING=1</span><br></pre></td></tr></table></figure><ol start="3"><li>按<code>esc</code>退出编辑模式，再输入<code>:wq</code>保存退出，现在终端就不会报警告了。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Last login: Fri Apr 10 15:40:06 on ttys006</span><br><span class="line">TangYanQiongdeMacBook-Pro:~ TangDan$</span><br></pre></td></tr></table></figure><h1 id="题外"><a href="#题外" class="headerlink" title="题外"></a>题外</h1><p>看到我这边shell用户名<code>TangYanQiongdeMacBook-Pro</code>我想改它很久（中英混合。。。），这会顺便改了，打开系统偏好设置-共享-直接修改电脑名称就可以修改了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Last login: Fri Apr 10 15:46:05 on ttys006</span><br><span class="line">TangYanQiong-MacbookPro:~ TangDan$</span><br></pre></td></tr></table></figure><p>舒服了，😃</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;随笔&quot;&gt;&lt;a href=&quot;#随笔&quot; class=&quot;headerlink&quot; title=&quot;随笔&quot;&gt;&lt;/a&gt;随笔&lt;/h1&gt;&lt;p&gt;前两天更新了Mac OS Catalina系统，总体来说还是可以，虽然有些只支持32位的应用，比如2015版的Office、WireShark等不能用了，但塞翁失马焉知非福呢，卸掉了Office相关的Word、Excel、PPT，瞬间清了几大个G，然后去下载了WPS多方文档格式支持软件，简直不要太好用，而且才几百兆，扯远了。。。&lt;/p&gt;
&lt;p&gt;今天随笔记一个小事件，对于强迫症人士有用，比如我。&lt;/p&gt;
&lt;p&gt;终端Shell报警告：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;The default interactive shell is now zsh.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;To update your account to use zsh, please run `chsh -s /bin/zsh`.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;For more details, please visit https://support.apple.com/kb/HT208050.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;TangYanQiongdeMacBook-Pro:~ TangDan$&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Others" scheme="https://tangyanqiong.com/categories/Others/"/>
    
    
      <category term="Shell" scheme="https://tangyanqiong.com/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>RN分享</title>
    <link href="https://tangyanqiong.com/post/98fdf95d.html"/>
    <id>https://tangyanqiong.com/post/98fdf95d.html</id>
    <published>2019-12-08T12:01:33.000Z</published>
    <updated>2022-07-20T16:54:02.593Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-React"><a href="#什么是-React" class="headerlink" title="什么是 React"></a>什么是 React</h2><ul><li><p>React 是一个用于构建用户界面的 JavaScript 库。</p></li><li><p>声明式UI</p></li></ul><a id="more"></a><h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><p><a href="https://zh-hans.reactjs.org/docs/jsx-in-depth.html" target="_blank" rel="noopener">JSX</a></p><h2 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h2><ul><li><p>Props</p></li><li><p>State</p></li><li><p>生命周期 <a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" target="_blank" rel="noopener">图例</a></p></li></ul><h2 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h2><ul><li><p>react 的核心卖点之一</p></li><li><p>setState （只要调用了 setState 就会调用 render 无论你 setState 修改的是什么，哪怕是页面里没有的一个数据，render 都会被触发，并且父组件渲染中会嵌套渲染自、子组件。）</p></li><li><p>render</p></li><li><p>diff | reconciliation</p></li></ul><p>官方一点的定义应该称为 reconciliation，也就是 React 用来比较两棵节点树的算法，它确定树中的哪些部分需要被更新。</p><p>在确定两棵树的区别后，会根据不同的地方对实际节点进行操作，这样你看到的界面终于在这一步得到了改变。当年 React 也就因为这个高效的 dom 操作方法得到追捧。</p><ul><li>shouldComponentUpdate</li></ul><h2 id="PureComponent"><a href="#PureComponent" class="headerlink" title="PureComponent"></a>PureComponent</h2><h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://zh-hans.reactjs.org/docs/forwarding-refs.html" target="_blank" rel="noopener">refs 转发</a></p><h2 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h2><p><a href="https://zh-hans.reactjs.org/docs/fragments.html#short-syntax" target="_blank" rel="noopener">fragment</a></p><h2 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h2><p><a href="https://zh-hans.reactjs.org/docs/higher-order-components.html" target="_blank" rel="noopener">高阶组件</a></p><h2 id="协调与-diff"><a href="#协调与-diff" class="headerlink" title="协调与 diff"></a>协调与 diff</h2><p><a href="https://zh-hans.reactjs.org/docs/reconciliation.html" target="_blank" rel="noopener">diffing</a></p><h2 id="react-hook"><a href="#react-hook" class="headerlink" title="react hook"></a>react hook</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是-React&quot;&gt;&lt;a href=&quot;#什么是-React&quot; class=&quot;headerlink&quot; title=&quot;什么是 React&quot;&gt;&lt;/a&gt;什么是 React&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;React 是一个用于构建用户界面的 JavaScript 库。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;声明式UI&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Web" scheme="https://tangyanqiong.com/categories/Web/"/>
    
      <category term="JS" scheme="https://tangyanqiong.com/categories/Web/JS/"/>
    
    
      <category term="JavaScript" scheme="https://tangyanqiong.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Charles抓包微信小程序\移动端（Mac版）</title>
    <link href="https://tangyanqiong.com/post/b032c09d.html"/>
    <id>https://tangyanqiong.com/post/b032c09d.html</id>
    <published>2019-10-11T03:26:59.000Z</published>
    <updated>2020-04-24T06:21:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前做移动端，对网络进行测试抓包一直用的Charles抓包工具，很实用的一款工具，那怎么抓微信小程序的包呢，实际跟移动端是一样的，下面统一记录下，避免换电脑遗忘。</p><a id="more"></a><h1 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h1><p>其实要想抓取到微信小程序的数据首先要解决的第一个问题件就是如何通过charles抓取手机上的数据（HTTP)。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>charles上通过proxy-&gt;proxy setting进入代理设置，入口如下图所示：</p><p><img src="https://img-blog.csdn.net/20180307191133358?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTWFueVBlbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p>点击后进入如下图所示：</p><p><img src="https://img-blog.csdn.net/20180307191412276?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTWFueVBlbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p>记住此处的port，默认为8888，也可以进行修改，只要不冲突就可以，<strong>勾选上Enable transparent HTTP proxying</strong>，到此为止完成charles上的初步设置。</p><p>到此为止，完成了电脑端的设置。</p><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>设置手机代理，<strong>注意要保证手机所连接的wifi跟电脑在一个局域网内（就是连接同一个wifi或者通过电脑分享出的wifi进行连接）</strong></p><p>首先，需要知道电脑的ip地址，手机上进入wifi设置，电脑与手机共连同一个网络，修改手机上wifi代理</p><p><img src="https://img-blog.csdn.net/20180307192323638?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTWFueVBlbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p>点击代理后进入如下界面，服务器主机名处填写刚才查到的电脑的ip地址即可，服务器端口填写第一步中charles处设置的端口，默认是8888，如果做了修改，填写设置charles时修改的端口值。</p><p><img src="https://img-blog.csdn.net/20180307192559442?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTWFueVBlbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p>点击保存，此时charles上会弹出一个对话框，点击allow(允许)即可。此时就可以抓取手机上的http数据包了（注意不是https）</p><p>如下图所示，点入一个应用后，抓取到的http包。</p><p><img src="https://img-blog.csdn.net/20180307193307975?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTWFueVBlbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><p>完成以上步骤，charles会同时抓取手机以及电脑上的数据包，如果针对手机抓包可以通过取消勾选下图所示的选项屏蔽掉，这样更清楚。</p><p><img src="https://img-blog.csdn.net/20180307194127716?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTWFueVBlbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>手机连接不上Charles的几种原因及解决方案：</p><ol><li><p>确认手机跟电脑是不是在一个wifi环境下，我在使用过程中又一次手机由于wifi信号强弱问题自动切换过wifi导致抓了一般的数据包抓不到了。</p></li><li><p>可以尝试更换一下端口号（8888可能已经被占用）。</p></li><li><p>可以通过电脑手动添加手机的ip。</p></li></ol><p><img src="https://img-blog.csdn.net/20180307193806911?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTWFueVBlbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><ol start="4"><li><p>试试关掉电脑防火墙，在重新连接。</p></li><li><p>最后大招，万能重启。重新打开charles，重新设置手机连接。</p></li></ol><h1 id="抓HTTPS包"><a href="#抓HTTPS包" class="headerlink" title="抓HTTPS包"></a>抓HTTPS包</h1><h2 id="电脑端设置"><a href="#电脑端设置" class="headerlink" title="电脑端设置"></a>电脑端设置</h2><p>到此为止，完成了一大步骤的设置，可以通过电脑抓取手机的HTTP数据包了，但对于HTTPS数据，到此步为止，抓包工具上的列表部分会显示一堆unknown的地址。</p><p><strong>那怎么来解决呢？</strong></p><p>首先是电脑端的配置，进入Charles的Help-&gt;SSL Proxying-&gt;Install Charles Root Certificate</p><p><img src="https://img-blog.csdn.net/20180307194401534?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTWFueVBlbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p>点击Install Charles Root Certificate之后，会弹出mac的钥匙串访问页面，点击允许并安装证书，加入成功后会显示如下：</p><p><img src="https://i.loli.net/2020/04/24/sZrkW4DSyu9dFew.png" alt="WeChatd20fdc2fb5b0fa890a9519a1a921c6a4.png"></p><p>右键点击该证书，选择菜单中的“显示简介选项”，接着进入信任栏目，将其全部置为“始终信任”</p><p><img src="https://img-blog.csdn.net/20180307194916728?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTWFueVBlbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p>接着点击Proxy-&gt;SSL Proxy Settings，弹出如下页面</p><p><img src="https://img-blog.csdn.net/20180307195134860?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTWFueVBlbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt><br><img src="https://img-blog.csdn.net/20180307195230731?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTWFueVBlbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p>弹出的对话框中，勾选Enable SSL Proxying，然后点击add添加Host为<em>和Port为443，点击ok（此处将host设置为</em>的意思是主抓取全部的http是数据包，如果想针对某个域名抓取可以在此设置）</p><p>到此为止，完成了电脑端的设置</p><h2 id="移动端设置"><a href="#移动端设置" class="headerlink" title="移动端设置"></a>移动端设置</h2><p>接着需要在手机端安装证书，点击Charles上的Help-&gt;SSL Proxying-&gt;Install Charles Root Certificate on a Mobile Device or Remote Browser</p><p>点击之后弹出如下对话框：</p><p><img src="https://img-blog.csdn.net/20180307195617304?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTWFueVBlbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p>接着在手机浏览器上访问charlesproxy.com/getssl这个地址，然后会弹出如下界面：</p><p><img src="https://img-blog.csdn.net/20180307200002865?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTWFueVBlbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p>输入一个名字比如charlesproxy之后点击确定，会有一个一闪而过的提示，就ok了</p><p>此时进入小程序，可以看到charles上能够看到https的接口的地址和数据了</p><p><img src="https://img-blog.csdn.net/20180307200443685?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTWFueVBlbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p>到此，就可以愉快的抓包了。</p><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><h2 id="温馨提示1"><a href="#温馨提示1" class="headerlink" title="温馨提示1"></a>温馨提示1</h2><p>苹果设备iOS10以后证书可以正常安装，可正常使用HTTPS抓包，但是安卓设备呢，需注意：</p><p><em>由于在Android7.0及以上的系统中，每个应用可以定义自己的可信CA集，默认情况下，应用只会信任系统预装的CA证书，而不会信任用户安装的CA证书</em></p><ul><li>安卓系统 7.0 以下版本，不管微信任意版本，都会信任系统提供的证书</li><li>安卓系统 7.0 以上版本，微信 7.0 以下版本，微信会信任系统提供的证书</li><li>安卓系统 7.0 以上版本，微信 7.0 以上版本，微信只信任它自己配置的证书列表</li></ul><p>简单来说，就是安卓系统7.0及以下的设备可以正常安装证书进行HTTPS抓包，7.0以上则需要曲线救国，这里就不多说了，我后面在电脑上用<strong>网易MuMu模拟器（该模拟器系统是6.0）</strong>安装微信，在wifi设置里长按默认网络进行网络修改，设置代理等，也可以愉快的抓小程序的数据包了。</p><h2 id="温馨提示2"><a href="#温馨提示2" class="headerlink" title="温馨提示2"></a>温馨提示2</h2><p>注意，有一些应用使用的网络框架是不允许通过代理访问的，此时通过charles抓包显示的地址仍是unknown，或者手机上访问该应用会提示网络连接错误等信息，此时取消勾选charles的SSL Proxying settings中的勾选框就可以正常访问了。</p><h2 id="温馨提示3"><a href="#温馨提示3" class="headerlink" title="温馨提示3"></a>温馨提示3</h2><p>抓取工作完成后，记得把手机上的代理设置恢复原样，否则当电脑上的charles关闭时，手机将无法正常访问网络。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;之前做移动端，对网络进行测试抓包一直用的Charles抓包工具，很实用的一款工具，那怎么抓微信小程序的包呢，实际跟移动端是一样的，下面统一记录下，避免换电脑遗忘。&lt;/p&gt;
    
    </summary>
    
      <category term="Others" scheme="https://tangyanqiong.com/categories/Others/"/>
    
    
      <category term="Charles" scheme="https://tangyanqiong.com/tags/Charles/"/>
    
      <category term="WeChat" scheme="https://tangyanqiong.com/tags/WeChat/"/>
    
      <category term="抓包" scheme="https://tangyanqiong.com/tags/%E6%8A%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>iOS及Web使用语言特性</title>
    <link href="https://tangyanqiong.com/post/4546698d.html"/>
    <id>https://tangyanqiong.com/post/4546698d.html</id>
    <published>2019-09-16T03:07:38.000Z</published>
    <updated>2020-04-14T07:58:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>关于iOS及Web的使用语言Object-C、Swift、JavaScript，大家都耳熟能详，那它们到底是什么类型的静态语言？以及什么强弱类型语言？很多同学只是简单的背出它们是什么语言及类型，但并没有理解到，现在来举例说明和分享一下。</p><a id="more"></a><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><h2 id="Object-C"><a href="#Object-C" class="headerlink" title="Object-C"></a>Object-C</h2><p>我用的最多的当然是Object-C，毕竟是做iOS开发出身，对这个语言了解最深。首先，因为黑魔法RunTime机制，Object-C是一个运行时的<strong>动态类型的强类型语言</strong>，举例如下：</p><ol><li>以下两种情况都可以看出，Xcode编译时并不会报错，说明是一个<em>动态语言</em>，运行时才会去检验类型</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSString *test = @&quot;1231231&quot;;</span><br><span class="line">test = [[NSDate alloc] init];</span><br><span class="line"></span><br><span class="line">NSDate *test2 = @&quot;1231231&quot;; // test2的真实类型是什么，运行时会得到String类型，并不是声明时的NSDate类型</span><br></pre></td></tr></table></figure><ol start="2"><li>Object-C是<em>强类型语言</em>，因为变量必须声明类型才能使用，说实话，Object-C的代码简洁性，是真的不怎么高</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSString *certsPath = [[NSBundle mainBundle] pathForResource:@&quot;server&quot; ofType:@&quot;crt&quot;];</span><br><span class="line">NSError *error;</span><br><span class="line">NSString *contentInUTF8 = [NSString stringWithContentsOfFile:certsPath encoding:NSUTF8StringEncoding error:&amp;error];</span><br></pre></td></tr></table></figure><h2 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h2><p>iOS的这两种开发语言，Swift和OC，Swift更简洁了，减少了代码的冗余性，最开始接触它的时候，我还以为它是一门弱语言类型的语言，后来发现我错了，下面会娓娓道来，它实际是一门<strong>静态类型的强类型语言</strong>。</p><ol><li>以下情况代码编译会报错：’Cannot assign value of type ‘NSDate’ to type ‘String’’ ，类型错误，由此看出Swift是<em>静态类型语言</em></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var tmp = &quot;asdfas&quot;</span><br><span class="line">let date = NSDate.init()</span><br><span class="line">tmp = date</span><br></pre></td></tr></table></figure><ol start="2"><li>为什么一开始会觉得它是弱类型语言呢？</li></ol><blockquote><p>Swift 变量不强制的指定类型，而是用 var 和 let 表示可变与不可变。所以，误Swift是一门弱类型的语言。</p></blockquote><p>像下面的代码块，变量赋值时并没声明类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let num = 1</span><br><span class="line">let str = &quot;2&quot;</span><br></pre></td></tr></table></figure><p>基于以上，从自身理解，误以为<del>Swift是弱类型语言</del></p><p>但是，实际上，这里没有强制声明类型，看似一个弱类型的语言，其实不然。Swift 编译器能够推断出 num 是 Int 类型。那么 num 就不能再被赋值为 String 类型。更不能写成如下的形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let num = 1</span><br><span class="line">let str = &quot;2&quot;</span><br><span class="line">let result = num + str</span><br></pre></td></tr></table></figure><p><strong>编译器将会报如下的错误：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">error: binary operator &apos;+&apos; cannot be applied to operands of type &apos;Int&apos; and &apos;String&apos;</span><br><span class="line">let result = num + str</span><br><span class="line">             ~~~ ^ ~~~</span><br><span class="line">note: overloads for &apos;+&apos; exist with these partially matching parameter lists: (Int, Int), (String, String), (Int, UnsafeMutablePointer&lt;Pointee&gt;), (Int, UnsafePointer&lt;Pointee&gt;)</span><br><span class="line">let result = num + str</span><br></pre></td></tr></table></figure><p>这说明了，Swift 是一门<em>强类型语言</em>。Swift 的类型声明，你可以看成是在定义变量的时候，隐式声明的（由编译器推断出），当然也可以显式的声明。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let num: Int = 1</span><br></pre></td></tr></table></figure><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><p>Web中的常用语言JavaScript，如果有语言基础的话，是一门很快上手的语言，我也很喜欢JavaScript，当然也有使用中比较头疼的事，因为它是一门<strong>动态类型的弱类型语言</strong>，往往项目中在项目运行成功后，控制台意想不到的报错，不像强语言类型那样，直接编译不过，而我又有Swift的编写思想，想着它类型编译通过了，运行肯定就没问题，往往会出现比如编译没问题，类型错误的问题，而且它没有iOS中nil可以调用任何方法的容错机制，如果这个对象为nil再调用其某个方法也会报错，所以写的时候必须要判断是否为空，增加代码冗余性，但是，好处大于弊端，比如代码简洁性，可以动态写很多业务逻辑，我还是很喜欢它。</p><ol><li><em>动态类型语言</em>，以下情况，编译没问题，动态运行时赋值类型</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let tmpFlag = false</span><br><span class="line">let test = &apos;asdfasdfas&apos;</span><br><span class="line">test = tmpFlag // 所以最终test为Bool类型了</span><br></pre></td></tr></table></figure><ol start="2"><li><em>弱类型语言</em>，书写变量时不用声明类型也可</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let tmpFlag = false</span><br><span class="line">let test = &apos;asdfasdfas&apos;</span><br><span class="line">let jjjj = Date.now()</span><br></pre></td></tr></table></figure><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><p>TypeScript是JavaScript的一个超集，TypeScript可以使用JavaScript中的所有代码和编码概念，TypeScript是为了使 JavaScript的开发变得更加容易而创建的，它是关于尽早捕获错误并使您成为更高效的开发人员，它是什么类型的语言？我们把在JavaScript上实验的代码，放在ts里一试便知道。</p><ol><li>以下情况是js上实验的代码，在ts里编译报错，说明TypeScript是<em>静态类型语言</em></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let tmpFlag = false</span><br><span class="line">let test = &apos;asdfasdfas&apos;</span><br><span class="line">test = tmpFlag</span><br></pre></td></tr></table></figure><p>报错如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">43:9 Type &apos;false&apos; is not assignable to type &apos;string&apos;.</span><br></pre></td></tr></table></figure><ol start="2"><li>相同代码又在ts里实验，编译未报错，故TypeScript是<em>弱类型语言</em></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let tmpFlag = false</span><br><span class="line">let test = &apos;asdfasdfas&apos;</span><br><span class="line">let jjjj = Date.now()</span><br></pre></td></tr></table></figure><p>以下代码也未报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let num = 1</span><br><span class="line">let str = &apos;2&apos;</span><br><span class="line">let result = num + str</span><br></pre></td></tr></table></figure><p>综上可知，TypeScript是一门<strong>静态类型的弱类型语言</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;关于iOS及Web的使用语言Object-C、Swift、JavaScript，大家都耳熟能详，那它们到底是什么类型的静态语言？以及什么强弱类型语言？很多同学只是简单的背出它们是什么语言及类型，但并没有理解到，现在来举例说明和分享一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Others" scheme="https://tangyanqiong.com/categories/Others/"/>
    
    
      <category term="JavaScript" scheme="https://tangyanqiong.com/tags/JavaScript/"/>
    
      <category term="Swift" scheme="https://tangyanqiong.com/tags/Swift/"/>
    
      <category term="Object-C" scheme="https://tangyanqiong.com/tags/Object-C/"/>
    
      <category term="TypeScript" scheme="https://tangyanqiong.com/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>跨平台RN与Flutter对比及学习</title>
    <link href="https://tangyanqiong.com/post/196a8be9.html"/>
    <id>https://tangyanqiong.com/post/196a8be9.html</id>
    <published>2019-09-08T07:42:34.000Z</published>
    <updated>2020-03-25T09:04:29.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近想学跨平台开发，在RN和Flutter中纠结学哪个，看了资料RN对Web前端比较友好，都是JS开发语言，比较容易上手，但是有个以前的iOS同事，他现在已经用Flutter着手在开发iOS、Android了，据他说很好用。</p><a id="more"></a><h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><p>跨平台，首先考虑的就是性能问题，谁的性能好，未来必将是谁的天下。</p><h2 id="RN性能"><a href="#RN性能" class="headerlink" title="RN性能"></a>RN性能</h2><p>RN的效率由于是将View编译成了原生View，所以效率上要比基于Cordova的HTML5高很多，但是它也有效率问题，RN的渲染机制是基于前端框架的考虑，复杂的UI渲染是需要依赖多个view叠加。比如我们渲染一个复杂的ListView，每一个小的控件，都是一个native的view，然后相互组合叠加，想想此时如果我们的list再需要滑动刷新，会有多少个对象需要渲染，所以也就有了前面所说的RN的列表方案不友好。</p><h3 id="RN框架原理图"><a href="#RN框架原理图" class="headerlink" title="RN框架原理图"></a>RN框架原理图</h3><p><img src="https://upload-images.jianshu.io/upload_images/11451874-f497b4b23ec7392f.png" alt="RN框架原理图"></p><h2 id="Flutter性能"><a href="#Flutter性能" class="headerlink" title="Flutter性能"></a>Flutter性能</h2><p>而Flutter则吸收了前两者的教训之后，在渲染技术上，选择了自己实现(GDI)，有自己的一套UI系统，由于有更好的可控性，使用了新的语言Dart，避免了RN的那种通过桥接器与Javascript通讯导致效率低下的问题，所以在性能方面无可厚非比RN更高一筹，有经验的开发者可以打开Android手机开发者选项里面的显示边界布局，发现Flutter的布局是一个整体，说明Flutter的渲染没用使用原生控件进行渲染。</p><h3 id="Flutter框架原理图"><a href="#Flutter框架原理图" class="headerlink" title="Flutter框架原理图"></a>Flutter框架原理图</h3><p><img src="https://upload-images.jianshu.io/upload_images/11451874-12b2515a4cb0cdb1.png" alt="Flutter框架原理图"></p><h1 id="异同"><a href="#异同" class="headerlink" title="异同"></a>异同</h1><ul><li><p>Flutter性能会更好无线接近原生的体验,Dart是AOT编译的，编译成快速、可预测的本地代码</p></li><li><p>RN采用JS语言开发，基于React，对前端工程师更友好。Dart语言受众小</p></li><li><p>Flutter自己实现了一套UI框架，丢弃了原生的UI框架。而RN还是可以自己利用原生框架，两个各有好处。Flutter的兼容性高，RN可以利用原生已有的优秀UI</p></li><li><p>RN的布局更像css，而Flutter的布局更像native布局，但是去掉xml通过代码直接写需要适应下</p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对比了RN/Flutter后，我觉得对于我来说，RN应该很容易上手，因为有前端基础，RN学习起来应该很快，但是我也不想放弃Flutter，Flutter布局像原生布局，有iOS开发经验的我也不想放弃，因为有iOS同事成功上车的前车之鉴，所以我也很有信心能学好它，从性能来说我也更偏向Flutter，但是也不想浪费RN这个学习机会，所以就我自己的实际情况而言，我会两个都学。</p><p>总之，一句话吧，<strong>基于自身实际情况，没有更好只有最适合你的框架</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近想学跨平台开发，在RN和Flutter中纠结学哪个，看了资料RN对Web前端比较友好，都是JS开发语言，比较容易上手，但是有个以前的iOS同事，他现在已经用Flutter着手在开发iOS、Android了，据他说很好用。&lt;/p&gt;
    
    </summary>
    
      <category term="跨平台" scheme="https://tangyanqiong.com/categories/%E8%B7%A8%E5%B9%B3%E5%8F%B0/"/>
    
    
      <category term="Flutter" scheme="https://tangyanqiong.com/tags/Flutter/"/>
    
      <category term="RN" scheme="https://tangyanqiong.com/tags/RN/"/>
    
  </entry>
  
  <entry>
    <title>MarkDown常用语法</title>
    <link href="https://tangyanqiong.com/post/d18ae5e4.html"/>
    <id>https://tangyanqiong.com/post/d18ae5e4.html</id>
    <published>2019-09-04T09:00:29.000Z</published>
    <updated>2020-03-25T09:20:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h1><p>由于前段时间工作忙，快一个月没更新博客了，貌似有些忘了MarkDown的语法，这里记录下MarkDown语法作备忘录，以后方便查找。</p><a id="more"></a><h1 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h1><h3 id="标题语法"><a href="#标题语法" class="headerlink" title="标题语法"></a>标题语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#一级标题</span><br><span class="line"></span><br><span class="line">##二级标题</span><br><span class="line"></span><br><span class="line">###三级标题</span><br><span class="line"></span><br><span class="line">####四级标题</span><br><span class="line"></span><br><span class="line">#####五级标题</span><br><span class="line"></span><br><span class="line">######六级标题</span><br></pre></td></tr></table></figure><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><hr><h3 id="使用-加空格，来表示无序列表"><a href="#使用-加空格，来表示无序列表" class="headerlink" title="使用*加空格，来表示无序列表"></a>使用*加空格，来表示无序列表</h3><ul><li><p>1</p></li><li><p>2</p></li><li><p>3</p></li></ul><h3 id="用数字加-加空格，来表示有序列表"><a href="#用数字加-加空格，来表示有序列表" class="headerlink" title="用数字加.加空格，来表示有序列表"></a>用数字加.加空格，来表示有序列表</h3><ol><li><p>1</p></li><li><p>2</p></li><li><p>3</p></li><li><p>4</p></li></ol><h3 id="使用引用"><a href="#使用引用" class="headerlink" title="使用引用"></a>使用引用</h3><blockquote><p>引用需要使用&gt;和空格</p></blockquote><h3 id="插入链接"><a href="#插入链接" class="headerlink" title="插入链接"></a>插入链接</h3><p><a href="http://baidu.com" target="_blank" rel="noopener">baidu</a></p><h3 id="插入在线图片"><a href="#插入在线图片" class="headerlink" title="插入在线图片"></a>插入在线图片</h3><p><img src="https://www.baidu.com/img/bd_logo1.png" alt="icon"></p><h3 id="使用粗体、斜体"><a href="#使用粗体、斜体" class="headerlink" title="使用粗体、斜体"></a>使用粗体、斜体</h3><p><strong>这就是粗体</strong></p><p><em>这就是斜体</em></p><p><strong><em>这就是斜粗体</em></strong></p><h3 id="Task-list"><a href="#Task-list" class="headerlink" title="Task list"></a>Task list</h3><ul><li style="list-style: none"><input type="checkbox" checked> finished</li><li style="list-style: none"><input type="checkbox"> unfinished</li></ul><p><del>这个是删除线</del></p><h3 id="使用代码框，PS-这种不支持代码的语法高亮"><a href="#使用代码框，PS-这种不支持代码的语法高亮" class="headerlink" title="使用代码框，PS:这种不支持代码的语法高亮"></a>使用代码框，PS:这种不支持代码的语法高亮</h3><p>~~~<br>@IBAction func showMessage(){</p><p>let alertController = UIAlertController(title: “welcome to my first app”, message: “hello world”, preferredStyle: UIAlertControllerStyle.Alert)</p><p>alertController.addAction(UIAlertAction(title: “OK”, style: UIAlertActionStyle.Default, handler: nil))</p><p>self.presentViewController(alertController, animated: true, completion: nil)</p><p>}<br><code>`</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;由来&quot;&gt;&lt;a href=&quot;#由来&quot; class=&quot;headerlink&quot; title=&quot;由来&quot;&gt;&lt;/a&gt;由来&lt;/h1&gt;&lt;p&gt;由于前段时间工作忙，快一个月没更新博客了，貌似有些忘了MarkDown的语法，这里记录下MarkDown语法作备忘录，以后方便查找。&lt;/p&gt;
    
    </summary>
    
      <category term="Others" scheme="https://tangyanqiong.com/categories/Others/"/>
    
    
      <category term="MarkDown" scheme="https://tangyanqiong.com/tags/MarkDown/"/>
    
  </entry>
  
  <entry>
    <title>Vue主题import出错</title>
    <link href="https://tangyanqiong.com/post/52c1147f.html"/>
    <id>https://tangyanqiong.com/post/52c1147f.html</id>
    <published>2019-08-01T03:52:00.000Z</published>
    <updated>2020-03-25T08:53:59.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>在main.js文件中import<strong>‘../theme/index.css’</strong> 报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ERROR  Failed to compile with 1 errors </span><br><span class="line">                                                                                                                                                                                             </span><br><span class="line">This relative module was not found:</span><br><span class="line"></span><br><span class="line">* ../theme/index.css in ./src/main.js</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>原来在webpack.base.conf.js中有导入过如下代码，可能是webpack.base.conf.js和utils.js重复编译SCSS文件导致报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 导入SCSS</span><br><span class="line">&#123;</span><br><span class="line">   test: /\.(scss|css)?$/,</span><br><span class="line">   loaders: [&quot;style&quot;, &quot;css&quot;, &quot;sass&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>删除上述在webpack.base.conf.js中导入的SCSS代码，即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;在main.js文件中import&lt;strong&gt;‘../theme/index.css’&lt;/strong&gt; 报错：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ERROR  Failed to compile with 1 errors &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                                                                                                                                                             &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;This relative module was not found:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* ../theme/index.css in ./src/main.js&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Web" scheme="https://tangyanqiong.com/categories/Web/"/>
    
      <category term="Vue" scheme="https://tangyanqiong.com/categories/Web/Vue/"/>
    
    
      <category term="Vue" scheme="https://tangyanqiong.com/tags/Vue/"/>
    
      <category term="CSS" scheme="https://tangyanqiong.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Vue项目缩进问题</title>
    <link href="https://tangyanqiong.com/post/db5c826e.html"/>
    <id>https://tangyanqiong.com/post/db5c826e.html</id>
    <published>2019-07-30T09:50:46.000Z</published>
    <updated>2019-07-31T02:01:29.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>WebStorm的缩进规则和ESlint-vue的校验规则冲突引起的问题。</p><h4 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h4><ul><li>Vue项目</li><li>安装时打开ESLint校验功能</li><li>开发工具WebStorm</li></ul><p>代码格式化会出现两种：</p><a id="more"></a><p><strong>WebStorm格式化：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    exports default &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>ESlint格式化：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">exports default &#123;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>打开项目根下的.eslintrc.js文件，将rules节点中添加以下配置项，其中’2’是指统一缩进2个空格，’1’是指1倍缩进。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;vue/script-indent&apos;: [&apos;error&apos;, 2, &#123;&apos;baseIndent&apos;: 1&#125;]</span><br></pre></td></tr></table></figure><p>另外需要添加以下节点，与rules节点同级：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">overrides: [</span><br><span class="line">    &#123; &apos;files&apos;: [&apos;*.vue&apos;],</span><br><span class="line">      &apos;rules&apos;: &#123;</span><br><span class="line">      &apos;indent&apos;: &apos;off&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>问题搞定</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;WebStorm的缩进规则和ESlint-vue的校验规则冲突引起的问题。&lt;/p&gt;
&lt;h4 id=&quot;前提条件&quot;&gt;&lt;a href=&quot;#前提条件&quot; class=&quot;headerlink&quot; title=&quot;前提条件&quot;&gt;&lt;/a&gt;前提条件&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Vue项目&lt;/li&gt;
&lt;li&gt;安装时打开ESLint校验功能&lt;/li&gt;
&lt;li&gt;开发工具WebStorm&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码格式化会出现两种：&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="https://tangyanqiong.com/categories/Web/"/>
    
      <category term="Vue" scheme="https://tangyanqiong.com/categories/Web/Vue/"/>
    
    
      <category term="Vue" scheme="https://tangyanqiong.com/tags/Vue/"/>
    
      <category term="ESLint" scheme="https://tangyanqiong.com/tags/ESLint/"/>
    
      <category term="WebStorm" scheme="https://tangyanqiong.com/tags/WebStorm/"/>
    
  </entry>
  
  <entry>
    <title>Github代码下载提速</title>
    <link href="https://tangyanqiong.com/post/1e0383f0.html"/>
    <id>https://tangyanqiong.com/post/1e0383f0.html</id>
    <published>2019-07-25T08:06:27.000Z</published>
    <updated>2019-07-26T09:42:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前pod install安装GRPC出现各种错误，在网上找了各种办法，还重装过git以及pod都没有用，还是报类似如下错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[!] Error installing !ProtoCompiler</span><br><span class="line">[!] /usr/bin/curl -f -L -o /var/folders/1s/jw93vj050vq92gbrjv1c3x880000gn/T/d20190718-18563-1fzxwnx/file.zip https://github.com/google/protobuf/releases/download/v3.8.0/protoc-3.8.0-osx-x86_64.zip --create-dirs --netrc-optional --retry 2</span><br><span class="line"></span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100   162    0   162    0     0     11      0 --:--:--  0:00:14 --:--:--    39</span><br><span class="line">100   617    0   617    0     0     40      0 --:--:--  0:00:15 --:--:--  602k</span><br><span class="line"> 10 2794k   10  305k    0     0    835      0  0:57:06  0:06:14  0:50:52     0</span><br><span class="line">curl: (56) LibreSSL SSL_read: SSL_ERROR_SYSCALL, errno 54</span><br><span class="line"></span><br><span class="line">[!] Error installing BoringSSL-GRPC</span><br><span class="line">[!] /usr/bin/git clone https://github.com/google/boringssl.git /var/folders/1s/jw93vj050vq92gbrjv1c3x880000gn/T/d20190718-18162-1vck5op --template=</span><br><span class="line"></span><br><span class="line">Cloning into &apos;/var/folders/1s/jw93vj050vq92gbrjv1c3x880000gn/T/d20190718-18162-1vck5op&apos;...</span><br><span class="line">error: RPC failed; curl 18 transfer closed with outstanding read data remaining</span><br><span class="line">fatal: The remote end hung up unexpectedly</span><br><span class="line">fatal: early EOF</span><br><span class="line">fatal: index-pack failed</span><br></pre></td></tr></table></figure><p>之前没想过是网络的原因导致，因为挂VPN也出现了这种情况，后来一一排除，pod install –verbose 打印log，才发现根本就是github下载速度过慢，甚至连接超时导致。</p><p><strong>那怎么来提高github下载代码的速度呢？</strong></p><a id="more"></a><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="获取IP地址"><a href="#获取IP地址" class="headerlink" title="获取IP地址"></a>获取IP地址</h2><p>点击进入<a href="https://www.ipaddress.com/" target="_blank" rel="noopener">获取IP网址</a>，获取到本机对应以下三个网址的IP地址。</p><ul><li>github.com</li><li>github.global.ssl.fastly.net</li><li>codeload.github.com</li></ul><p><img src="https://i.loli.net/2019/07/25/5d396bea1360952904.png" alt="20190126112912387.png"></p><p>每个人的都不一样，这是我获取到的IP地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">140.82.113.4 github.com</span><br><span class="line">151.101.185.194 github.global.ssl.fastly.net</span><br><span class="line">140.82.114.9 codeload.github.com</span><br></pre></td></tr></table></figure><h2 id="修改系统hosts文件"><a href="#修改系统hosts文件" class="headerlink" title="修改系统hosts文件"></a>修改系统hosts文件</h2><h3 id="Windows系统"><a href="#Windows系统" class="headerlink" title="Windows系统"></a>Windows系统</h3><ul><li>hosts文件路径：C:\Windows\System32\drivers\etc\hosts ,</li><li>添加上面查询到的IP到hosts文件中（此时可能需要管理员权限,可以将hosts复制到桌面，修改好了再复制回去覆盖原来的）</li><li>修改完成后刷新DNS<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /flushdns</span><br></pre></td></tr></table></figure></li></ul><h3 id="Mac系统"><a href="#Mac系统" class="headerlink" title="Mac系统"></a>Mac系统</h3><p>在Finder-&gt;前往-&gt;前往文件夹，在框里输入/etc/hosts，找到hosts文件，可以将hosts文件复制到桌面，将ip地址添加到里面，修改好了再复制回去覆盖原来的hosts文件。</p><p><img src="https://i.loli.net/2019/07/25/5d396ef17c57396896.png" alt="82A13670-2C3E-445D-9E10-4088F2E438AD.png"><br>最后在终端执行刷新DNS命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dscacheutil -flushcache</span><br></pre></td></tr></table></figure><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>提速前的效果未截图，反正最快就是10多kb的样子，提速后效果如下：</p><p><img src="https://i.loli.net/2019/07/25/5d3970549b23037785.png" alt="68073D99-C3D9-4541-8E8A-B20C08C59A61.png"></p><p>GRPC报错的相关问题也迎刃而解。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;之前pod install安装GRPC出现各种错误，在网上找了各种办法，还重装过git以及pod都没有用，还是报类似如下错误。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[!] Error installing !ProtoCompiler&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[!] /usr/bin/curl -f -L -o /var/folders/1s/jw93vj050vq92gbrjv1c3x880000gn/T/d20190718-18563-1fzxwnx/file.zip https://github.com/google/protobuf/releases/download/v3.8.0/protoc-3.8.0-osx-x86_64.zip --create-dirs --netrc-optional --retry 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                 Dload  Upload   Total   Spent    Left  Speed&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;100   162    0   162    0     0     11      0 --:--:--  0:00:14 --:--:--    39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;100   617    0   617    0     0     40      0 --:--:--  0:00:15 --:--:--  602k&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 10 2794k   10  305k    0     0    835      0  0:57:06  0:06:14  0:50:52     0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;curl: (56) LibreSSL SSL_read: SSL_ERROR_SYSCALL, errno 54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[!] Error installing BoringSSL-GRPC&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[!] /usr/bin/git clone https://github.com/google/boringssl.git /var/folders/1s/jw93vj050vq92gbrjv1c3x880000gn/T/d20190718-18162-1vck5op --template=&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Cloning into &amp;apos;/var/folders/1s/jw93vj050vq92gbrjv1c3x880000gn/T/d20190718-18162-1vck5op&amp;apos;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;error: RPC failed; curl 18 transfer closed with outstanding read data remaining&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fatal: The remote end hung up unexpectedly&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fatal: early EOF&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fatal: index-pack failed&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;之前没想过是网络的原因导致，因为挂VPN也出现了这种情况，后来一一排除，pod install –verbose 打印log，才发现根本就是github下载速度过慢，甚至连接超时导致。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那怎么来提高github下载代码的速度呢？&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Others" scheme="https://tangyanqiong.com/categories/Others/"/>
    
    
      <category term="GRPC" scheme="https://tangyanqiong.com/tags/GRPC/"/>
    
      <category term="Github" scheme="https://tangyanqiong.com/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>Swift上View手势控制</title>
    <link href="https://tangyanqiong.com/post/a17aa0f4.html"/>
    <id>https://tangyanqiong.com/post/a17aa0f4.html</id>
    <published>2019-06-03T07:31:20.000Z</published>
    <updated>2019-06-06T02:00:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>对View进行放大缩小、移动、旋转，其实是很常见的需求，最开始在OC上，很早的几年，还是用的touch事件来实现，这种实现方式很繁琐，呈现的效果也不是很好。</p><p>后来，苹果也逐步的淘汰了这种方式，出了手势这种模式，极大程度上的缩减了代码量，而且操作简单，上手迅速，OC上手势的使用方式网上比比皆是，这里就不细说，着重介绍Swift View手势控制方法。</p><a id="more"></a><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>添加旋转、缩放、移动手势，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//Rotation</span><br><span class="line">let rotationGestureRecognizer = UIRotationGestureRecognizer(target: self, action: #selector(EditPhotoViewController.rotateView(_:)))</span><br><span class="line">photoImageView?.addGestureRecognizer(rotationGestureRecognizer)</span><br><span class="line"></span><br><span class="line">//Scale pinch</span><br><span class="line">let pinchGestureRecognizer = UIPinchGestureRecognizer(target: self, action: #selector(EditPhotoViewController.pinchView(_:)))</span><br><span class="line">photoImageView?.addGestureRecognizer(pinchGestureRecognizer)</span><br><span class="line"></span><br><span class="line">//Move</span><br><span class="line">let panGestureRecognizer = UIPanGestureRecognizer(target: self, action: #selector(EditPhotoViewController.panView(_:)))</span><br><span class="line">photoImageView?.addGestureRecognizer(panGestureRecognizer)</span><br></pre></td></tr></table></figure><p><strong>以下代码使用变量如下：</strong></p><blockquote><p>  private var cropFrame = CGRect.zero //图片上限制框的frame</p></blockquote><blockquote><p>  private var latestFrame = CGRect.zero //最大缩放frame</p></blockquote><blockquote><p>   private var rotationAngle: CGFloat = 0.0 //旋转的角度</p></blockquote><p><strong>给变量设置初始值：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private func resetShowImageViewFrame() &#123;</span><br><span class="line">   rotationAngle = 0.0</span><br><span class="line"></span><br><span class="line">   photoImageView?.image = originalImage</span><br><span class="line">   photoImageView?.transform = .identity</span><br><span class="line"></span><br><span class="line">   // scale to fit the screen</span><br><span class="line">   cropFrame = photoOverLayView?.transparentArea ?? CGRect.zero</span><br><span class="line"></span><br><span class="line">   var oriWidth: CGFloat = cropFrame.size.width</span><br><span class="line">   var oriHeight: CGFloat = (originalImage?.size.height ?? 0.0) * (oriWidth / (originalImage?.size.width ?? 0.0))</span><br><span class="line">   if ((originalImage?.size.width)!/(originalImage?.size.height)!) &gt; (CGFloat)(standardPostImgWidth)/(CGFloat)(standardPostImgHeight) &#123;</span><br><span class="line">      oriHeight = cropFrame.size.height</span><br><span class="line">      oriWidth = (originalImage?.size.width ?? 0.0) * (oriHeight / (originalImage?.size.height ?? 0.0))</span><br><span class="line">   &#125;</span><br><span class="line">   let oriX: CGFloat = cropFrame.origin.x + (cropFrame.size.width - oriWidth) / 2</span><br><span class="line">   let oriY: CGFloat = cropFrame.origin.y + (cropFrame.size.height - oriHeight) / 2</span><br><span class="line">   oldFrame = CGRect(x: oriX, y: oriY, width: oriWidth, height: oriHeight)</span><br><span class="line">   latestFrame = oldFrame</span><br><span class="line">   photoImageView?.frame = oldFrame</span><br><span class="line">   largeFrame = CGRect(x: 0, y: 0, width: limitRatio * oldFrame.size.width, height: limitRatio * oldFrame.size.height)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="旋转实现"><a href="#旋转实现" class="headerlink" title="旋转实现"></a>旋转实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@objc func rotateView(_ rotationGestureRecognizer: UIRotationGestureRecognizer?) &#123;</span><br><span class="line">   let view: UIView? = photoImageView</span><br><span class="line">   if rotationGestureRecognizer?.state == .began || rotationGestureRecognizer?.state == .changed &#123;</span><br><span class="line">      view?.transform = (view?.transform.rotated(by: (rotationGestureRecognizer?.rotation)!))!</span><br><span class="line">      rotationAngle = rotationAngle + (rotationGestureRecognizer?.rotation ?? 0.0)</span><br><span class="line">      rotationGestureRecognizer?.rotation = 0</span><br><span class="line">   &#125; else if rotationGestureRecognizer?.state == .ended &#123;</span><br><span class="line">      latestFrame = photoImageView?.frame ?? CGRect.zero</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缩放实现"><a href="#缩放实现" class="headerlink" title="缩放实现"></a>缩放实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@objc func pinchView(_ pinchGestureRecognizer: UIPinchGestureRecognizer?) &#123;</span><br><span class="line">   let view: UIView? = photoImageView</span><br><span class="line">   if pinchGestureRecognizer?.state == .began || pinchGestureRecognizer?.state == .changed &#123;</span><br><span class="line">      if rotationAngle == 0 &#123;</span><br><span class="line">       //narrow</span><br><span class="line">         if (pinchGestureRecognizer?.scale)! &lt;= CGFloat(1.0) &amp;&amp; ((photoImageView?.width)! &lt;= cropFrame.size.width || (photoImageView?.height)! &lt;= cropFrame.size.height) &#123;</span><br><span class="line">            return</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       //amplification</span><br><span class="line">       if (pinchGestureRecognizer?.scale)! &gt; CGFloat(1.0) &amp;&amp; ((photoImageView?.width)! &gt; 5000 || (photoImageView?.height)! &gt; 5000) &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        view?.transform = (view?.transform.scaledBy(x: (pinchGestureRecognizer?.scale)!, y: (pinchGestureRecognizer?.scale)!))!</span><br><span class="line">        pinchGestureRecognizer?.scale = 1</span><br><span class="line">    &#125; else if pinchGestureRecognizer?.state == .ended &#123;</span><br><span class="line">        if rotationAngle == 0 &#123;</span><br><span class="line">            var newFrame: CGRect? = photoImageView?.frame</span><br><span class="line">            //newFrame = handleScaleOverflow(newFrame ?? CGRect.zero)</span><br><span class="line">            newFrame = handleBorderOverflow(newFrame ?? CGRect.zero)</span><br><span class="line">            UIView.animate(withDuration: TimeInterval(BOUNDCE_DURATION), animations: &#123;</span><br><span class="line">            self.photoImageView?.frame = newFrame ?? CGRect.zero</span><br><span class="line">            self.latestFrame = newFrame ?? CGRect.zero</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            latestFrame = photoImageView?.frame ?? CGRect.zero</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="平移实现"><a href="#平移实现" class="headerlink" title="平移实现"></a>平移实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@objc func panView(_ panGestureRecognizer: UIPanGestureRecognizer?)</span><br><span class="line">&#123;</span><br><span class="line">   let view = panGestureRecognizer?.view;</span><br><span class="line">   if (panGestureRecognizer?.state == .began || panGestureRecognizer?.state == .changed) &#123;</span><br><span class="line">       let translation = panGestureRecognizer?.translation(in: view?.superview)</span><br><span class="line">       view?.center = CGPoint(x: (view?.center.x)! + (translation?.x)!, y: (view?.center.y)! + (translation?.y)!)</span><br><span class="line">       panGestureRecognizer?.setTranslation(CGPoint.zero, in: view?.superview)</span><br><span class="line">    &#125; else if panGestureRecognizer?.state == .ended &#123;</span><br><span class="line">        if rotationAngle == 0 &#123;</span><br><span class="line">           //bounce to original frame</span><br><span class="line">           var newFrame: CGRect? = photoImageView?.frame</span><br><span class="line">           newFrame = handleBorderOverflow(newFrame ?? CGRect.zero)</span><br><span class="line">           UIView.animate(withDuration: TimeInterval(BOUNDCE_DURATION), animations: &#123;</span><br><span class="line">               self.photoImageView?.frame = newFrame ?? CGRect.zero</span><br><span class="line">               self.latestFrame = newFrame ?? CGRect.zero</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">           latestFrame = photoImageView?.frame ?? CGRect.zero</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p><img src="https://i.loli.net/2019/06/03/5cf4ed0771faf64108.gif" alt="未命名.gif"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;对View进行放大缩小、移动、旋转，其实是很常见的需求，最开始在OC上，很早的几年，还是用的touch事件来实现，这种实现方式很繁琐，呈现的效果也不是很好。&lt;/p&gt;
&lt;p&gt;后来，苹果也逐步的淘汰了这种方式，出了手势这种模式，极大程度上的缩减了代码量，而且操作简单，上手迅速，OC上手势的使用方式网上比比皆是，这里就不细说，着重介绍Swift View手势控制方法。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://tangyanqiong.com/categories/iOS/"/>
    
      <category term="Swift" scheme="https://tangyanqiong.com/categories/iOS/Swift/"/>
    
    
      <category term="Swift" scheme="https://tangyanqiong.com/tags/Swift/"/>
    
      <category term="手势控制" scheme="https://tangyanqiong.com/tags/%E6%89%8B%E5%8A%BF%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>iPad控制多屏电视</title>
    <link href="https://tangyanqiong.com/post/a503d77d.html"/>
    <id>https://tangyanqiong.com/post/a503d77d.html</id>
    <published>2019-05-30T07:46:42.000Z</published>
    <updated>2019-07-26T09:48:49.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们公司有4个电视（内置机顶盒），用来展示公司的业务，平时经常会有客户来参观，电视下面是通过HDMI线连接的电脑，展示的实际是网页。</p><fancybox><img src="https://i.loli.net/2019/05/31/5cf0923211c8d15084.jpg" alt="5cef8c97a983892634.jpg"></fancybox><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>昨天下午领导提一个需求，因为演示的时候，需要操作，就得用电脑的鼠标在电视上点，屏幕太大鼠标又在电视下方，很不方便，不好操作，然后想借鉴别人公司，直接用iPad里控制4个电视来操作。</p><a id="more"></a><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><p><strong>用iPad来控制电视屏幕，是不是一听就很高大？</strong></p><p>哈哈，怎么控制？都不是一个系统，一个是windows系统，一个是iOS系统。讨论时，我提出了两个方案：</p><ul><li><ol><li>做个APP，把网页内嵌到里面，直接用自带的AirPlay把iPad投屏到电视，不用的电视，再切换投屏，这样在iPad上操作就会同步到电视。</li></ol></li><li><ol start="2"><li>因为展示的业务是web页，那么就用APP，在同一局域网给Web端发指令，或通过后台中转指令，以控制在电视上展示的网页。</li></ol></li></ul><h2 id="调研"><a href="#调研" class="headerlink" title="调研"></a>调研</h2><h3 id="1-投屏方案"><a href="#1-投屏方案" class="headerlink" title="1. 投屏方案"></a>1. 投屏方案</h3><p>这个方案，实际是时间成本最少的，说干就干，然后马上我这边就起了一个项目，嵌了一个网页在APP里，好吧，正式开始投屏，然后…</p><p><strong>结果：</strong></p><p>投屏是成功了的，但是呢，因为电视的屏幕比是16:9，而iPad是4:3，导致了在电视上，iPad的投屏屏幕显示不全，两边还有间隙，不是全屏，而且当初web端开发的网页尺寸也是固定的1920x1080，也就是为电视量身定做的，这个网页在iPad上也不能全屏显示。</p><p>这种硬件上及网页端的限制，不好改变，就放弃了这种方式。</p><h3 id="2-指令控制方案"><a href="#2-指令控制方案" class="headerlink" title="2. 指令控制方案"></a>2. 指令控制方案</h3><p>这个方案，需要和web端约定很多指令，基本指令像点击不同按钮的不同指令，而且比如上下滑动网页的距离，由于屏幕分辨率不一样，需要经过一定转换，才能是web端的对应距离等等问题。</p><p><strong>结果：</strong></p><p>诚如上面所说，这个开发成本会很大，而且有局限性，一旦网页内容改变，APP端需改动代码升级才能使用，这种做法不符合产品经理的预期，所以直接淘汰了。</p><h2 id="另辟蹊径"><a href="#另辟蹊径" class="headerlink" title="另辟蹊径"></a>另辟蹊径</h2><p>上面的两个方案告吹后，给产品经理说了结果，然后产品经理在网上找到了另一种方案，就是市面上这种类似TeamViewer的远程操控桌面软件，直接在iPad上安装软件，然后在PC上安装同样软件，使用iPad操控PC桌面。</p><h3 id="两种方案"><a href="#两种方案" class="headerlink" title="两种方案"></a>两种方案</h3><p>有了这个方案，就在网上找到了<a href="https://sunlogin.oray.com/zh_CN/" target="_blank" rel="noopener">向日葵</a>、<a href="https://www.splashtop.com/cn" target="_blank" rel="noopener">Splashtop</a>，这两个软件支持多端连接。</p><h4 id="1-向日葵"><a href="#1-向日葵" class="headerlink" title="1. 向日葵"></a>1. 向日葵</h4><p>安装和使用都比较简单，APP风格符合中国人的操作习惯，每次连接PC端都需要输入验证码（PC端的向日葵软件上），这样的话，每次切换连接不同电脑比较慢，操作体验不好。</p><fancybox><img src="https://i.loli.net/2019/05/30/5cefa66c0e85747877.png" alt="BAB22DB7-DCF2-460C-A034-F576BB64AF0F.png"></fancybox><h4 id="2-Splashtop"><a href="#2-Splashtop" class="headerlink" title="2. Splashtop"></a>2. Splashtop</h4><p>同样的，安装和使用都比较简单，是国外软件，风格偏欧美风，我其实比较喜欢这种操作方式，简单易懂，连接同一个电脑，连续输入两次验证码，下次再点击接该电脑就直接连接了。</p><fancybox><img src="https://i.loli.net/2019/05/30/5cefa66bdd93468731.jpg" alt="28ABD3EAB7E73EC5D89DD79D1255881D.jpg"></fancybox><p><strong>对比这两个软件，Splashtop切换不同电脑连接要更快些，而且不用每次都输验证码，相对方便些，所以就给产品经理推荐了这个软件来操作。</strong></p><h3 id="最终实施"><a href="#最终实施" class="headerlink" title="最终实施"></a>最终实施</h3><p>哈哈，以为这就OK了吗，NO，今天来公司，产品经理说昨晚给CEO看了，CEO觉得这样切换还是太慢，给了个建议，让4个电视通过HDMI方式连到一个电脑上，这样的话就用iPad操控一台电脑就可以了，不存在切换慢的问题了，仔细想了下，这种方案还真不错，有可行性，然后开撸，将4台电视连接到了一台电脑上（专门有HDMI拓展外接，所以接口足够），然后分屏显示。</p><h4 id="1-Splashtop连接"><a href="#1-Splashtop连接" class="headerlink" title="1. Splashtop连接"></a>1. Splashtop连接</h4><p>其实我真的是蛮喜欢Splashtop的，操作简单，可惜的是Splashtop只支持双屏显示，切换分屏始终只显示第1第2分屏。</p><fancybox><img src="https://i.loli.net/2019/05/30/5cefa66c15f5d36721.png" alt="DDC6ECBC-354F-477B-9DE6-930C9D6395BC.png"></fancybox><h4 id="2-向日葵连接"><a href="#2-向日葵连接" class="headerlink" title="2. 向日葵连接"></a>2. 向日葵连接</h4><p>换了向日葵来连接，满怀期望的希望它支持多屏，结果不负众望，4台分屏完美切换，速度流畅，好，就用它了。</p><fancybox><img src="https://i.loli.net/2019/05/30/5cefa66c1250218113.png" alt="B6B92F41-17AA-49AF-B2EF-73869B6C73F8.png"></fancybox><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的来说，这次需求完成还是比较满意的，上面领导也满意这个结果，这次分享希望能给需要iPad控制多屏电视的人带来帮助，有什么问题请在评论区告诉我吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;我们公司有4个电视（内置机顶盒），用来展示公司的业务，平时经常会有客户来参观，电视下面是通过HDMI线连接的电脑，展示的实际是网页。&lt;/p&gt;
&lt;fancybox&gt;&lt;img src=&quot;https://i.loli.net/2019/05/31/5cf0923211c8d15084.jpg&quot; alt=&quot;5cef8c97a983892634.jpg&quot;&gt;&lt;/fancybox&gt;

&lt;h2 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h2&gt;&lt;p&gt;昨天下午领导提一个需求，因为演示的时候，需要操作，就得用电脑的鼠标在电视上点，屏幕太大鼠标又在电视下方，很不方便，不好操作，然后想借鉴别人公司，直接用iPad里控制4个电视来操作。&lt;/p&gt;
    
    </summary>
    
      <category term="Others" scheme="https://tangyanqiong.com/categories/Others/"/>
    
    
      <category term="iPad控制多屏" scheme="https://tangyanqiong.com/tags/iPad%E6%8E%A7%E5%88%B6%E5%A4%9A%E5%B1%8F/"/>
    
      <category term="远程桌面控制" scheme="https://tangyanqiong.com/tags/%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E6%8E%A7%E5%88%B6/"/>
    
      <category term="向日葵" scheme="https://tangyanqiong.com/tags/%E5%90%91%E6%97%A5%E8%91%B5/"/>
    
      <category term="Splashtop" scheme="https://tangyanqiong.com/tags/Splashtop/"/>
    
  </entry>
  
  <entry>
    <title>Vue框架底层原理</title>
    <link href="https://tangyanqiong.com/post/d32be447.html"/>
    <id>https://tangyanqiong.com/post/d32be447.html</id>
    <published>2019-03-20T09:58:17.000Z</published>
    <updated>2019-07-26T09:44:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Vue框架是什么，怎么用，相信大家都已经很熟悉了，诚如<a href="https://www.runoob.com/vue2/vue-tutorial.html" target="_blank" rel="noopener">Vue教程</a>所说，它是一套构建用户界面的渐进式Web前端框架。</p><fancybox><img src="https://i.loli.net/2019/05/27/5ceb976f6b4eb74810.png" alt="image"></fancybox><p>但是很多人就是拿来主义，就只管用，博主也是这类人 = =!, 但是随着深入使用Vue，越发觉得深知其原理的重要性，那么，本文来探讨一下Vue的底层原理到底是什么，是怎么实现的。</p><a id="more"></a><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h2><p>Vue的底层原理总体来说就是深入响应式原理，它最独特的特性之一就是非侵入性的响应式系统。数据模型仅仅是普通的 JavaScript 对象。而当你修改它们时，视图会进行更新，这使得状态管理非常简单直接。</p><h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><h3 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h3><p>下面是一段代码，较直观的体现了Vue特点，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;mvvm-app&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&quot;word&quot;&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;word&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button v-on:click=&quot;sayHi&quot;&gt;change model&lt;/button&gt; //点击这个button，word的值会发生改变</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script src=&quot;./js/observer.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;./js/watcher.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;./js/compile.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;./js/mvvm.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var vm = new MVVM(&#123;</span><br><span class="line">        el: &apos;#mvvm-app&apos;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            word: &apos;Hello World!&apos;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            sayHi: function() &#123;</span><br><span class="line">                this.word = &apos;Hi, everybody!&apos;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>实现效果如下：</strong></p><p><img src="https://i.loli.net/2019/05/27/5ceba18d75b1079687.gif" alt="vue_test.gif"></p><p>而Vue实现数据双向绑定的效果，需要<strong>三大模块：</strong></p><ul><li><ol><li>Observer：对数据对象的所有属性进行监听，如有变动可拿到最新值并通知观察者</li></ol></li><li><ol start="2"><li>Compile：对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数</li></ol></li><li><ol start="3"><li>Watcher：作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图</li></ol></li></ul><fancybox><img src="https://i.loli.net/2019/05/27/5ceba2641810f80268.png" alt="vue_test2.png"></fancybox><h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><p>Observer的核心是通过Obeject.defineProperty()来监听数据的变动，这个函数内部可以定义setter和getter，每当数据发生变化，就会触发setter。这时候Observer就要通知订阅者，订阅者就是Watcher。</p><h3 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h3><p>Watcher订阅者作为Observer和Compile之间通信的桥梁，主要做的事情是：</p><ul><li><ol><li>在自身实例化时往属性订阅器(dep)里面添加自己</li></ol></li><li><ol start="2"><li>自身必须有一个update()方法</li></ol></li><li><ol start="3"><li>待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调</li></ol></li></ul><h3 id="Compile"><a href="#Compile" class="headerlink" title="Compile"></a>Compile</h3><p>Compile主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>MVVM 是Model-View-ViewModel 的缩写，它是一种基于前端开发的架构模式，其核心是提供对View 和 ViewModel 的双向数据绑定，这使得ViewModel 的状态改变可以自动传递给 View，即所谓的数据双向绑定。</p><p>而Vue框架则是一个提供了 MVVM 风格的双向数据绑定的 Javascript 库，专注于View 层。它的核心是 MVVM 中的 VM，也就是 ViewModel。 ViewModel负责连接 View 和 Model，保证视图和数据的一致性，这种轻量级的架构让前端开发更加高效、便捷。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Vue框架是什么，怎么用，相信大家都已经很熟悉了，诚如&lt;a href=&quot;https://www.runoob.com/vue2/vue-tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Vue教程&lt;/a&gt;所说，它是一套构建用户界面的渐进式Web前端框架。&lt;/p&gt;
&lt;fancybox&gt;&lt;img src=&quot;https://i.loli.net/2019/05/27/5ceb976f6b4eb74810.png&quot; alt=&quot;image&quot;&gt;&lt;/fancybox&gt;

&lt;p&gt;但是很多人就是拿来主义，就只管用，博主也是这类人 = =!, 但是随着深入使用Vue，越发觉得深知其原理的重要性，那么，本文来探讨一下Vue的底层原理到底是什么，是怎么实现的。&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="https://tangyanqiong.com/categories/Web/"/>
    
      <category term="Vue" scheme="https://tangyanqiong.com/categories/Web/Vue/"/>
    
    
      <category term="JavaScript" scheme="https://tangyanqiong.com/tags/JavaScript/"/>
    
      <category term="Vue" scheme="https://tangyanqiong.com/tags/Vue/"/>
    
      <category term="MVVM" scheme="https://tangyanqiong.com/tags/MVVM/"/>
    
  </entry>
  
  <entry>
    <title>初探JavaScript的变量</title>
    <link href="https://tangyanqiong.com/post/6e5ac6c0.html"/>
    <id>https://tangyanqiong.com/post/6e5ac6c0.html</id>
    <published>2019-02-25T08:12:34.000Z</published>
    <updated>2019-07-26T09:43:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本类型和引用类型的值"><a href="#基本类型和引用类型的值" class="headerlink" title="基本类型和引用类型的值"></a>基本类型和引用类型的值</h3><p><code>ECMAScript</code>变量一般有两种数据类型的值：<strong>基本类型和引用类型</strong>。</p><ul><li>基本类型： 简单的数据段：<code>Undefined, Null, Boolean, Number, String</code></li><li>引用类型：多个值构成的对象；</li></ul><a id="more"></a><h4 id="1-动态的属性"><a href="#1-动态的属性" class="headerlink" title="1. 动态的属性"></a>1. 动态的属性</h4><p>定义两者的值：创建一个变量并为其变量赋值；</p><p>执行两者的值：</p><ul><li>引用类型：可以添加、删除属性和方法；</li><li>基本类型：不能添加、删除属性和方法；</li></ul><p>比如：引用类型 a，可以添加属性 name age<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">a.name = <span class="string">"杨子龙"</span>;</span><br><span class="line">a.age = <span class="number">24</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a.name);                      <span class="comment">//杨子龙</span></span><br></pre></td></tr></table></figure></p><p>基本类型 name 无法添加属性 age<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"杨子龙"</span>;</span><br><span class="line">name.age  = <span class="number">24</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name.age);                 <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure></p><p>代码中可知：只能给引用类型值动态地添加属性，以便将来使用。</p><h4 id="2-赋值变量值"><a href="#2-赋值变量值" class="headerlink" title="2. 赋值变量值"></a>2. 赋值变量值</h4><p>从一个变量向另一个变量复制基本类型值和引用类型值时：</p><ul><li>基本类型：在变量对象上创建一个新值，并将其值复制给新变量分配的位置上；（完全独立的两个变量）<br>例如：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">111</span>;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line"><span class="built_in">console</span>.log(b);                 <span class="comment">//111</span></span><br></pre></td></tr></table></figure><p>代码中可知：变量b的值只是变量a的值的一个副本，两者的值111是完全独立的。</p><ul><li>引用类型：将存储在变量对象中的值复制一份放到为新变量分配的空间中；（引用同一个对象的两个变量）</li></ul><p>引用类型的值的副本实际是一个指针，指向存储在堆中的一个对象。<br>例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>;</span><br><span class="line"><span class="keyword">var</span> obj2 = obj1;</span><br><span class="line">obj1.name = <span class="string">"杨子龙"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj2,name);                 <span class="comment">// Object &#123; name="杨子龙"&#125; 杨子龙</span></span><br></pre></td></tr></table></figure></p><p>代码中可知：obj1和obj2都指向同一个对象Object；所以，为obj1添加的name属性，通过obj2也可以访问的到。</p><h4 id="3-传递参数"><a href="#3-传递参数" class="headerlink" title="3. 传递参数"></a>3. 传递参数</h4><p>我们都知道基本类型是<strong>按值访问</strong>的，因为可以访问保存在变量中的实际的值。<br>所有函数的参数都是<strong>按值传递</strong>的。</p><ul><li>基本类型：基本类型值的传递如同基本类型变量的复制一样；<br>在向参数传递值，被传递的值会被复制给一个局部变量（命名参数），因此这个局部变量的变化不会反映在函数的外部。</li></ul><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  num += <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> result = fn(a);</span><br><span class="line"><span class="built_in">console</span>.log(result);        <span class="comment">//20</span></span><br><span class="line"><span class="built_in">console</span>.log(a);             <span class="comment">//10</span></span><br></pre></td></tr></table></figure><p>代码中可知：参数num和变量a互不相识，只是有着相同的值而已，用完之后，你还是你，我还是我，互不干政。</p><ul><li>引用类型：引用类型的传递如同引用类型变量的复制一样；<br>在向参数传递值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。</li></ul><p>例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  obj.name = <span class="string">'杨子龙'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">fn(person);</span><br><span class="line"><span class="built_in">console</span>.log(person.name);           <span class="comment">//杨子龙</span></span><br></pre></td></tr></table></figure></p><p>代码中可知：在这个函数内部，参数obj和变量person引用的是同一个对象Object，所以，你不动我也不动，你动我也动，你中有我，我中有你，情义绵绵，经久不息……</p><p>也就是说：即使变量person是按值传递的，但是参数obj（想象成局部变量）还是会按引用来访问同一个对象。</p><blockquote><p> 访问变量有按值和按引用两种方式，参数只能按值传递。</p></blockquote><h4 id="4-检测类型"><a href="#4-检测类型" class="headerlink" title="4. 检测类型"></a>4. 检测类型</h4><ul><li>基本类型：<code>typeof</code></li><li>引用类型：<code>instanceof</code>（对象或null）</li></ul><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'Yang Zilong'</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">24</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">var</span> d = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> e;</span><br><span class="line"><span class="keyword">var</span> g = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">var</span> f = <span class="literal">null</span>;  <span class="comment">// 比较特殊</span></span><br><span class="line"><span class="keyword">var</span> h = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a); <span class="comment">//string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> b); <span class="comment">//number </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> c); <span class="comment">//string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> d); <span class="comment">//boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> e); <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> g); <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> f); <span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> h); <span class="comment">//object</span></span><br></pre></td></tr></table></figure><blockquote><p>所用引用类型的值都是Object的实例。</p></blockquote><p>如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">var</span> num = [<span class="number">1</span>,<span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/.at/i</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>);     <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(num <span class="keyword">instanceof</span> <span class="built_in">Object</span>);        <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(num <span class="keyword">instanceof</span> <span class="built_in">Array</span>);         <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern <span class="keyword">instanceof</span> <span class="built_in">Object</span>);    <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>);    <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><blockquote><p>使用<code>instanceof</code>检测基本类型，会返回<code>false</code>，基本类型不是对象。</p></blockquote><ul><li>参考资料：《JavaScript高级程序设计》（第三版）第四章</li><li>同步于： <a href="https://juejin.im/post/5c73a28cf265da2de52d9390" target="_blank" rel="noopener">掘金</a>、<a href="https://www.imooc.com/article/280082" target="_blank" rel="noopener">慕课网</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基本类型和引用类型的值&quot;&gt;&lt;a href=&quot;#基本类型和引用类型的值&quot; class=&quot;headerlink&quot; title=&quot;基本类型和引用类型的值&quot;&gt;&lt;/a&gt;基本类型和引用类型的值&lt;/h3&gt;&lt;p&gt;&lt;code&gt;ECMAScript&lt;/code&gt;变量一般有两种数据类型的值：&lt;strong&gt;基本类型和引用类型&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本类型： 简单的数据段：&lt;code&gt;Undefined, Null, Boolean, Number, String&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;引用类型：多个值构成的对象；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Web" scheme="https://tangyanqiong.com/categories/Web/"/>
    
      <category term="JS" scheme="https://tangyanqiong.com/categories/Web/JS/"/>
    
    
      <category term="JavaScript" scheme="https://tangyanqiong.com/tags/JavaScript/"/>
    
  </entry>
  
</feed>
