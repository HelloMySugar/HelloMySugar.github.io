<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Root&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://tangyanqiong.com/"/>
  <updated>2022-07-22T14:16:30.462Z</updated>
  <id>https://tangyanqiong.com/</id>
  
  <author>
    <name>Root</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>扁平数据结构转Tree</title>
    <link href="https://tangyanqiong.com/post/6033d016.html"/>
    <id>https://tangyanqiong.com/post/6033d016.html</id>
    <published>2021-08-01T11:05:33.000Z</published>
    <updated>2022-07-22T14:16:30.462Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>假如后台返回一个扁平的数据结构，转成树，应该怎么做呢？</p><p>打平的数据内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let arr = [</span><br><span class="line">    &#123;id: 1, name: &apos;部门1&apos;, pid: 0&#125;,</span><br><span class="line">    &#123;id: 2, name: &apos;部门2&apos;, pid: 1&#125;,</span><br><span class="line">    &#123;id: 3, name: &apos;部门3&apos;, pid: 1&#125;,</span><br><span class="line">    &#123;id: 4, name: &apos;部门4&apos;, pid: 3&#125;,</span><br><span class="line">    &#123;id: 5, name: &apos;部门5&apos;, pid: 4&#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><a id="more"></a><p>期望输出的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;id&quot;: 1,</span><br><span class="line">        &quot;name&quot;: &quot;部门1&quot;,</span><br><span class="line">        &quot;pid&quot;: 0,</span><br><span class="line">        &quot;children&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;id&quot;: 2,</span><br><span class="line">                &quot;name&quot;: &quot;部门2&quot;,</span><br><span class="line">                &quot;pid&quot;: 1,</span><br><span class="line">                &quot;children&quot;: []</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;id&quot;: 3,</span><br><span class="line">                &quot;name&quot;: &quot;部门3&quot;,</span><br><span class="line">                &quot;pid&quot;: 1,</span><br><span class="line">                &quot;children&quot;: [</span><br><span class="line">                    // 结果 ,,,</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>假如先不用考虑性能问题，实现功能即可。</p><p>可能10%的人没思路，没碰到过这种结构；60%的人说用过递归，有思路，给他个笔记本，但就是写不出来；20%的人在引导下，磕磕绊绊能写出来；剩下10%的人能写出来，但性能不是最佳。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>接下来，我们用几种方法来实现这个小算法</p><h2 id="什么是好算法，什么是坏算法"><a href="#什么是好算法，什么是坏算法" class="headerlink" title="什么是好算法，什么是坏算法"></a>什么是好算法，什么是坏算法</h2><p>判断一个算法的好坏，一般从<strong>执行时间</strong>和<strong>占用空间</strong>来看,执行时间越短，占用的内存空间越小，那么它就是好的算法。对应的，我们常常用时间复杂度代表执行时间，空间复杂度代表占用的内存空间。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间复杂度的计算并不是计算程序具体运行的时间，而是算法执行语句的次数。 随着<strong>n</strong>的不断<strong>增大</strong>，时间复杂度不断<strong>增大</strong>，算法<strong>花费时间</strong>越多。 </p><p>常见的时间复杂度有：</p><ul><li>常数阶O(1)</li><li>对数阶O(log2 n)</li><li>线性阶O(n)</li><li>线性对数阶O(n log2 n)</li><li>平方阶O(n^2)</li><li>立方阶O(n^3)</li><li>k次方阶O(n^K)</li><li>指数阶O(2^n)</li></ul><h3 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h3><ol><li>选取相对增长最高的项</li><li>最高项系数是都化为1</li><li>若是常数的话用O(1)表示 举个例子：如f(n)=3*n^4+3n+300 则 O(n)=n^4</li></ol><p>通常我们计算时间复杂度都是计算最坏情况。计算时间复杂度的要注意的几个点</p><ul><li>如果算法的执行时间不随n的增加而增长，假如算法中有上千条语句，执行时间也不过是一个较大的常数。此类算法的时间复杂度是O(1)。 举例如下：代码执行100次，是一个常数，复杂度也是O(1)。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let x = 1;</span><br><span class="line">while (x &lt;100) &#123;</span><br><span class="line"> x++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>有多个循环语句时候，算法的时间复杂度是由嵌套层数最多的循环语句中最内层语句的方法决定的。举例如下：在下面for循环当中，外层循环每执行一次，内层循环要执行n次，执行次数是根据n所决定的，时间复杂度是O(n^2)。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (i = 0; i &lt; n; i++)&#123;</span><br><span class="line">       for (j = 0; j &lt; n; j++) &#123;</span><br><span class="line">           // ...code</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>循环不仅与n有关，还与执行循环判断条件有关。举例如下：在代码中，如果arr[i]不等于1的话，时间复杂度是O(n)。如果arr[i]等于1的话，循环不执行，时间复杂度是O(0)。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(var i = 0; i&lt;n &amp;&amp; arr[i] !=1; i++) &#123;</span><br><span class="line">// ...code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>空间复杂度是对一个算法在运行过程中临时占用存储空间的大小。</p><h3 id="计算方法-1"><a href="#计算方法-1" class="headerlink" title="计算方法"></a>计算方法</h3><ol><li>忽略常数，用O(1)表示</li><li>递归算法的空间复杂度=(递归深度n)*(每次递归所要的辅助空间)<br>计算空间复杂度的简单几点</li></ol><ul><li>仅仅只复制单个变量，空间复杂度为O(1)。举例如下：空间复杂度为O(n) = O(1)。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a = 1;</span><br><span class="line">let b = 2;</span><br><span class="line">let c = 3;</span><br><span class="line">console.log(&apos;输出a,b,c&apos;, a, b, c);</span><br></pre></td></tr></table></figure><ul><li>递归实现，调用fun函数，每次都创建1个变量k。调用n次，空间复杂度O(n*1) = O(n)。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function fun(n) &#123;</span><br><span class="line">   let k = 10;</span><br><span class="line">   if (n == k) &#123;</span><br><span class="line">       return n;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       return fun(++n)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不考虑性能实现，递归遍历查找"><a href="#不考虑性能实现，递归遍历查找" class="headerlink" title="不考虑性能实现，递归遍历查找"></a>不考虑性能实现，递归遍历查找</h2><p>主要思路是提供一个递getChildren的方法，该方法递归去查找子集。 就这样，不用考虑性能，无脑去查，大多数人只知道递归，就是写不出来。。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 递归查找，获取children</span><br><span class="line"> */</span><br><span class="line">const getChildren = (data, result, pid) =&gt; &#123;</span><br><span class="line">  for (const item of data) &#123;</span><br><span class="line">    if (item.pid === pid) &#123;</span><br><span class="line">      const newItem = &#123;...item, children: []&#125;;</span><br><span class="line">      result.push(newItem);</span><br><span class="line">      getChildren(data, newItem.children, item.id);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 转换方法</span><br><span class="line">*/</span><br><span class="line">const arrayToTree = (data, pid) =&gt; &#123;</span><br><span class="line">  const result = [];</span><br><span class="line">  getChildren(data, result, pid)</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码我们分析，该实现的时间复杂度为O(2^n)。</p><h2 id="不用递归，也能搞定"><a href="#不用递归，也能搞定" class="headerlink" title="不用递归，也能搞定"></a>不用递归，也能搞定</h2><p>主要思路是先把数据转成Map去存储，之后遍历的同时借助对象的引用，直接从Map找对应的数据做存储</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function arrayToTree(items) &#123;</span><br><span class="line">  const result = [];   // 存放结果集</span><br><span class="line">  const itemMap = &#123;&#125;;  // </span><br><span class="line">    </span><br><span class="line">  // 先转成map存储</span><br><span class="line">  for (const item of items) &#123;</span><br><span class="line">    itemMap[item.id] = &#123;...item, children: []&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  for (const item of items) &#123;</span><br><span class="line">    const id = item.id;</span><br><span class="line">    const pid = item.pid;</span><br><span class="line">    const treeItem =  itemMap[id];</span><br><span class="line">    if (pid === 0) &#123;</span><br><span class="line">      result.push(treeItem);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      if (!itemMap[pid]) &#123;</span><br><span class="line">        itemMap[pid] = &#123;</span><br><span class="line">          children: [],</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      itemMap[pid].children.push(treeItem)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码我们分析，有两次循环，该实现的时间复杂度为O(2n)，需要一个Map把数据存储起来，空间复杂度O(n)</p><h2 id="最优性能"><a href="#最优性能" class="headerlink" title="最优性能"></a>最优性能</h2><p>主要思路也是先把数据转成Map去存储，之后遍历的同时借助对象的引用，直接从Map找对应的数据做存储。不同点在遍历的时候即做Map存储,有找对应关系。性能会更好。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">function arrayToTree(items) &#123;</span><br><span class="line">  const result = [];   // 存放结果集</span><br><span class="line">  const itemMap = &#123;&#125;;  // </span><br><span class="line">  for (const item of items) &#123;</span><br><span class="line">    const id = item.id;</span><br><span class="line">    const pid = item.pid;</span><br><span class="line"></span><br><span class="line">    if (!itemMap[id]) &#123;</span><br><span class="line">      itemMap[id] = &#123;</span><br><span class="line">        children: [],</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    itemMap[id] = &#123;</span><br><span class="line">      ...item,</span><br><span class="line">      children: itemMap[id][&apos;children&apos;]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const treeItem =  itemMap[id];</span><br><span class="line"></span><br><span class="line">    if (pid === 0) &#123;</span><br><span class="line">      result.push(treeItem);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      if (!itemMap[pid]) &#123;</span><br><span class="line">        itemMap[pid] = &#123;</span><br><span class="line">          children: [],</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      itemMap[pid].children.push(treeItem)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码我们分析，一次循环就搞定了，该实现的时间复杂度为O(n)，需要一个Map把数据存储起来，空间复杂度O(n)</p><h2 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h2><p>方法         1000(条)      10000(条）    20000(条）       50000(条)</p><p>递归实现   154.596ms    1.678s         7.152s               75.412s</p><p>不用递归，两次遍历   0.793ms     16.499ms      45.581ms     97.373ms</p><p>不用递归，一次遍历    0.639ms     6.397ms    25.436ms    44.719ms</p><p><strong>从我们的测试结果来看，随着数量的增大，递归的实现会越来越慢，基本成指数的增长方式。</strong></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>实践出真理，大家共勉进步。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;假如后台返回一个扁平的数据结构，转成树，应该怎么做呢？&lt;/p&gt;
&lt;p&gt;打平的数据内容如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let arr = [&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;id: 1, name: &amp;apos;部门1&amp;apos;, pid: 0&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;id: 2, name: &amp;apos;部门2&amp;apos;, pid: 1&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;id: 3, name: &amp;apos;部门3&amp;apos;, pid: 1&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;id: 4, name: &amp;apos;部门4&amp;apos;, pid: 3&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;id: 5, name: &amp;apos;部门5&amp;apos;, pid: 4&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Web" scheme="https://tangyanqiong.com/categories/Web/"/>
    
      <category term="JS" scheme="https://tangyanqiong.com/categories/Web/JS/"/>
    
    
      <category term="JavaScript" scheme="https://tangyanqiong.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>浏览器输入url到页面渲染过程</title>
    <link href="https://tangyanqiong.com/post/7429757f.html"/>
    <id>https://tangyanqiong.com/post/7429757f.html</id>
    <published>2020-08-28T11:05:33.000Z</published>
    <updated>2022-07-22T13:14:14.232Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>相信很多人都会被面试到一道比较综合的面试题，答案也不是固定的，从浏览器输入地址到页面渲染经过了很多的过程，且每个过程都可以深挖出很多知识点，面试官可以用这一道题区分出不同面试者的水平。下面我们就来具体学习下。</p><p><strong>构建请求</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET/HTTP/1.1;</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="查找强缓存"><a href="#查找强缓存" class="headerlink" title="查找强缓存"></a>查找强缓存</h2><p>浏览器会先检查是否存在缓存，如果存在缓存就直接从缓存里面拿数据，给到浏览器进行渲染</p><h2 id="DNS-解析"><a href="#DNS-解析" class="headerlink" title="DNS 解析"></a>DNS 解析</h2><p>由于我们输入的是域名，而数据包是通过 IP 地址传给对方的。因此我们需要得到域名对应的 IP 地址。这个过程需要依赖一个服务系统，这个系统将域名和 IP 一一映射，我们将这个系统就叫做 DNS（域名系统）。得到具体 IP 的过程就是 DNS 解析。 当然，值得注意的是，浏览器提供了 DNS 数据缓存功能。即如果一个域名已经解析过，那会把解析的结果缓存下来，下次处理直接走缓存，不需要经过 DNS 解析</p><h2 id="建立-TCP-连接"><a href="#建立-TCP-连接" class="headerlink" title="建立 TCP 连接"></a>建立 TCP 连接</h2><p>建立 TCP 连接经历了下面三个阶段</p><ul><li>通过三次握手(即总共发送 3 个数据包确认已经建立连接)建立客户端和服务器之间的连接。</li><li>进行数据传输。这里有一个重要的机制，就是接收方接收到数据包后必须要向发送方确认, 如果发送方没有接到这个确认的消息，就判定为数据包丢失，并重新发送该数据包。当然，发送的过程中还有一个优化策略，就是把大的数据包拆成一个个小包，依次传输到接收方，接收方按照这个小包的顺序把它们组装成完整数据包。</li><li>断开连接的阶段。数据传输完成，现在要断开连接了，通过四次挥手来断开连接。</li></ul><p>TCP 就是通过三次握手确认连接，数据包校验保证数据到达接收方，然后通过四次挥手断开连接保证数据传输的可靠性</p><h2 id="发送-HTTP-请求"><a href="#发送-HTTP-请求" class="headerlink" title="发送 HTTP 请求"></a>发送 HTTP 请求</h2><p>现在 TCP 连接建立完毕，浏览器可以和服务器开始通信，即开始发送 HTTP 请求。浏览器发 HTTP 请求要携带三样东西:请求行、请求头和请求体</p><h2 id="网络响应"><a href="#网络响应" class="headerlink" title="网络响应"></a>网络响应</h2><p>HTTP 请求到达服务器，服务器进行对应的处理。最后要把数据传给浏览器，也就是返回网络响应。</p><p>响应头包含了服务器及其返回数据的一些信息, 服务器生成数据的时间、返回的数据类型以及对即将写入的 Cookie 信息。如果请求头或响应头中包含 Connection: Keep-Alive，表示建立了持久连接，这样 TCP 连接会一直保持，之后请求统一站点的资源会复用这个连接。</p><h2 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a>页面渲染</h2><p>完成以上过程后，数据已经达到浏览器端，接下来就是浏览器解析并渲染数据了</p><h2 id="解析过程"><a href="#解析过程" class="headerlink" title="解析过程"></a>解析过程</h2><ol><li>构建 DOM 树</li></ol><p>由于浏览器无法直接理解 HTML 字符串，因此将这一系列的字节流转换为一种有意义并且方便操作的数据结构，这种数据结构就是 DOM 树。DOM 树本质上是一个以 document 为根节点的多叉树</p><ol start="2"><li>样式计算</li></ol><p>首先，浏览器是无法直接识别 CSS 样式文本的，因此渲染引擎接收到 CSS 文本之后第一件事情就是将其转化为一个结构化的对象，即 styleSheets。 这个格式化的过程过于复杂，而且对于不同的浏览器会有不同的优化策略，这里就不展开了。 在浏览器控制台能够通过 document.styleSheets 来查看这个最终的结构。当然，这个结构包含了以上三种 CSS 来源，为后面的样式操作提供了基础。</p><ol start="3"><li>生成布局树</li></ol><p>现在已经生成了 DOM 树和 DOM 样式，接下来要做的就是通过浏览器的布局系统确定元素的位置，也就是要生成一棵布局树(Layout Tree)。 布局树生成的大致工作如下:</p><ul><li>遍历生成的 DOM 树节点，并把他们添加到布局树中；</li><li>计算布局树节点的坐标位置。</li></ul><p>值得注意的是，布局树只包含可见元素，对于 head 标签和设置了 display: none 的元素，将不会被放入其中。</p><h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><ol><li>构建 DOM 树</li></ol><p>浏览器将 HTML 解析成树形结构的 DOM 树，一般来说，这个过程发生在页面初次加载，或页面 JavaScript 修改了节点结构的时候</p><ol start="2"><li>构建渲染树</li></ol><p>浏览器将 CSS 解析成树形结构的 CSSOM 树，再和 DOM 树合并成渲染树</p><ol start="3"><li>布局（Layout）</li></ol><p>浏览器根据渲染树所体现的节点、各个节点的 CSS 定义以及它们的从属关系，计算出每个节点在屏幕中的位置。Web 页面中元素的布局是相对的，在页面元素位置、大小发生变化，往往会导致其他节点联动，需要重新计算布局，这时候的布局过程一般被称为回流（Reflow）。</p><ol start="4"><li>绘制（Paint）</li></ol><p>遍历渲染树，调用渲染器的 paint() 方法在屏幕上绘制出节点内容，本质上是一个像素填充的过程。这个过程也出现于回流或一些不影响布局的 CSS 修改引起的屏幕局部重画，这时候它被称为重绘（Repaint）。实际上，绘制过程是在多个层上完成的，这些层我们称为 渲染层（RenderLayer）</p><ol start="5"><li>渲染层合成（Composite）</li></ol><p>多个绘制后的渲染层按照恰当的重叠顺序进行合并，而后生成位图，最终通过显卡展示到屏幕上。</p><p><strong>那什么是渲染层合成呢？</strong></p><p>在 DOM 树中每个节点都会对应一个渲染对象（RenderObject），当它们的渲染对象处于相同的坐标空间（z 轴空间）时，就会形成一个 RenderLayers，也就是渲染层。渲染层将保证页面元素以正确的顺序堆叠，这时候就会出现层合成（composite），从而正确处理透明元素和重叠元素的显示。 这个模型类似于 Photoshop 的图层模型，在 Photoshop 中，每个设计元素都是一个独立的图层，多个图层以恰当的顺序在 z 轴空间上叠加，最终构成一个完整的设计图。 对于有位置重叠的元素的页面，这个过程尤其重要，因为一旦图层的合并顺序出错，将会导致元素显示异常。</p><ol start="6"><li>显示器显示内容</li></ol><p>栅格化操作完成后，合成线程会生成一个绘制命令，即”DrawQuad”，并发送给浏览器进程。 浏览器进程中的 viz 组件接收到这个命令，根据这个命令把页面内容绘制到内存，也就是生成了页面，然后把这部分内存发送给显卡，从而展示在屏幕上。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>从浏览器的渲染过程中我们知道，页面 HTML 会被解析成 DOM 树，每个 HTML 元素对应了树结构上的一个 node 节点。而从 DOM 树转化到一个个的渲染层，并最终执行合并、绘制的过程，中间其实还存在一些过渡的数据结构，它们记录了 DOM 树到屏幕图形的转化原理，其本质也就是树结构到层结构的演化。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;相信很多人都会被面试到一道比较综合的面试题，答案也不是固定的，从浏览器输入地址到页面渲染经过了很多的过程，且每个过程都可以深挖出很多知识点，面试官可以用这一道题区分出不同面试者的水平。下面我们就来具体学习下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;构建请求&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;GET/HTTP/1.1;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Web" scheme="https://tangyanqiong.com/categories/Web/"/>
    
      <category term="JS" scheme="https://tangyanqiong.com/categories/Web/JS/"/>
    
    
      <category term="JavaScript" scheme="https://tangyanqiong.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>vue3双向数据绑定原理</title>
    <link href="https://tangyanqiong.com/post/acef5003.html"/>
    <id>https://tangyanqiong.com/post/acef5003.html</id>
    <published>2020-07-18T12:25:45.000Z</published>
    <updated>2022-07-22T12:55:31.064Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>什么是双向数据绑定，这里就不做赘述了，vue的双向数据绑定是什么大家都很了解了，这里主要讲vue2和vue3中双向绑定的区别。</p><p>vue2中使用“Object.defineProperty”对象以及对象属性的劫持实现双向绑定；而vue3中的响应式采用了ES6中的“Proxy”方法实现双向绑定。</p><a id="more"></a><h1 id="为什么要替换vue2的双向数据绑定"><a href="#为什么要替换vue2的双向数据绑定" class="headerlink" title="为什么要替换vue2的双向数据绑定"></a>为什么要替换vue2的双向数据绑定</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>关于对象： Vue 无法检测 property 的添加或移除。<br>关于数组：不能利用索引直接设置一个数组项,也不能修改数组的长度。</p><p>总结来说Object.defineProperty方法存在一定的局限性</p><ol><li>在Vue中，Object.defineProperty无法监控到数组下标的变化，导致直接通过数组的下标给数组设置值，不能实时响应。 为了解决这个问题，经过vue内部处理后可以使用以下几种方法来监听数组（ Vue为什么不能检测数组变动）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">push()</span><br><span class="line">pop()</span><br><span class="line">shift()</span><br><span class="line">unshift()</span><br><span class="line">splice()</span><br><span class="line">sort()</span><br><span class="line">reverse()</span><br></pre></td></tr></table></figure><ol start="2"><li>Object.defineProperty只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历。Vue里，是通过递归以及遍历data对象来实现对数据的监控的，如果属性值也是对象那么需要深度遍历,显然如果能劫持一个完整的对象，不管是对操作性还是性能都会有一个很大的提升。</li></ol><h1 id="vue3双向绑定原理"><a href="#vue3双向绑定原理" class="headerlink" title="vue3双向绑定原理"></a>vue3双向绑定原理</h1><h2 id="什么是Proxy"><a href="#什么是Proxy" class="headerlink" title="什么是Proxy"></a>什么是Proxy</h2><p>Proxy 是ES6中新增的一个特性，可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p><p>基本用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。</span><br><span class="line">var proxy = new Proxy(target, handler);</span><br></pre></td></tr></table></figure><p>参数解释</p><ol><li>target: 是用Proxy包装的被代理对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。</li><li>handler: 是一个对象，其声明了代理target 的一些操作，其属性是当执行一个操作时定义代理的行为的函数。<br>Proxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法</li></ol><h2 id="Proxy的13种拦截"><a href="#Proxy的13种拦截" class="headerlink" title="Proxy的13种拦截"></a>Proxy的13种拦截</h2><ul><li>get(target, propKey, receiver)：拦截对象属性的读取，比如proxy.foo和proxy[‘foo’]。</li><li>set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo = v或proxy[‘foo’] = v，返回一个布尔值。</li><li>has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值。</li><li>deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值。</li><li>ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for…in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。</li><li>getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。</li><li>defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。</li><li>preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值。</li><li>getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象。</li><li>isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值。</li><li>setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</li><li>apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。</li><li>construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。</li></ul><p><strong>例子</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// #注：Proxy 实例也可以作为其他对象的原型对象。</span><br><span class="line">var proxy = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  get: function(target, property) &#123;</span><br><span class="line">    return 35;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">let obj = Object.create(proxy);</span><br><span class="line">obj.time // 35</span><br><span class="line"></span><br><span class="line">var handler = &#123;</span><br><span class="line">  get: function(target, name) &#123;</span><br><span class="line">    if (name === &apos;prototype&apos;) &#123;</span><br><span class="line">      return Object.prototype;</span><br><span class="line">    &#125;</span><br><span class="line">    return &apos;Hello, &apos; + name;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  apply: function(target, thisBinding, args) &#123;</span><br><span class="line">    return args[0];</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  construct: function(target, args) &#123;</span><br><span class="line">    return &#123;value: args[1]&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var fproxy = new Proxy(function(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;, handler);</span><br><span class="line"></span><br><span class="line">fproxy(1, 2) // 1</span><br><span class="line">new fproxy(1, 2) // &#123;value: 2&#125;</span><br><span class="line">fproxy.prototype === Object.prototype // true</span><br><span class="line">fproxy.foo === &quot;Hello, foo&quot; // true</span><br></pre></td></tr></table></figure><h2 id="Proxy实现数据劫持"><a href="#Proxy实现数据劫持" class="headerlink" title="Proxy实现数据劫持"></a>Proxy实现数据劫持</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">observe(data) &#123;</span><br><span class="line">  const that = this;</span><br><span class="line">  let handler = &#123;</span><br><span class="line">   get(target, property) &#123;</span><br><span class="line">      return target[property];</span><br><span class="line">    &#125;,</span><br><span class="line">    set(target, key, value) &#123;</span><br><span class="line">      let res = Reflect.set(target, key, value);</span><br><span class="line">      that.subscribe[key].map(item =&gt; &#123;</span><br><span class="line">        item.update();</span><br><span class="line">      &#125;);</span><br><span class="line">      return res;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  this.$data = new Proxy(data, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;什么是双向数据绑定，这里就不做赘述了，vue的双向数据绑定是什么大家都很了解了，这里主要讲vue2和vue3中双向绑定的区别。&lt;/p&gt;
&lt;p&gt;vue2中使用“Object.defineProperty”对象以及对象属性的劫持实现双向绑定；而vue3中的响应式采用了ES6中的“Proxy”方法实现双向绑定。&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="https://tangyanqiong.com/categories/Web/"/>
    
      <category term="JS" scheme="https://tangyanqiong.com/categories/Web/JS/"/>
    
    
      <category term="JavaScript" scheme="https://tangyanqiong.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>什么是闭包及防抖节流</title>
    <link href="https://tangyanqiong.com/post/c980d613.html"/>
    <id>https://tangyanqiong.com/post/c980d613.html</id>
    <published>2020-05-02T10:05:42.000Z</published>
    <updated>2022-07-22T12:55:31.065Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>通常情况下，声明在一个函数中的函数，叫做闭包函数，在Javascript语言中，只有函数内部的子函数才能读取局部变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 闭包函数</span><br><span class="line">function f1()&#123;</span><br><span class="line"> var n;</span><br><span class="line"> return function () &#123;</span><br><span class="line">    n ++;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>让外部访问函数内部变量成为可能<br>可以避免使用全局变量，防止全局变量污染</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>局部变量会常驻在内存中，会造成内存泄漏（有一块内存空间被长期占用，而不被释放）</p><h1 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h1><p>设想有此场景：输入框中内容变化需要实时请求接口以获取最新搜索结果，如果在输入完成前输入框内容每变化一下都去请求接口，会造成很多不必要的请求，大大增加服务器压力。</p><p>解决思路：有变化时延迟一段时间再执行function，若在这段延迟时间内又有新变化，则重新开始延迟</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 定时器期间，有新操作时，清空旧定时器，重设新定时器</span><br><span class="line">var debounce = (fn, wait) =&gt; &#123;</span><br><span class="line">   let timer, timeStamp=0;</span><br><span class="line">   let context, args;</span><br><span class="line">  </span><br><span class="line">    let run = ()=&gt;&#123;</span><br><span class="line">        timer= setTimeout(()=&gt;&#123;</span><br><span class="line">            fn.apply(context,args);</span><br><span class="line">       &#125;,wait);</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   let clean = () =&gt; &#123;</span><br><span class="line">       clearTimeout(timer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   return function() &#123;</span><br><span class="line">      context = this;</span><br><span class="line">      args = arguments;</span><br><span class="line">      let now = (new Date()).getTime();</span><br><span class="line">      if (now-timeStamp &lt; wait) &#123;</span><br><span class="line">          console.log(&apos;reset&apos;,now);</span><br><span class="line">          // 清除定时器，并重新加入延迟 </span><br><span class="line">          clean(); </span><br><span class="line">          run();</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          console.log(&apos;set&apos;,now);</span><br><span class="line">          run();  // last timer alreay executed, set a new timer</span><br><span class="line">      &#125;</span><br><span class="line">       timeStamp = now;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码进一步优化：周期内有新事件触发时，重置定时器开始时间戳，定时器执行时，判断开始时间戳，若开始时间戳被推后，重新设定延时定时器；加入是否立即执行参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// 增加前缘触发功能</span><br><span class="line">var debounce = (fn, wait, immediate=false) =&gt; &#123;</span><br><span class="line">    let timer, startTimeStamp=0;</span><br><span class="line">    let context, args;</span><br><span class="line"> </span><br><span class="line">    let run = (timerInterval) =&gt; &#123;</span><br><span class="line">        timer= setTimeout(() =&gt; &#123;</span><br><span class="line">            let now = (new Date()).getTime();</span><br><span class="line">            let interval = now-startTimeStamp</span><br><span class="line">            if(interval &lt; timerInterval) &#123; // the timer start time has been reset，so the interval is less than timerInterval</span><br><span class="line">                console.log(&apos;debounce reset&apos;,timerInterval-interval);</span><br><span class="line">                startTimeStamp = now;</span><br><span class="line">                run(wait-interval);  // reset timer for left time </span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (!immediate) &#123;</span><br><span class="line">                    fn.apply(context,args);</span><br><span class="line">                &#125;</span><br><span class="line">                clearTimeout(timer);</span><br><span class="line">                timer=null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, timerInterval);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return function() &#123;</span><br><span class="line">        context = this;</span><br><span class="line">        args = arguments;</span><br><span class="line">        let now = (new Date()).getTime();</span><br><span class="line">        startTimeStamp = now; // set timer start time</span><br><span class="line"> </span><br><span class="line">        if(!timer) &#123;</span><br><span class="line">            console.log(&apos;debounce set&apos;,wait);</span><br><span class="line">            if(immediate) &#123;</span><br><span class="line">                fn.apply(context,args);</span><br><span class="line">            &#125;</span><br><span class="line">            run(wait);    // last timer alreay executed, set a new timer</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h1><p>设想有此场景：有‘搜索’按钮，每点击一次都会重新请求接口，获取并渲染页面表格最新数据，假如短时间内连续点击按钮，依然会造成很多不必要的请求<br>解决思路：在一段时间内只执行最后一次function</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">// 定时器期间，只执行最后一次操作</span><br><span class="line">var throttling = (fn, wait) =&gt; &#123;</span><br><span class="line">    let timer;</span><br><span class="line">    let context, args;</span><br><span class="line"> </span><br><span class="line">    let run = () =&gt; &#123;</span><br><span class="line">        timer=setTimeout(()=&gt;&#123;</span><br><span class="line">            fn.apply(context,args);</span><br><span class="line">            clearTimeout(timer);</span><br><span class="line">            timer=null;</span><br><span class="line">        &#125;,wait);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return function () &#123;</span><br><span class="line">        context=this;</span><br><span class="line">        args=arguments;</span><br><span class="line">        if(!timer)&#123;</span><br><span class="line">            console.log(&quot;throttle, set&quot;);</span><br><span class="line">            run();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            console.log(&quot;throttle, ignore&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 增加前缘</span><br><span class="line">var throttling = (fn, wait, immediate) =&gt; &#123;</span><br><span class="line">    let timer, timeStamp=0;</span><br><span class="line">    let context, args;</span><br><span class="line"> </span><br><span class="line">    let run = () =&gt; &#123;</span><br><span class="line">        timer=setTimeout(()=&gt;&#123;</span><br><span class="line">            if(!immediate)&#123;</span><br><span class="line">                fn.apply(context,args);</span><br><span class="line">            &#125;</span><br><span class="line">            clearTimeout(timer);</span><br><span class="line">            timer=null;</span><br><span class="line">        &#125;,wait);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return function () &#123;</span><br><span class="line">        context=this;</span><br><span class="line">        args=arguments;</span><br><span class="line">        if(!timer)&#123;</span><br><span class="line">            console.log(&quot;throttle, set&quot;);</span><br><span class="line">            if(immediate)&#123;</span><br><span class="line">                fn.apply(context,args);</span><br><span class="line">            &#125;</span><br><span class="line">            run();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            console.log(&quot;throttle, ignore&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>防抖及节流都是使用闭包函数来应用的实际场景，平时也应注意合理使用闭包函数，避免性能消耗过多。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;通常情况下，声明在一个函数中的函数，叫做闭包函数，在Javascript语言中，只有函数内部的子函数才能读取局部变量：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 闭包函数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function f1()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; var n;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; return function () &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    n ++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Web" scheme="https://tangyanqiong.com/categories/Web/"/>
    
      <category term="JS" scheme="https://tangyanqiong.com/categories/Web/JS/"/>
    
    
      <category term="JavaScript" scheme="https://tangyanqiong.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Flutter最新版本环境搭建报错</title>
    <link href="https://tangyanqiong.com/post/dc7fb27e.html"/>
    <id>https://tangyanqiong.com/post/dc7fb27e.html</id>
    <published>2020-04-15T06:24:35.000Z</published>
    <updated>2022-07-20T16:53:04.194Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近更新到Mac OS最新系统Catalina，重装了Flutter，出现了些问题，在网上也搜索了，可能是才出的新版本问题，也没找到解决办法，最终自己捣鼓解决了此问题，随笔记录下此问题。 </p><a id="more"></a><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>正常搭建Flutter的过程就不说了，到最后一步执行<code>flutter doctor</code>时报错如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">TangYanQiong-MacbookPro:~ TangDan$ flutter doctor</span><br><span class="line">Doctor summary (to see all details, run flutter doctor -v):</span><br><span class="line">[✓] Flutter (Channel master, v1.18.0-5.0.pre.57, on Mac OS X 10.15.4 19E287,</span><br><span class="line">    locale zh-Hans-CN)</span><br><span class="line">[!] Android toolchain - develop for Android devices (Android SDK version 29.0.3)</span><br><span class="line">    ✗ Android license status unknown.</span><br><span class="line">      Try re-installing or updating your Android SDK Manager.</span><br><span class="line">      See https://developer.android.com/studio/#downloads or visit visit</span><br><span class="line">      https://flutter.dev/docs/get-started/install/macos#android-setup for</span><br><span class="line">      detailed instructions.</span><br><span class="line">[✓] Xcode - develop for iOS and macOS (Xcode 11.4)</span><br><span class="line">[✓] Android Studio (version 3.6)</span><br><span class="line"> </span><br><span class="line">[!] Connected device                          </span><br><span class="line">    ! No devices available</span><br><span class="line"></span><br><span class="line">! Doctor found issues in 2 categories.</span><br></pre></td></tr></table></figure><p>网上查了，大多答案都是让执行<code>flutter doctor --android-licenses</code>，结果又报错如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TangYanQiong-MacbookPro:~ TangDan$ flutter doctor --android-licenses</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Android sdkmanager tool not found</span><br><span class="line">(/Users/TangDan/Library/Android/sdk/tools/bin/sdkmanager).</span><br><span class="line">Try re-installing or updating your Android SDK,</span><br><span class="line">visit https://flutter.dev/docs/get-started/install/macos#android-setup for</span><br><span class="line">detailed instructions.</span><br></pre></td></tr></table></figure><p>这个意思是说，Android sdkmanager tool没找到，然后按照提示的目录信息，去找了一下，发现我的sdk目录下，根本就没有tools这个文件夹，后来调查发现，这个tools文件实际上是android studio安装了Android SDK Tools才会有生成那个文件夹，在这里勾选安装，如果你本地有这个的话，安装了应该就好了。</p><p><img src="https://i.loli.net/2020/04/14/banc4LTCiGfH6uM.png" alt="20190305104220816.png"></p><p>但是我本地并没有这个选项，我这边的Android SDK配置是这样的，根本没有tools这个安装包，只有Command-line Tools这个，有点类似，就也勾选安装了：<br><img src="https://i.loli.net/2020/04/14/VzNalLOkI4bX52F.jpg" alt="921794A9-2AA5-414D-BB73-B2C8E04D6DC6.png"></p><p>安装成功后的目录如下：<br><img src="https://i.loli.net/2020/04/14/AQrYhRKN8gBdO2y.jpg" alt="8C0A4825-8370-4CE2-9421-BEB561E68F24.png"></p><p>还是没有tools这个文件夹，但是sdkmanager有了，后面自己想了下，不是缺tools吗？只是路径不对的问题了，就自己新建了个tools，里面在创建了个bin文件夹，再把sdkmanager拷进去。<br><img src="https://i.loli.net/2020/04/14/RGnK1e3mx4LZIph.jpg" alt="27225CB4-388F-4C7C-8EDD-99A3C0C2C242.png"><br><img src="https://i.loli.net/2020/04/14/JXTMI9Pfw821ySe.jpg" alt="9D0FB5F4-C0DF-44A0-9C8C-421482B40E32.png"></p><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>猜想是，Android Studio最新版本Tools版本、名称及路径修改了，但是flutter最新版本并未更新，还是使用老路径导致找不到。</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>现在再来执行<code>flutter doctor --android-licenses</code>，一路<code>y</code>下去，设置成功。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TangYanQiong-MacbookPro:~ TangDan$ flutter doctor --android-licenses</span><br><span class="line">5 of 7 SDK package licenses not accepted. 100% Computing updates...             </span><br><span class="line">Review licenses that have not been accepted (y/N)? y</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>最后，再执行<code>flutter doctor</code>，大功告成，不报错了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TangYanQiong-MacbookPro:~ TangDan$ flutter doctor</span><br><span class="line">[✓] Flutter (Channel master, v1.18.0-5.0.pre.57, on Mac OS X 10.15.4 19E287,</span><br><span class="line">    locale zh-Hans-CN)</span><br><span class="line"> </span><br><span class="line">[✓] Android toolchain - develop for Android devices (Android SDK version 29.0.3)</span><br><span class="line">[✓] Xcode - develop for iOS and macOS (Xcode 11.4)</span><br><span class="line">[✓] Android Studio (version 3.6)</span><br><span class="line"> </span><br><span class="line">[✓] Connected device (1 available)            </span><br><span class="line"></span><br><span class="line">• No issues found!</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近更新到Mac OS最新系统Catalina，重装了Flutter，出现了些问题，在网上也搜索了，可能是才出的新版本问题，也没找到解决办法，最终自己捣鼓解决了此问题，随笔记录下此问题。 &lt;/p&gt;
    
    </summary>
    
      <category term="Flutter" scheme="https://tangyanqiong.com/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="https://tangyanqiong.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Mac OS Catalina 终端Shell报警告</title>
    <link href="https://tangyanqiong.com/post/bdd80ff3.html"/>
    <id>https://tangyanqiong.com/post/bdd80ff3.html</id>
    <published>2020-02-10T07:18:37.000Z</published>
    <updated>2022-07-20T16:54:26.670Z</updated>
    
    <content type="html"><![CDATA[<h1 id="随笔"><a href="#随笔" class="headerlink" title="随笔"></a>随笔</h1><p>前两天更新了Mac OS Catalina系统，总体来说还是可以，虽然有些只支持32位的应用，比如2015版的Office、WireShark等不能用了，但塞翁失马焉知非福呢，卸掉了Office相关的Word、Excel、PPT，瞬间清了几大个G，然后去下载了WPS多方文档格式支持软件，简直不要太好用，而且才几百兆，扯远了。。。</p><p>今天随笔记一个小事件，对于强迫症人士有用，比如我。</p><p>终端Shell报警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The default interactive shell is now zsh.</span><br><span class="line">To update your account to use zsh, please run `chsh -s /bin/zsh`.</span><br><span class="line">For more details, please visit https://support.apple.com/kb/HT208050.</span><br><span class="line">TangYanQiongdeMacBook-Pro:~ TangDan$</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>从报的警告就可以看出，提示原来使用的是bash风格，然而Catalina系统的shell已更改为zsh，请用 <code>chsh -s /bin/zsh</code> 更新替换，好吧，就run了，结果变成了这个风格</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TangDan@TangYanQiongdeMacBook-Pro ~ %</span><br></pre></td></tr></table></figure><p>对这种爱不起来，然后查看系统支持的shell风格列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TangYanQiongdeMacBook-Pro:~ TangDan$ cat /etc/shells</span><br><span class="line"># List of acceptable shells for chpass(1).</span><br><span class="line"># Ftpd will not allow users to connect who are not using</span><br><span class="line"># one of these shells.</span><br><span class="line"></span><br><span class="line">/bin/bash</span><br><span class="line">/bin/csh</span><br><span class="line">/bin/dash</span><br><span class="line">/bin/ksh</span><br><span class="line">/bin/sh</span><br><span class="line">/bin/tcsh</span><br><span class="line">/bin/zsh</span><br></pre></td></tr></table></figure><p>然后每个都试了，还是<code>/bin/bash</code>这种风格<code>TangYanQiongdeMacBook-Pro:~ TangDan$</code>最喜欢，但是系统会报警告，好，那把这个警告怎么消除？</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><ol><li>vim修改bash_profile文件，在终端输出</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bash_profile</span><br></pre></td></tr></table></figure><ol start="2"><li>在bash_profile文件最下方加上，按<code>i</code>进入编辑模式</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># macOS Catalina</span><br><span class="line">export BASH_SILENCE_DEPRECATION_WARNING=1</span><br></pre></td></tr></table></figure><ol start="3"><li>按<code>esc</code>退出编辑模式，再输入<code>:wq</code>保存退出，现在终端就不会报警告了。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Last login: Fri Apr 10 15:40:06 on ttys006</span><br><span class="line">TangYanQiongdeMacBook-Pro:~ TangDan$</span><br></pre></td></tr></table></figure><h1 id="题外"><a href="#题外" class="headerlink" title="题外"></a>题外</h1><p>看到我这边shell用户名<code>TangYanQiongdeMacBook-Pro</code>我想改它很久（中英混合。。。），这会顺便改了，打开系统偏好设置-共享-直接修改电脑名称就可以修改了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Last login: Fri Apr 10 15:46:05 on ttys006</span><br><span class="line">TangYanQiong-MacbookPro:~ TangDan$</span><br></pre></td></tr></table></figure><p>舒服了，😃</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;随笔&quot;&gt;&lt;a href=&quot;#随笔&quot; class=&quot;headerlink&quot; title=&quot;随笔&quot;&gt;&lt;/a&gt;随笔&lt;/h1&gt;&lt;p&gt;前两天更新了Mac OS Catalina系统，总体来说还是可以，虽然有些只支持32位的应用，比如2015版的Office、WireShark等不能用了，但塞翁失马焉知非福呢，卸掉了Office相关的Word、Excel、PPT，瞬间清了几大个G，然后去下载了WPS多方文档格式支持软件，简直不要太好用，而且才几百兆，扯远了。。。&lt;/p&gt;
&lt;p&gt;今天随笔记一个小事件，对于强迫症人士有用，比如我。&lt;/p&gt;
&lt;p&gt;终端Shell报警告：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;The default interactive shell is now zsh.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;To update your account to use zsh, please run `chsh -s /bin/zsh`.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;For more details, please visit https://support.apple.com/kb/HT208050.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;TangYanQiongdeMacBook-Pro:~ TangDan$&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Others" scheme="https://tangyanqiong.com/categories/Others/"/>
    
    
      <category term="Shell" scheme="https://tangyanqiong.com/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>RN分享</title>
    <link href="https://tangyanqiong.com/post/98fdf95d.html"/>
    <id>https://tangyanqiong.com/post/98fdf95d.html</id>
    <published>2019-12-08T12:01:33.000Z</published>
    <updated>2022-07-20T16:54:02.593Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-React"><a href="#什么是-React" class="headerlink" title="什么是 React"></a>什么是 React</h2><ul><li><p>React 是一个用于构建用户界面的 JavaScript 库。</p></li><li><p>声明式UI</p></li></ul><a id="more"></a><h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><p><a href="https://zh-hans.reactjs.org/docs/jsx-in-depth.html" target="_blank" rel="noopener">JSX</a></p><h2 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h2><ul><li><p>Props</p></li><li><p>State</p></li><li><p>生命周期 <a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" target="_blank" rel="noopener">图例</a></p></li></ul><h2 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h2><ul><li><p>react 的核心卖点之一</p></li><li><p>setState （只要调用了 setState 就会调用 render 无论你 setState 修改的是什么，哪怕是页面里没有的一个数据，render 都会被触发，并且父组件渲染中会嵌套渲染自、子组件。）</p></li><li><p>render</p></li><li><p>diff | reconciliation</p></li></ul><p>官方一点的定义应该称为 reconciliation，也就是 React 用来比较两棵节点树的算法，它确定树中的哪些部分需要被更新。</p><p>在确定两棵树的区别后，会根据不同的地方对实际节点进行操作，这样你看到的界面终于在这一步得到了改变。当年 React 也就因为这个高效的 dom 操作方法得到追捧。</p><ul><li>shouldComponentUpdate</li></ul><h2 id="PureComponent"><a href="#PureComponent" class="headerlink" title="PureComponent"></a>PureComponent</h2><h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://zh-hans.reactjs.org/docs/forwarding-refs.html" target="_blank" rel="noopener">refs 转发</a></p><h2 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h2><p><a href="https://zh-hans.reactjs.org/docs/fragments.html#short-syntax" target="_blank" rel="noopener">fragment</a></p><h2 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h2><p><a href="https://zh-hans.reactjs.org/docs/higher-order-components.html" target="_blank" rel="noopener">高阶组件</a></p><h2 id="协调与-diff"><a href="#协调与-diff" class="headerlink" title="协调与 diff"></a>协调与 diff</h2><p><a href="https://zh-hans.reactjs.org/docs/reconciliation.html" target="_blank" rel="noopener">diffing</a></p><h2 id="react-hook"><a href="#react-hook" class="headerlink" title="react hook"></a>react hook</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是-React&quot;&gt;&lt;a href=&quot;#什么是-React&quot; class=&quot;headerlink&quot; title=&quot;什么是 React&quot;&gt;&lt;/a&gt;什么是 React&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;React 是一个用于构建用户界面的 JavaScript 库。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;声明式UI&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Web" scheme="https://tangyanqiong.com/categories/Web/"/>
    
      <category term="JS" scheme="https://tangyanqiong.com/categories/Web/JS/"/>
    
    
      <category term="JavaScript" scheme="https://tangyanqiong.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Charles抓包微信小程序\移动端（Mac版）</title>
    <link href="https://tangyanqiong.com/post/b032c09d.html"/>
    <id>https://tangyanqiong.com/post/b032c09d.html</id>
    <published>2019-10-11T03:26:59.000Z</published>
    <updated>2020-04-24T06:21:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前做移动端，对网络进行测试抓包一直用的Charles抓包工具，很实用的一款工具，那怎么抓微信小程序的包呢，实际跟移动端是一样的，下面统一记录下，避免换电脑遗忘。</p><a id="more"></a><h1 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h1><p>其实要想抓取到微信小程序的数据首先要解决的第一个问题件就是如何通过charles抓取手机上的数据（HTTP)。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>charles上通过proxy-&gt;proxy setting进入代理设置，入口如下图所示：</p><p><img src="https://img-blog.csdn.net/20180307191133358?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTWFueVBlbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p>点击后进入如下图所示：</p><p><img src="https://img-blog.csdn.net/20180307191412276?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTWFueVBlbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p>记住此处的port，默认为8888，也可以进行修改，只要不冲突就可以，<strong>勾选上Enable transparent HTTP proxying</strong>，到此为止完成charles上的初步设置。</p><p>到此为止，完成了电脑端的设置。</p><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>设置手机代理，<strong>注意要保证手机所连接的wifi跟电脑在一个局域网内（就是连接同一个wifi或者通过电脑分享出的wifi进行连接）</strong></p><p>首先，需要知道电脑的ip地址，手机上进入wifi设置，电脑与手机共连同一个网络，修改手机上wifi代理</p><p><img src="https://img-blog.csdn.net/20180307192323638?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTWFueVBlbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p>点击代理后进入如下界面，服务器主机名处填写刚才查到的电脑的ip地址即可，服务器端口填写第一步中charles处设置的端口，默认是8888，如果做了修改，填写设置charles时修改的端口值。</p><p><img src="https://img-blog.csdn.net/20180307192559442?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTWFueVBlbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p>点击保存，此时charles上会弹出一个对话框，点击allow(允许)即可。此时就可以抓取手机上的http数据包了（注意不是https）</p><p>如下图所示，点入一个应用后，抓取到的http包。</p><p><img src="https://img-blog.csdn.net/20180307193307975?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTWFueVBlbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><p>完成以上步骤，charles会同时抓取手机以及电脑上的数据包，如果针对手机抓包可以通过取消勾选下图所示的选项屏蔽掉，这样更清楚。</p><p><img src="https://img-blog.csdn.net/20180307194127716?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTWFueVBlbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>手机连接不上Charles的几种原因及解决方案：</p><ol><li><p>确认手机跟电脑是不是在一个wifi环境下，我在使用过程中又一次手机由于wifi信号强弱问题自动切换过wifi导致抓了一般的数据包抓不到了。</p></li><li><p>可以尝试更换一下端口号（8888可能已经被占用）。</p></li><li><p>可以通过电脑手动添加手机的ip。</p></li></ol><p><img src="https://img-blog.csdn.net/20180307193806911?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTWFueVBlbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><ol start="4"><li><p>试试关掉电脑防火墙，在重新连接。</p></li><li><p>最后大招，万能重启。重新打开charles，重新设置手机连接。</p></li></ol><h1 id="抓HTTPS包"><a href="#抓HTTPS包" class="headerlink" title="抓HTTPS包"></a>抓HTTPS包</h1><h2 id="电脑端设置"><a href="#电脑端设置" class="headerlink" title="电脑端设置"></a>电脑端设置</h2><p>到此为止，完成了一大步骤的设置，可以通过电脑抓取手机的HTTP数据包了，但对于HTTPS数据，到此步为止，抓包工具上的列表部分会显示一堆unknown的地址。</p><p><strong>那怎么来解决呢？</strong></p><p>首先是电脑端的配置，进入Charles的Help-&gt;SSL Proxying-&gt;Install Charles Root Certificate</p><p><img src="https://img-blog.csdn.net/20180307194401534?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTWFueVBlbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p>点击Install Charles Root Certificate之后，会弹出mac的钥匙串访问页面，点击允许并安装证书，加入成功后会显示如下：</p><p><img src="https://i.loli.net/2020/04/24/sZrkW4DSyu9dFew.png" alt="WeChatd20fdc2fb5b0fa890a9519a1a921c6a4.png"></p><p>右键点击该证书，选择菜单中的“显示简介选项”，接着进入信任栏目，将其全部置为“始终信任”</p><p><img src="https://img-blog.csdn.net/20180307194916728?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTWFueVBlbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p>接着点击Proxy-&gt;SSL Proxy Settings，弹出如下页面</p><p><img src="https://img-blog.csdn.net/20180307195134860?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTWFueVBlbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt><br><img src="https://img-blog.csdn.net/20180307195230731?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTWFueVBlbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p>弹出的对话框中，勾选Enable SSL Proxying，然后点击add添加Host为<em>和Port为443，点击ok（此处将host设置为</em>的意思是主抓取全部的http是数据包，如果想针对某个域名抓取可以在此设置）</p><p>到此为止，完成了电脑端的设置</p><h2 id="移动端设置"><a href="#移动端设置" class="headerlink" title="移动端设置"></a>移动端设置</h2><p>接着需要在手机端安装证书，点击Charles上的Help-&gt;SSL Proxying-&gt;Install Charles Root Certificate on a Mobile Device or Remote Browser</p><p>点击之后弹出如下对话框：</p><p><img src="https://img-blog.csdn.net/20180307195617304?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTWFueVBlbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p>接着在手机浏览器上访问charlesproxy.com/getssl这个地址，然后会弹出如下界面：</p><p><img src="https://img-blog.csdn.net/20180307200002865?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTWFueVBlbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p>输入一个名字比如charlesproxy之后点击确定，会有一个一闪而过的提示，就ok了</p><p>此时进入小程序，可以看到charles上能够看到https的接口的地址和数据了</p><p><img src="https://img-blog.csdn.net/20180307200443685?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTWFueVBlbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p>到此，就可以愉快的抓包了。</p><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><h2 id="温馨提示1"><a href="#温馨提示1" class="headerlink" title="温馨提示1"></a>温馨提示1</h2><p>苹果设备iOS10以后证书可以正常安装，可正常使用HTTPS抓包，但是安卓设备呢，需注意：</p><p><em>由于在Android7.0及以上的系统中，每个应用可以定义自己的可信CA集，默认情况下，应用只会信任系统预装的CA证书，而不会信任用户安装的CA证书</em></p><ul><li>安卓系统 7.0 以下版本，不管微信任意版本，都会信任系统提供的证书</li><li>安卓系统 7.0 以上版本，微信 7.0 以下版本，微信会信任系统提供的证书</li><li>安卓系统 7.0 以上版本，微信 7.0 以上版本，微信只信任它自己配置的证书列表</li></ul><p>简单来说，就是安卓系统7.0及以下的设备可以正常安装证书进行HTTPS抓包，7.0以上则需要曲线救国，这里就不多说了，我后面在电脑上用<strong>网易MuMu模拟器（该模拟器系统是6.0）</strong>安装微信，在wifi设置里长按默认网络进行网络修改，设置代理等，也可以愉快的抓小程序的数据包了。</p><h2 id="温馨提示2"><a href="#温馨提示2" class="headerlink" title="温馨提示2"></a>温馨提示2</h2><p>注意，有一些应用使用的网络框架是不允许通过代理访问的，此时通过charles抓包显示的地址仍是unknown，或者手机上访问该应用会提示网络连接错误等信息，此时取消勾选charles的SSL Proxying settings中的勾选框就可以正常访问了。</p><h2 id="温馨提示3"><a href="#温馨提示3" class="headerlink" title="温馨提示3"></a>温馨提示3</h2><p>抓取工作完成后，记得把手机上的代理设置恢复原样，否则当电脑上的charles关闭时，手机将无法正常访问网络。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;之前做移动端，对网络进行测试抓包一直用的Charles抓包工具，很实用的一款工具，那怎么抓微信小程序的包呢，实际跟移动端是一样的，下面统一记录下，避免换电脑遗忘。&lt;/p&gt;
    
    </summary>
    
      <category term="Others" scheme="https://tangyanqiong.com/categories/Others/"/>
    
    
      <category term="Charles" scheme="https://tangyanqiong.com/tags/Charles/"/>
    
      <category term="WeChat" scheme="https://tangyanqiong.com/tags/WeChat/"/>
    
      <category term="抓包" scheme="https://tangyanqiong.com/tags/%E6%8A%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>iOS及Web使用语言特性</title>
    <link href="https://tangyanqiong.com/post/4546698d.html"/>
    <id>https://tangyanqiong.com/post/4546698d.html</id>
    <published>2019-09-16T03:07:38.000Z</published>
    <updated>2020-04-14T07:58:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>关于iOS及Web的使用语言Object-C、Swift、JavaScript，大家都耳熟能详，那它们到底是什么类型的静态语言？以及什么强弱类型语言？很多同学只是简单的背出它们是什么语言及类型，但并没有理解到，现在来举例说明和分享一下。</p><a id="more"></a><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><h2 id="Object-C"><a href="#Object-C" class="headerlink" title="Object-C"></a>Object-C</h2><p>我用的最多的当然是Object-C，毕竟是做iOS开发出身，对这个语言了解最深。首先，因为黑魔法RunTime机制，Object-C是一个运行时的<strong>动态类型的强类型语言</strong>，举例如下：</p><ol><li>以下两种情况都可以看出，Xcode编译时并不会报错，说明是一个<em>动态语言</em>，运行时才会去检验类型</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSString *test = @&quot;1231231&quot;;</span><br><span class="line">test = [[NSDate alloc] init];</span><br><span class="line"></span><br><span class="line">NSDate *test2 = @&quot;1231231&quot;; // test2的真实类型是什么，运行时会得到String类型，并不是声明时的NSDate类型</span><br></pre></td></tr></table></figure><ol start="2"><li>Object-C是<em>强类型语言</em>，因为变量必须声明类型才能使用，说实话，Object-C的代码简洁性，是真的不怎么高</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSString *certsPath = [[NSBundle mainBundle] pathForResource:@&quot;server&quot; ofType:@&quot;crt&quot;];</span><br><span class="line">NSError *error;</span><br><span class="line">NSString *contentInUTF8 = [NSString stringWithContentsOfFile:certsPath encoding:NSUTF8StringEncoding error:&amp;error];</span><br></pre></td></tr></table></figure><h2 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h2><p>iOS的这两种开发语言，Swift和OC，Swift更简洁了，减少了代码的冗余性，最开始接触它的时候，我还以为它是一门弱语言类型的语言，后来发现我错了，下面会娓娓道来，它实际是一门<strong>静态类型的强类型语言</strong>。</p><ol><li>以下情况代码编译会报错：’Cannot assign value of type ‘NSDate’ to type ‘String’’ ，类型错误，由此看出Swift是<em>静态类型语言</em></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var tmp = &quot;asdfas&quot;</span><br><span class="line">let date = NSDate.init()</span><br><span class="line">tmp = date</span><br></pre></td></tr></table></figure><ol start="2"><li>为什么一开始会觉得它是弱类型语言呢？</li></ol><blockquote><p>Swift 变量不强制的指定类型，而是用 var 和 let 表示可变与不可变。所以，误Swift是一门弱类型的语言。</p></blockquote><p>像下面的代码块，变量赋值时并没声明类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let num = 1</span><br><span class="line">let str = &quot;2&quot;</span><br></pre></td></tr></table></figure><p>基于以上，从自身理解，误以为<del>Swift是弱类型语言</del></p><p>但是，实际上，这里没有强制声明类型，看似一个弱类型的语言，其实不然。Swift 编译器能够推断出 num 是 Int 类型。那么 num 就不能再被赋值为 String 类型。更不能写成如下的形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let num = 1</span><br><span class="line">let str = &quot;2&quot;</span><br><span class="line">let result = num + str</span><br></pre></td></tr></table></figure><p><strong>编译器将会报如下的错误：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">error: binary operator &apos;+&apos; cannot be applied to operands of type &apos;Int&apos; and &apos;String&apos;</span><br><span class="line">let result = num + str</span><br><span class="line">             ~~~ ^ ~~~</span><br><span class="line">note: overloads for &apos;+&apos; exist with these partially matching parameter lists: (Int, Int), (String, String), (Int, UnsafeMutablePointer&lt;Pointee&gt;), (Int, UnsafePointer&lt;Pointee&gt;)</span><br><span class="line">let result = num + str</span><br></pre></td></tr></table></figure><p>这说明了，Swift 是一门<em>强类型语言</em>。Swift 的类型声明，你可以看成是在定义变量的时候，隐式声明的（由编译器推断出），当然也可以显式的声明。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let num: Int = 1</span><br></pre></td></tr></table></figure><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><p>Web中的常用语言JavaScript，如果有语言基础的话，是一门很快上手的语言，我也很喜欢JavaScript，当然也有使用中比较头疼的事，因为它是一门<strong>动态类型的弱类型语言</strong>，往往项目中在项目运行成功后，控制台意想不到的报错，不像强语言类型那样，直接编译不过，而我又有Swift的编写思想，想着它类型编译通过了，运行肯定就没问题，往往会出现比如编译没问题，类型错误的问题，而且它没有iOS中nil可以调用任何方法的容错机制，如果这个对象为nil再调用其某个方法也会报错，所以写的时候必须要判断是否为空，增加代码冗余性，但是，好处大于弊端，比如代码简洁性，可以动态写很多业务逻辑，我还是很喜欢它。</p><ol><li><em>动态类型语言</em>，以下情况，编译没问题，动态运行时赋值类型</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let tmpFlag = false</span><br><span class="line">let test = &apos;asdfasdfas&apos;</span><br><span class="line">test = tmpFlag // 所以最终test为Bool类型了</span><br></pre></td></tr></table></figure><ol start="2"><li><em>弱类型语言</em>，书写变量时不用声明类型也可</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let tmpFlag = false</span><br><span class="line">let test = &apos;asdfasdfas&apos;</span><br><span class="line">let jjjj = Date.now()</span><br></pre></td></tr></table></figure><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><p>TypeScript是JavaScript的一个超集，TypeScript可以使用JavaScript中的所有代码和编码概念，TypeScript是为了使 JavaScript的开发变得更加容易而创建的，它是关于尽早捕获错误并使您成为更高效的开发人员，它是什么类型的语言？我们把在JavaScript上实验的代码，放在ts里一试便知道。</p><ol><li>以下情况是js上实验的代码，在ts里编译报错，说明TypeScript是<em>静态类型语言</em></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let tmpFlag = false</span><br><span class="line">let test = &apos;asdfasdfas&apos;</span><br><span class="line">test = tmpFlag</span><br></pre></td></tr></table></figure><p>报错如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">43:9 Type &apos;false&apos; is not assignable to type &apos;string&apos;.</span><br></pre></td></tr></table></figure><ol start="2"><li>相同代码又在ts里实验，编译未报错，故TypeScript是<em>弱类型语言</em></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let tmpFlag = false</span><br><span class="line">let test = &apos;asdfasdfas&apos;</span><br><span class="line">let jjjj = Date.now()</span><br></pre></td></tr></table></figure><p>以下代码也未报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let num = 1</span><br><span class="line">let str = &apos;2&apos;</span><br><span class="line">let result = num + str</span><br></pre></td></tr></table></figure><p>综上可知，TypeScript是一门<strong>静态类型的弱类型语言</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;关于iOS及Web的使用语言Object-C、Swift、JavaScript，大家都耳熟能详，那它们到底是什么类型的静态语言？以及什么强弱类型语言？很多同学只是简单的背出它们是什么语言及类型，但并没有理解到，现在来举例说明和分享一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Others" scheme="https://tangyanqiong.com/categories/Others/"/>
    
    
      <category term="JavaScript" scheme="https://tangyanqiong.com/tags/JavaScript/"/>
    
      <category term="Swift" scheme="https://tangyanqiong.com/tags/Swift/"/>
    
      <category term="Object-C" scheme="https://tangyanqiong.com/tags/Object-C/"/>
    
      <category term="TypeScript" scheme="https://tangyanqiong.com/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>跨平台RN与Flutter对比及学习</title>
    <link href="https://tangyanqiong.com/post/196a8be9.html"/>
    <id>https://tangyanqiong.com/post/196a8be9.html</id>
    <published>2019-09-08T07:42:34.000Z</published>
    <updated>2020-03-25T09:04:29.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近想学跨平台开发，在RN和Flutter中纠结学哪个，看了资料RN对Web前端比较友好，都是JS开发语言，比较容易上手，但是有个以前的iOS同事，他现在已经用Flutter着手在开发iOS、Android了，据他说很好用。</p><a id="more"></a><h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><p>跨平台，首先考虑的就是性能问题，谁的性能好，未来必将是谁的天下。</p><h2 id="RN性能"><a href="#RN性能" class="headerlink" title="RN性能"></a>RN性能</h2><p>RN的效率由于是将View编译成了原生View，所以效率上要比基于Cordova的HTML5高很多，但是它也有效率问题，RN的渲染机制是基于前端框架的考虑，复杂的UI渲染是需要依赖多个view叠加。比如我们渲染一个复杂的ListView，每一个小的控件，都是一个native的view，然后相互组合叠加，想想此时如果我们的list再需要滑动刷新，会有多少个对象需要渲染，所以也就有了前面所说的RN的列表方案不友好。</p><h3 id="RN框架原理图"><a href="#RN框架原理图" class="headerlink" title="RN框架原理图"></a>RN框架原理图</h3><p><img src="https://upload-images.jianshu.io/upload_images/11451874-f497b4b23ec7392f.png" alt="RN框架原理图"></p><h2 id="Flutter性能"><a href="#Flutter性能" class="headerlink" title="Flutter性能"></a>Flutter性能</h2><p>而Flutter则吸收了前两者的教训之后，在渲染技术上，选择了自己实现(GDI)，有自己的一套UI系统，由于有更好的可控性，使用了新的语言Dart，避免了RN的那种通过桥接器与Javascript通讯导致效率低下的问题，所以在性能方面无可厚非比RN更高一筹，有经验的开发者可以打开Android手机开发者选项里面的显示边界布局，发现Flutter的布局是一个整体，说明Flutter的渲染没用使用原生控件进行渲染。</p><h3 id="Flutter框架原理图"><a href="#Flutter框架原理图" class="headerlink" title="Flutter框架原理图"></a>Flutter框架原理图</h3><p><img src="https://upload-images.jianshu.io/upload_images/11451874-12b2515a4cb0cdb1.png" alt="Flutter框架原理图"></p><h1 id="异同"><a href="#异同" class="headerlink" title="异同"></a>异同</h1><ul><li><p>Flutter性能会更好无线接近原生的体验,Dart是AOT编译的，编译成快速、可预测的本地代码</p></li><li><p>RN采用JS语言开发，基于React，对前端工程师更友好。Dart语言受众小</p></li><li><p>Flutter自己实现了一套UI框架，丢弃了原生的UI框架。而RN还是可以自己利用原生框架，两个各有好处。Flutter的兼容性高，RN可以利用原生已有的优秀UI</p></li><li><p>RN的布局更像css，而Flutter的布局更像native布局，但是去掉xml通过代码直接写需要适应下</p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对比了RN/Flutter后，我觉得对于我来说，RN应该很容易上手，因为有前端基础，RN学习起来应该很快，但是我也不想放弃Flutter，Flutter布局像原生布局，有iOS开发经验的我也不想放弃，因为有iOS同事成功上车的前车之鉴，所以我也很有信心能学好它，从性能来说我也更偏向Flutter，但是也不想浪费RN这个学习机会，所以就我自己的实际情况而言，我会两个都学。</p><p>总之，一句话吧，<strong>基于自身实际情况，没有更好只有最适合你的框架</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近想学跨平台开发，在RN和Flutter中纠结学哪个，看了资料RN对Web前端比较友好，都是JS开发语言，比较容易上手，但是有个以前的iOS同事，他现在已经用Flutter着手在开发iOS、Android了，据他说很好用。&lt;/p&gt;
    
    </summary>
    
      <category term="跨平台" scheme="https://tangyanqiong.com/categories/%E8%B7%A8%E5%B9%B3%E5%8F%B0/"/>
    
    
      <category term="Flutter" scheme="https://tangyanqiong.com/tags/Flutter/"/>
    
      <category term="RN" scheme="https://tangyanqiong.com/tags/RN/"/>
    
  </entry>
  
  <entry>
    <title>MarkDown常用语法</title>
    <link href="https://tangyanqiong.com/post/d18ae5e4.html"/>
    <id>https://tangyanqiong.com/post/d18ae5e4.html</id>
    <published>2019-09-04T09:00:29.000Z</published>
    <updated>2020-03-25T09:20:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h1><p>由于前段时间工作忙，快一个月没更新博客了，貌似有些忘了MarkDown的语法，这里记录下MarkDown语法作备忘录，以后方便查找。</p><a id="more"></a><h1 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h1><h3 id="标题语法"><a href="#标题语法" class="headerlink" title="标题语法"></a>标题语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#一级标题</span><br><span class="line"></span><br><span class="line">##二级标题</span><br><span class="line"></span><br><span class="line">###三级标题</span><br><span class="line"></span><br><span class="line">####四级标题</span><br><span class="line"></span><br><span class="line">#####五级标题</span><br><span class="line"></span><br><span class="line">######六级标题</span><br></pre></td></tr></table></figure><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><hr><h3 id="使用-加空格，来表示无序列表"><a href="#使用-加空格，来表示无序列表" class="headerlink" title="使用*加空格，来表示无序列表"></a>使用*加空格，来表示无序列表</h3><ul><li><p>1</p></li><li><p>2</p></li><li><p>3</p></li></ul><h3 id="用数字加-加空格，来表示有序列表"><a href="#用数字加-加空格，来表示有序列表" class="headerlink" title="用数字加.加空格，来表示有序列表"></a>用数字加.加空格，来表示有序列表</h3><ol><li><p>1</p></li><li><p>2</p></li><li><p>3</p></li><li><p>4</p></li></ol><h3 id="使用引用"><a href="#使用引用" class="headerlink" title="使用引用"></a>使用引用</h3><blockquote><p>引用需要使用&gt;和空格</p></blockquote><h3 id="插入链接"><a href="#插入链接" class="headerlink" title="插入链接"></a>插入链接</h3><p><a href="http://baidu.com" target="_blank" rel="noopener">baidu</a></p><h3 id="插入在线图片"><a href="#插入在线图片" class="headerlink" title="插入在线图片"></a>插入在线图片</h3><p><img src="https://www.baidu.com/img/bd_logo1.png" alt="icon"></p><h3 id="使用粗体、斜体"><a href="#使用粗体、斜体" class="headerlink" title="使用粗体、斜体"></a>使用粗体、斜体</h3><p><strong>这就是粗体</strong></p><p><em>这就是斜体</em></p><p><strong><em>这就是斜粗体</em></strong></p><h3 id="Task-list"><a href="#Task-list" class="headerlink" title="Task list"></a>Task list</h3><ul><li style="list-style: none"><input type="checkbox" checked> finished</li><li style="list-style: none"><input type="checkbox"> unfinished</li></ul><p><del>这个是删除线</del></p><h3 id="使用代码框，PS-这种不支持代码的语法高亮"><a href="#使用代码框，PS-这种不支持代码的语法高亮" class="headerlink" title="使用代码框，PS:这种不支持代码的语法高亮"></a>使用代码框，PS:这种不支持代码的语法高亮</h3><p>~~~<br>@IBAction func showMessage(){</p><p>let alertController = UIAlertController(title: “welcome to my first app”, message: “hello world”, preferredStyle: UIAlertControllerStyle.Alert)</p><p>alertController.addAction(UIAlertAction(title: “OK”, style: UIAlertActionStyle.Default, handler: nil))</p><p>self.presentViewController(alertController, animated: true, completion: nil)</p><p>}<br><code>`</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;由来&quot;&gt;&lt;a href=&quot;#由来&quot; class=&quot;headerlink&quot; title=&quot;由来&quot;&gt;&lt;/a&gt;由来&lt;/h1&gt;&lt;p&gt;由于前段时间工作忙，快一个月没更新博客了，貌似有些忘了MarkDown的语法，这里记录下MarkDown语法作备忘录，以后方便查找。&lt;/p&gt;
    
    </summary>
    
      <category term="Others" scheme="https://tangyanqiong.com/categories/Others/"/>
    
    
      <category term="MarkDown" scheme="https://tangyanqiong.com/tags/MarkDown/"/>
    
  </entry>
  
  <entry>
    <title>Vue主题import出错</title>
    <link href="https://tangyanqiong.com/post/52c1147f.html"/>
    <id>https://tangyanqiong.com/post/52c1147f.html</id>
    <published>2019-08-01T03:52:00.000Z</published>
    <updated>2020-03-25T08:53:59.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>在main.js文件中import<strong>‘../theme/index.css’</strong> 报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ERROR  Failed to compile with 1 errors </span><br><span class="line">                                                                                                                                                                                             </span><br><span class="line">This relative module was not found:</span><br><span class="line"></span><br><span class="line">* ../theme/index.css in ./src/main.js</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>原来在webpack.base.conf.js中有导入过如下代码，可能是webpack.base.conf.js和utils.js重复编译SCSS文件导致报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 导入SCSS</span><br><span class="line">&#123;</span><br><span class="line">   test: /\.(scss|css)?$/,</span><br><span class="line">   loaders: [&quot;style&quot;, &quot;css&quot;, &quot;sass&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>删除上述在webpack.base.conf.js中导入的SCSS代码，即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;在main.js文件中import&lt;strong&gt;‘../theme/index.css’&lt;/strong&gt; 报错：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ERROR  Failed to compile with 1 errors &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                                                                                                                                                             &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;This relative module was not found:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* ../theme/index.css in ./src/main.js&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Web" scheme="https://tangyanqiong.com/categories/Web/"/>
    
      <category term="Vue" scheme="https://tangyanqiong.com/categories/Web/Vue/"/>
    
    
      <category term="Vue" scheme="https://tangyanqiong.com/tags/Vue/"/>
    
      <category term="CSS" scheme="https://tangyanqiong.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Vue项目缩进问题</title>
    <link href="https://tangyanqiong.com/post/db5c826e.html"/>
    <id>https://tangyanqiong.com/post/db5c826e.html</id>
    <published>2019-07-30T09:50:46.000Z</published>
    <updated>2019-07-31T02:01:29.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>WebStorm的缩进规则和ESlint-vue的校验规则冲突引起的问题。</p><h4 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h4><ul><li>Vue项目</li><li>安装时打开ESLint校验功能</li><li>开发工具WebStorm</li></ul><p>代码格式化会出现两种：</p><a id="more"></a><p><strong>WebStorm格式化：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    exports default &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>ESlint格式化：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">exports default &#123;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>打开项目根下的.eslintrc.js文件，将rules节点中添加以下配置项，其中’2’是指统一缩进2个空格，’1’是指1倍缩进。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;vue/script-indent&apos;: [&apos;error&apos;, 2, &#123;&apos;baseIndent&apos;: 1&#125;]</span><br></pre></td></tr></table></figure><p>另外需要添加以下节点，与rules节点同级：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">overrides: [</span><br><span class="line">    &#123; &apos;files&apos;: [&apos;*.vue&apos;],</span><br><span class="line">      &apos;rules&apos;: &#123;</span><br><span class="line">      &apos;indent&apos;: &apos;off&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>问题搞定</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;WebStorm的缩进规则和ESlint-vue的校验规则冲突引起的问题。&lt;/p&gt;
&lt;h4 id=&quot;前提条件&quot;&gt;&lt;a href=&quot;#前提条件&quot; class=&quot;headerlink&quot; title=&quot;前提条件&quot;&gt;&lt;/a&gt;前提条件&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Vue项目&lt;/li&gt;
&lt;li&gt;安装时打开ESLint校验功能&lt;/li&gt;
&lt;li&gt;开发工具WebStorm&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码格式化会出现两种：&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="https://tangyanqiong.com/categories/Web/"/>
    
      <category term="Vue" scheme="https://tangyanqiong.com/categories/Web/Vue/"/>
    
    
      <category term="Vue" scheme="https://tangyanqiong.com/tags/Vue/"/>
    
      <category term="ESLint" scheme="https://tangyanqiong.com/tags/ESLint/"/>
    
      <category term="WebStorm" scheme="https://tangyanqiong.com/tags/WebStorm/"/>
    
  </entry>
  
  <entry>
    <title>Github代码下载提速</title>
    <link href="https://tangyanqiong.com/post/1e0383f0.html"/>
    <id>https://tangyanqiong.com/post/1e0383f0.html</id>
    <published>2019-07-25T08:06:27.000Z</published>
    <updated>2019-07-26T09:42:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前pod install安装GRPC出现各种错误，在网上找了各种办法，还重装过git以及pod都没有用，还是报类似如下错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[!] Error installing !ProtoCompiler</span><br><span class="line">[!] /usr/bin/curl -f -L -o /var/folders/1s/jw93vj050vq92gbrjv1c3x880000gn/T/d20190718-18563-1fzxwnx/file.zip https://github.com/google/protobuf/releases/download/v3.8.0/protoc-3.8.0-osx-x86_64.zip --create-dirs --netrc-optional --retry 2</span><br><span class="line"></span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100   162    0   162    0     0     11      0 --:--:--  0:00:14 --:--:--    39</span><br><span class="line">100   617    0   617    0     0     40      0 --:--:--  0:00:15 --:--:--  602k</span><br><span class="line"> 10 2794k   10  305k    0     0    835      0  0:57:06  0:06:14  0:50:52     0</span><br><span class="line">curl: (56) LibreSSL SSL_read: SSL_ERROR_SYSCALL, errno 54</span><br><span class="line"></span><br><span class="line">[!] Error installing BoringSSL-GRPC</span><br><span class="line">[!] /usr/bin/git clone https://github.com/google/boringssl.git /var/folders/1s/jw93vj050vq92gbrjv1c3x880000gn/T/d20190718-18162-1vck5op --template=</span><br><span class="line"></span><br><span class="line">Cloning into &apos;/var/folders/1s/jw93vj050vq92gbrjv1c3x880000gn/T/d20190718-18162-1vck5op&apos;...</span><br><span class="line">error: RPC failed; curl 18 transfer closed with outstanding read data remaining</span><br><span class="line">fatal: The remote end hung up unexpectedly</span><br><span class="line">fatal: early EOF</span><br><span class="line">fatal: index-pack failed</span><br></pre></td></tr></table></figure><p>之前没想过是网络的原因导致，因为挂VPN也出现了这种情况，后来一一排除，pod install –verbose 打印log，才发现根本就是github下载速度过慢，甚至连接超时导致。</p><p><strong>那怎么来提高github下载代码的速度呢？</strong></p><a id="more"></a><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="获取IP地址"><a href="#获取IP地址" class="headerlink" title="获取IP地址"></a>获取IP地址</h2><p>点击进入<a href="https://www.ipaddress.com/" target="_blank" rel="noopener">获取IP网址</a>，获取到本机对应以下三个网址的IP地址。</p><ul><li>github.com</li><li>github.global.ssl.fastly.net</li><li>codeload.github.com</li></ul><p><img src="https://i.loli.net/2019/07/25/5d396bea1360952904.png" alt="20190126112912387.png"></p><p>每个人的都不一样，这是我获取到的IP地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">140.82.113.4 github.com</span><br><span class="line">151.101.185.194 github.global.ssl.fastly.net</span><br><span class="line">140.82.114.9 codeload.github.com</span><br></pre></td></tr></table></figure><h2 id="修改系统hosts文件"><a href="#修改系统hosts文件" class="headerlink" title="修改系统hosts文件"></a>修改系统hosts文件</h2><h3 id="Windows系统"><a href="#Windows系统" class="headerlink" title="Windows系统"></a>Windows系统</h3><ul><li>hosts文件路径：C:\Windows\System32\drivers\etc\hosts ,</li><li>添加上面查询到的IP到hosts文件中（此时可能需要管理员权限,可以将hosts复制到桌面，修改好了再复制回去覆盖原来的）</li><li>修改完成后刷新DNS<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /flushdns</span><br></pre></td></tr></table></figure></li></ul><h3 id="Mac系统"><a href="#Mac系统" class="headerlink" title="Mac系统"></a>Mac系统</h3><p>在Finder-&gt;前往-&gt;前往文件夹，在框里输入/etc/hosts，找到hosts文件，可以将hosts文件复制到桌面，将ip地址添加到里面，修改好了再复制回去覆盖原来的hosts文件。</p><p><img src="https://i.loli.net/2019/07/25/5d396ef17c57396896.png" alt="82A13670-2C3E-445D-9E10-4088F2E438AD.png"><br>最后在终端执行刷新DNS命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dscacheutil -flushcache</span><br></pre></td></tr></table></figure><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>提速前的效果未截图，反正最快就是10多kb的样子，提速后效果如下：</p><p><img src="https://i.loli.net/2019/07/25/5d3970549b23037785.png" alt="68073D99-C3D9-4541-8E8A-B20C08C59A61.png"></p><p>GRPC报错的相关问题也迎刃而解。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;之前pod install安装GRPC出现各种错误，在网上找了各种办法，还重装过git以及pod都没有用，还是报类似如下错误。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[!] Error installing !ProtoCompiler&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[!] /usr/bin/curl -f -L -o /var/folders/1s/jw93vj050vq92gbrjv1c3x880000gn/T/d20190718-18563-1fzxwnx/file.zip https://github.com/google/protobuf/releases/download/v3.8.0/protoc-3.8.0-osx-x86_64.zip --create-dirs --netrc-optional --retry 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                 Dload  Upload   Total   Spent    Left  Speed&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;100   162    0   162    0     0     11      0 --:--:--  0:00:14 --:--:--    39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;100   617    0   617    0     0     40      0 --:--:--  0:00:15 --:--:--  602k&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 10 2794k   10  305k    0     0    835      0  0:57:06  0:06:14  0:50:52     0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;curl: (56) LibreSSL SSL_read: SSL_ERROR_SYSCALL, errno 54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[!] Error installing BoringSSL-GRPC&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[!] /usr/bin/git clone https://github.com/google/boringssl.git /var/folders/1s/jw93vj050vq92gbrjv1c3x880000gn/T/d20190718-18162-1vck5op --template=&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Cloning into &amp;apos;/var/folders/1s/jw93vj050vq92gbrjv1c3x880000gn/T/d20190718-18162-1vck5op&amp;apos;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;error: RPC failed; curl 18 transfer closed with outstanding read data remaining&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fatal: The remote end hung up unexpectedly&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fatal: early EOF&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fatal: index-pack failed&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;之前没想过是网络的原因导致，因为挂VPN也出现了这种情况，后来一一排除，pod install –verbose 打印log，才发现根本就是github下载速度过慢，甚至连接超时导致。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那怎么来提高github下载代码的速度呢？&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Others" scheme="https://tangyanqiong.com/categories/Others/"/>
    
    
      <category term="GRPC" scheme="https://tangyanqiong.com/tags/GRPC/"/>
    
      <category term="Github" scheme="https://tangyanqiong.com/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>Swift上View手势控制</title>
    <link href="https://tangyanqiong.com/post/a17aa0f4.html"/>
    <id>https://tangyanqiong.com/post/a17aa0f4.html</id>
    <published>2019-06-03T07:31:20.000Z</published>
    <updated>2019-06-06T02:00:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>对View进行放大缩小、移动、旋转，其实是很常见的需求，最开始在OC上，很早的几年，还是用的touch事件来实现，这种实现方式很繁琐，呈现的效果也不是很好。</p><p>后来，苹果也逐步的淘汰了这种方式，出了手势这种模式，极大程度上的缩减了代码量，而且操作简单，上手迅速，OC上手势的使用方式网上比比皆是，这里就不细说，着重介绍Swift View手势控制方法。</p><a id="more"></a><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>添加旋转、缩放、移动手势，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//Rotation</span><br><span class="line">let rotationGestureRecognizer = UIRotationGestureRecognizer(target: self, action: #selector(EditPhotoViewController.rotateView(_:)))</span><br><span class="line">photoImageView?.addGestureRecognizer(rotationGestureRecognizer)</span><br><span class="line"></span><br><span class="line">//Scale pinch</span><br><span class="line">let pinchGestureRecognizer = UIPinchGestureRecognizer(target: self, action: #selector(EditPhotoViewController.pinchView(_:)))</span><br><span class="line">photoImageView?.addGestureRecognizer(pinchGestureRecognizer)</span><br><span class="line"></span><br><span class="line">//Move</span><br><span class="line">let panGestureRecognizer = UIPanGestureRecognizer(target: self, action: #selector(EditPhotoViewController.panView(_:)))</span><br><span class="line">photoImageView?.addGestureRecognizer(panGestureRecognizer)</span><br></pre></td></tr></table></figure><p><strong>以下代码使用变量如下：</strong></p><blockquote><p>  private var cropFrame = CGRect.zero //图片上限制框的frame</p></blockquote><blockquote><p>  private var latestFrame = CGRect.zero //最大缩放frame</p></blockquote><blockquote><p>   private var rotationAngle: CGFloat = 0.0 //旋转的角度</p></blockquote><p><strong>给变量设置初始值：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private func resetShowImageViewFrame() &#123;</span><br><span class="line">   rotationAngle = 0.0</span><br><span class="line"></span><br><span class="line">   photoImageView?.image = originalImage</span><br><span class="line">   photoImageView?.transform = .identity</span><br><span class="line"></span><br><span class="line">   // scale to fit the screen</span><br><span class="line">   cropFrame = photoOverLayView?.transparentArea ?? CGRect.zero</span><br><span class="line"></span><br><span class="line">   var oriWidth: CGFloat = cropFrame.size.width</span><br><span class="line">   var oriHeight: CGFloat = (originalImage?.size.height ?? 0.0) * (oriWidth / (originalImage?.size.width ?? 0.0))</span><br><span class="line">   if ((originalImage?.size.width)!/(originalImage?.size.height)!) &gt; (CGFloat)(standardPostImgWidth)/(CGFloat)(standardPostImgHeight) &#123;</span><br><span class="line">      oriHeight = cropFrame.size.height</span><br><span class="line">      oriWidth = (originalImage?.size.width ?? 0.0) * (oriHeight / (originalImage?.size.height ?? 0.0))</span><br><span class="line">   &#125;</span><br><span class="line">   let oriX: CGFloat = cropFrame.origin.x + (cropFrame.size.width - oriWidth) / 2</span><br><span class="line">   let oriY: CGFloat = cropFrame.origin.y + (cropFrame.size.height - oriHeight) / 2</span><br><span class="line">   oldFrame = CGRect(x: oriX, y: oriY, width: oriWidth, height: oriHeight)</span><br><span class="line">   latestFrame = oldFrame</span><br><span class="line">   photoImageView?.frame = oldFrame</span><br><span class="line">   largeFrame = CGRect(x: 0, y: 0, width: limitRatio * oldFrame.size.width, height: limitRatio * oldFrame.size.height)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="旋转实现"><a href="#旋转实现" class="headerlink" title="旋转实现"></a>旋转实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@objc func rotateView(_ rotationGestureRecognizer: UIRotationGestureRecognizer?) &#123;</span><br><span class="line">   let view: UIView? = photoImageView</span><br><span class="line">   if rotationGestureRecognizer?.state == .began || rotationGestureRecognizer?.state == .changed &#123;</span><br><span class="line">      view?.transform = (view?.transform.rotated(by: (rotationGestureRecognizer?.rotation)!))!</span><br><span class="line">      rotationAngle = rotationAngle + (rotationGestureRecognizer?.rotation ?? 0.0)</span><br><span class="line">      rotationGestureRecognizer?.rotation = 0</span><br><span class="line">   &#125; else if rotationGestureRecognizer?.state == .ended &#123;</span><br><span class="line">      latestFrame = photoImageView?.frame ?? CGRect.zero</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缩放实现"><a href="#缩放实现" class="headerlink" title="缩放实现"></a>缩放实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@objc func pinchView(_ pinchGestureRecognizer: UIPinchGestureRecognizer?) &#123;</span><br><span class="line">   let view: UIView? = photoImageView</span><br><span class="line">   if pinchGestureRecognizer?.state == .began || pinchGestureRecognizer?.state == .changed &#123;</span><br><span class="line">      if rotationAngle == 0 &#123;</span><br><span class="line">       //narrow</span><br><span class="line">         if (pinchGestureRecognizer?.scale)! &lt;= CGFloat(1.0) &amp;&amp; ((photoImageView?.width)! &lt;= cropFrame.size.width || (photoImageView?.height)! &lt;= cropFrame.size.height) &#123;</span><br><span class="line">            return</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       //amplification</span><br><span class="line">       if (pinchGestureRecognizer?.scale)! &gt; CGFloat(1.0) &amp;&amp; ((photoImageView?.width)! &gt; 5000 || (photoImageView?.height)! &gt; 5000) &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        view?.transform = (view?.transform.scaledBy(x: (pinchGestureRecognizer?.scale)!, y: (pinchGestureRecognizer?.scale)!))!</span><br><span class="line">        pinchGestureRecognizer?.scale = 1</span><br><span class="line">    &#125; else if pinchGestureRecognizer?.state == .ended &#123;</span><br><span class="line">        if rotationAngle == 0 &#123;</span><br><span class="line">            var newFrame: CGRect? = photoImageView?.frame</span><br><span class="line">            //newFrame = handleScaleOverflow(newFrame ?? CGRect.zero)</span><br><span class="line">            newFrame = handleBorderOverflow(newFrame ?? CGRect.zero)</span><br><span class="line">            UIView.animate(withDuration: TimeInterval(BOUNDCE_DURATION), animations: &#123;</span><br><span class="line">            self.photoImageView?.frame = newFrame ?? CGRect.zero</span><br><span class="line">            self.latestFrame = newFrame ?? CGRect.zero</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            latestFrame = photoImageView?.frame ?? CGRect.zero</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="平移实现"><a href="#平移实现" class="headerlink" title="平移实现"></a>平移实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@objc func panView(_ panGestureRecognizer: UIPanGestureRecognizer?)</span><br><span class="line">&#123;</span><br><span class="line">   let view = panGestureRecognizer?.view;</span><br><span class="line">   if (panGestureRecognizer?.state == .began || panGestureRecognizer?.state == .changed) &#123;</span><br><span class="line">       let translation = panGestureRecognizer?.translation(in: view?.superview)</span><br><span class="line">       view?.center = CGPoint(x: (view?.center.x)! + (translation?.x)!, y: (view?.center.y)! + (translation?.y)!)</span><br><span class="line">       panGestureRecognizer?.setTranslation(CGPoint.zero, in: view?.superview)</span><br><span class="line">    &#125; else if panGestureRecognizer?.state == .ended &#123;</span><br><span class="line">        if rotationAngle == 0 &#123;</span><br><span class="line">           //bounce to original frame</span><br><span class="line">           var newFrame: CGRect? = photoImageView?.frame</span><br><span class="line">           newFrame = handleBorderOverflow(newFrame ?? CGRect.zero)</span><br><span class="line">           UIView.animate(withDuration: TimeInterval(BOUNDCE_DURATION), animations: &#123;</span><br><span class="line">               self.photoImageView?.frame = newFrame ?? CGRect.zero</span><br><span class="line">               self.latestFrame = newFrame ?? CGRect.zero</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">           latestFrame = photoImageView?.frame ?? CGRect.zero</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p><img src="https://i.loli.net/2019/06/03/5cf4ed0771faf64108.gif" alt="未命名.gif"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;对View进行放大缩小、移动、旋转，其实是很常见的需求，最开始在OC上，很早的几年，还是用的touch事件来实现，这种实现方式很繁琐，呈现的效果也不是很好。&lt;/p&gt;
&lt;p&gt;后来，苹果也逐步的淘汰了这种方式，出了手势这种模式，极大程度上的缩减了代码量，而且操作简单，上手迅速，OC上手势的使用方式网上比比皆是，这里就不细说，着重介绍Swift View手势控制方法。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://tangyanqiong.com/categories/iOS/"/>
    
      <category term="Swift" scheme="https://tangyanqiong.com/categories/iOS/Swift/"/>
    
    
      <category term="Swift" scheme="https://tangyanqiong.com/tags/Swift/"/>
    
      <category term="手势控制" scheme="https://tangyanqiong.com/tags/%E6%89%8B%E5%8A%BF%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>iPad控制多屏电视</title>
    <link href="https://tangyanqiong.com/post/a503d77d.html"/>
    <id>https://tangyanqiong.com/post/a503d77d.html</id>
    <published>2019-05-30T07:46:42.000Z</published>
    <updated>2019-07-26T09:48:49.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们公司有4个电视（内置机顶盒），用来展示公司的业务，平时经常会有客户来参观，电视下面是通过HDMI线连接的电脑，展示的实际是网页。</p><fancybox><img src="https://i.loli.net/2019/05/31/5cf0923211c8d15084.jpg" alt="5cef8c97a983892634.jpg"></fancybox><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>昨天下午领导提一个需求，因为演示的时候，需要操作，就得用电脑的鼠标在电视上点，屏幕太大鼠标又在电视下方，很不方便，不好操作，然后想借鉴别人公司，直接用iPad里控制4个电视来操作。</p><a id="more"></a><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><p><strong>用iPad来控制电视屏幕，是不是一听就很高大？</strong></p><p>哈哈，怎么控制？都不是一个系统，一个是windows系统，一个是iOS系统。讨论时，我提出了两个方案：</p><ul><li><ol><li>做个APP，把网页内嵌到里面，直接用自带的AirPlay把iPad投屏到电视，不用的电视，再切换投屏，这样在iPad上操作就会同步到电视。</li></ol></li><li><ol start="2"><li>因为展示的业务是web页，那么就用APP，在同一局域网给Web端发指令，或通过后台中转指令，以控制在电视上展示的网页。</li></ol></li></ul><h2 id="调研"><a href="#调研" class="headerlink" title="调研"></a>调研</h2><h3 id="1-投屏方案"><a href="#1-投屏方案" class="headerlink" title="1. 投屏方案"></a>1. 投屏方案</h3><p>这个方案，实际是时间成本最少的，说干就干，然后马上我这边就起了一个项目，嵌了一个网页在APP里，好吧，正式开始投屏，然后…</p><p><strong>结果：</strong></p><p>投屏是成功了的，但是呢，因为电视的屏幕比是16:9，而iPad是4:3，导致了在电视上，iPad的投屏屏幕显示不全，两边还有间隙，不是全屏，而且当初web端开发的网页尺寸也是固定的1920x1080，也就是为电视量身定做的，这个网页在iPad上也不能全屏显示。</p><p>这种硬件上及网页端的限制，不好改变，就放弃了这种方式。</p><h3 id="2-指令控制方案"><a href="#2-指令控制方案" class="headerlink" title="2. 指令控制方案"></a>2. 指令控制方案</h3><p>这个方案，需要和web端约定很多指令，基本指令像点击不同按钮的不同指令，而且比如上下滑动网页的距离，由于屏幕分辨率不一样，需要经过一定转换，才能是web端的对应距离等等问题。</p><p><strong>结果：</strong></p><p>诚如上面所说，这个开发成本会很大，而且有局限性，一旦网页内容改变，APP端需改动代码升级才能使用，这种做法不符合产品经理的预期，所以直接淘汰了。</p><h2 id="另辟蹊径"><a href="#另辟蹊径" class="headerlink" title="另辟蹊径"></a>另辟蹊径</h2><p>上面的两个方案告吹后，给产品经理说了结果，然后产品经理在网上找到了另一种方案，就是市面上这种类似TeamViewer的远程操控桌面软件，直接在iPad上安装软件，然后在PC上安装同样软件，使用iPad操控PC桌面。</p><h3 id="两种方案"><a href="#两种方案" class="headerlink" title="两种方案"></a>两种方案</h3><p>有了这个方案，就在网上找到了<a href="https://sunlogin.oray.com/zh_CN/" target="_blank" rel="noopener">向日葵</a>、<a href="https://www.splashtop.com/cn" target="_blank" rel="noopener">Splashtop</a>，这两个软件支持多端连接。</p><h4 id="1-向日葵"><a href="#1-向日葵" class="headerlink" title="1. 向日葵"></a>1. 向日葵</h4><p>安装和使用都比较简单，APP风格符合中国人的操作习惯，每次连接PC端都需要输入验证码（PC端的向日葵软件上），这样的话，每次切换连接不同电脑比较慢，操作体验不好。</p><fancybox><img src="https://i.loli.net/2019/05/30/5cefa66c0e85747877.png" alt="BAB22DB7-DCF2-460C-A034-F576BB64AF0F.png"></fancybox><h4 id="2-Splashtop"><a href="#2-Splashtop" class="headerlink" title="2. Splashtop"></a>2. Splashtop</h4><p>同样的，安装和使用都比较简单，是国外软件，风格偏欧美风，我其实比较喜欢这种操作方式，简单易懂，连接同一个电脑，连续输入两次验证码，下次再点击接该电脑就直接连接了。</p><fancybox><img src="https://i.loli.net/2019/05/30/5cefa66bdd93468731.jpg" alt="28ABD3EAB7E73EC5D89DD79D1255881D.jpg"></fancybox><p><strong>对比这两个软件，Splashtop切换不同电脑连接要更快些，而且不用每次都输验证码，相对方便些，所以就给产品经理推荐了这个软件来操作。</strong></p><h3 id="最终实施"><a href="#最终实施" class="headerlink" title="最终实施"></a>最终实施</h3><p>哈哈，以为这就OK了吗，NO，今天来公司，产品经理说昨晚给CEO看了，CEO觉得这样切换还是太慢，给了个建议，让4个电视通过HDMI方式连到一个电脑上，这样的话就用iPad操控一台电脑就可以了，不存在切换慢的问题了，仔细想了下，这种方案还真不错，有可行性，然后开撸，将4台电视连接到了一台电脑上（专门有HDMI拓展外接，所以接口足够），然后分屏显示。</p><h4 id="1-Splashtop连接"><a href="#1-Splashtop连接" class="headerlink" title="1. Splashtop连接"></a>1. Splashtop连接</h4><p>其实我真的是蛮喜欢Splashtop的，操作简单，可惜的是Splashtop只支持双屏显示，切换分屏始终只显示第1第2分屏。</p><fancybox><img src="https://i.loli.net/2019/05/30/5cefa66c15f5d36721.png" alt="DDC6ECBC-354F-477B-9DE6-930C9D6395BC.png"></fancybox><h4 id="2-向日葵连接"><a href="#2-向日葵连接" class="headerlink" title="2. 向日葵连接"></a>2. 向日葵连接</h4><p>换了向日葵来连接，满怀期望的希望它支持多屏，结果不负众望，4台分屏完美切换，速度流畅，好，就用它了。</p><fancybox><img src="https://i.loli.net/2019/05/30/5cefa66c1250218113.png" alt="B6B92F41-17AA-49AF-B2EF-73869B6C73F8.png"></fancybox><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的来说，这次需求完成还是比较满意的，上面领导也满意这个结果，这次分享希望能给需要iPad控制多屏电视的人带来帮助，有什么问题请在评论区告诉我吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;我们公司有4个电视（内置机顶盒），用来展示公司的业务，平时经常会有客户来参观，电视下面是通过HDMI线连接的电脑，展示的实际是网页。&lt;/p&gt;
&lt;fancybox&gt;&lt;img src=&quot;https://i.loli.net/2019/05/31/5cf0923211c8d15084.jpg&quot; alt=&quot;5cef8c97a983892634.jpg&quot;&gt;&lt;/fancybox&gt;

&lt;h2 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h2&gt;&lt;p&gt;昨天下午领导提一个需求，因为演示的时候，需要操作，就得用电脑的鼠标在电视上点，屏幕太大鼠标又在电视下方，很不方便，不好操作，然后想借鉴别人公司，直接用iPad里控制4个电视来操作。&lt;/p&gt;
    
    </summary>
    
      <category term="Others" scheme="https://tangyanqiong.com/categories/Others/"/>
    
    
      <category term="iPad控制多屏" scheme="https://tangyanqiong.com/tags/iPad%E6%8E%A7%E5%88%B6%E5%A4%9A%E5%B1%8F/"/>
    
      <category term="远程桌面控制" scheme="https://tangyanqiong.com/tags/%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E6%8E%A7%E5%88%B6/"/>
    
      <category term="向日葵" scheme="https://tangyanqiong.com/tags/%E5%90%91%E6%97%A5%E8%91%B5/"/>
    
      <category term="Splashtop" scheme="https://tangyanqiong.com/tags/Splashtop/"/>
    
  </entry>
  
  <entry>
    <title>Vue框架底层原理</title>
    <link href="https://tangyanqiong.com/post/d32be447.html"/>
    <id>https://tangyanqiong.com/post/d32be447.html</id>
    <published>2019-03-20T09:58:17.000Z</published>
    <updated>2019-07-26T09:44:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Vue框架是什么，怎么用，相信大家都已经很熟悉了，诚如<a href="https://www.runoob.com/vue2/vue-tutorial.html" target="_blank" rel="noopener">Vue教程</a>所说，它是一套构建用户界面的渐进式Web前端框架。</p><fancybox><img src="https://i.loli.net/2019/05/27/5ceb976f6b4eb74810.png" alt="image"></fancybox><p>但是很多人就是拿来主义，就只管用，博主也是这类人 = =!, 但是随着深入使用Vue，越发觉得深知其原理的重要性，那么，本文来探讨一下Vue的底层原理到底是什么，是怎么实现的。</p><a id="more"></a><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h2><p>Vue的底层原理总体来说就是深入响应式原理，它最独特的特性之一就是非侵入性的响应式系统。数据模型仅仅是普通的 JavaScript 对象。而当你修改它们时，视图会进行更新，这使得状态管理非常简单直接。</p><h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><h3 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h3><p>下面是一段代码，较直观的体现了Vue特点，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;mvvm-app&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&quot;word&quot;&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;word&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button v-on:click=&quot;sayHi&quot;&gt;change model&lt;/button&gt; //点击这个button，word的值会发生改变</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script src=&quot;./js/observer.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;./js/watcher.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;./js/compile.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;./js/mvvm.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var vm = new MVVM(&#123;</span><br><span class="line">        el: &apos;#mvvm-app&apos;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            word: &apos;Hello World!&apos;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            sayHi: function() &#123;</span><br><span class="line">                this.word = &apos;Hi, everybody!&apos;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>实现效果如下：</strong></p><p><img src="https://i.loli.net/2019/05/27/5ceba18d75b1079687.gif" alt="vue_test.gif"></p><p>而Vue实现数据双向绑定的效果，需要<strong>三大模块：</strong></p><ul><li><ol><li>Observer：对数据对象的所有属性进行监听，如有变动可拿到最新值并通知观察者</li></ol></li><li><ol start="2"><li>Compile：对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数</li></ol></li><li><ol start="3"><li>Watcher：作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图</li></ol></li></ul><fancybox><img src="https://i.loli.net/2019/05/27/5ceba2641810f80268.png" alt="vue_test2.png"></fancybox><h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><p>Observer的核心是通过Obeject.defineProperty()来监听数据的变动，这个函数内部可以定义setter和getter，每当数据发生变化，就会触发setter。这时候Observer就要通知订阅者，订阅者就是Watcher。</p><h3 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h3><p>Watcher订阅者作为Observer和Compile之间通信的桥梁，主要做的事情是：</p><ul><li><ol><li>在自身实例化时往属性订阅器(dep)里面添加自己</li></ol></li><li><ol start="2"><li>自身必须有一个update()方法</li></ol></li><li><ol start="3"><li>待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调</li></ol></li></ul><h3 id="Compile"><a href="#Compile" class="headerlink" title="Compile"></a>Compile</h3><p>Compile主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>MVVM 是Model-View-ViewModel 的缩写，它是一种基于前端开发的架构模式，其核心是提供对View 和 ViewModel 的双向数据绑定，这使得ViewModel 的状态改变可以自动传递给 View，即所谓的数据双向绑定。</p><p>而Vue框架则是一个提供了 MVVM 风格的双向数据绑定的 Javascript 库，专注于View 层。它的核心是 MVVM 中的 VM，也就是 ViewModel。 ViewModel负责连接 View 和 Model，保证视图和数据的一致性，这种轻量级的架构让前端开发更加高效、便捷。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Vue框架是什么，怎么用，相信大家都已经很熟悉了，诚如&lt;a href=&quot;https://www.runoob.com/vue2/vue-tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Vue教程&lt;/a&gt;所说，它是一套构建用户界面的渐进式Web前端框架。&lt;/p&gt;
&lt;fancybox&gt;&lt;img src=&quot;https://i.loli.net/2019/05/27/5ceb976f6b4eb74810.png&quot; alt=&quot;image&quot;&gt;&lt;/fancybox&gt;

&lt;p&gt;但是很多人就是拿来主义，就只管用，博主也是这类人 = =!, 但是随着深入使用Vue，越发觉得深知其原理的重要性，那么，本文来探讨一下Vue的底层原理到底是什么，是怎么实现的。&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="https://tangyanqiong.com/categories/Web/"/>
    
      <category term="Vue" scheme="https://tangyanqiong.com/categories/Web/Vue/"/>
    
    
      <category term="JavaScript" scheme="https://tangyanqiong.com/tags/JavaScript/"/>
    
      <category term="Vue" scheme="https://tangyanqiong.com/tags/Vue/"/>
    
      <category term="MVVM" scheme="https://tangyanqiong.com/tags/MVVM/"/>
    
  </entry>
  
  <entry>
    <title>初探JavaScript的变量</title>
    <link href="https://tangyanqiong.com/post/6e5ac6c0.html"/>
    <id>https://tangyanqiong.com/post/6e5ac6c0.html</id>
    <published>2019-02-25T08:12:34.000Z</published>
    <updated>2019-07-26T09:43:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本类型和引用类型的值"><a href="#基本类型和引用类型的值" class="headerlink" title="基本类型和引用类型的值"></a>基本类型和引用类型的值</h3><p><code>ECMAScript</code>变量一般有两种数据类型的值：<strong>基本类型和引用类型</strong>。</p><ul><li>基本类型： 简单的数据段：<code>Undefined, Null, Boolean, Number, String</code></li><li>引用类型：多个值构成的对象；</li></ul><a id="more"></a><h4 id="1-动态的属性"><a href="#1-动态的属性" class="headerlink" title="1. 动态的属性"></a>1. 动态的属性</h4><p>定义两者的值：创建一个变量并为其变量赋值；</p><p>执行两者的值：</p><ul><li>引用类型：可以添加、删除属性和方法；</li><li>基本类型：不能添加、删除属性和方法；</li></ul><p>比如：引用类型 a，可以添加属性 name age<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">a.name = <span class="string">"杨子龙"</span>;</span><br><span class="line">a.age = <span class="number">24</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a.name);                      <span class="comment">//杨子龙</span></span><br></pre></td></tr></table></figure></p><p>基本类型 name 无法添加属性 age<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"杨子龙"</span>;</span><br><span class="line">name.age  = <span class="number">24</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name.age);                 <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure></p><p>代码中可知：只能给引用类型值动态地添加属性，以便将来使用。</p><h4 id="2-赋值变量值"><a href="#2-赋值变量值" class="headerlink" title="2. 赋值变量值"></a>2. 赋值变量值</h4><p>从一个变量向另一个变量复制基本类型值和引用类型值时：</p><ul><li>基本类型：在变量对象上创建一个新值，并将其值复制给新变量分配的位置上；（完全独立的两个变量）<br>例如：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">111</span>;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line"><span class="built_in">console</span>.log(b);                 <span class="comment">//111</span></span><br></pre></td></tr></table></figure><p>代码中可知：变量b的值只是变量a的值的一个副本，两者的值111是完全独立的。</p><ul><li>引用类型：将存储在变量对象中的值复制一份放到为新变量分配的空间中；（引用同一个对象的两个变量）</li></ul><p>引用类型的值的副本实际是一个指针，指向存储在堆中的一个对象。<br>例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>;</span><br><span class="line"><span class="keyword">var</span> obj2 = obj1;</span><br><span class="line">obj1.name = <span class="string">"杨子龙"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj2,name);                 <span class="comment">// Object &#123; name="杨子龙"&#125; 杨子龙</span></span><br></pre></td></tr></table></figure></p><p>代码中可知：obj1和obj2都指向同一个对象Object；所以，为obj1添加的name属性，通过obj2也可以访问的到。</p><h4 id="3-传递参数"><a href="#3-传递参数" class="headerlink" title="3. 传递参数"></a>3. 传递参数</h4><p>我们都知道基本类型是<strong>按值访问</strong>的，因为可以访问保存在变量中的实际的值。<br>所有函数的参数都是<strong>按值传递</strong>的。</p><ul><li>基本类型：基本类型值的传递如同基本类型变量的复制一样；<br>在向参数传递值，被传递的值会被复制给一个局部变量（命名参数），因此这个局部变量的变化不会反映在函数的外部。</li></ul><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  num += <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> result = fn(a);</span><br><span class="line"><span class="built_in">console</span>.log(result);        <span class="comment">//20</span></span><br><span class="line"><span class="built_in">console</span>.log(a);             <span class="comment">//10</span></span><br></pre></td></tr></table></figure><p>代码中可知：参数num和变量a互不相识，只是有着相同的值而已，用完之后，你还是你，我还是我，互不干政。</p><ul><li>引用类型：引用类型的传递如同引用类型变量的复制一样；<br>在向参数传递值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。</li></ul><p>例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  obj.name = <span class="string">'杨子龙'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">fn(person);</span><br><span class="line"><span class="built_in">console</span>.log(person.name);           <span class="comment">//杨子龙</span></span><br></pre></td></tr></table></figure></p><p>代码中可知：在这个函数内部，参数obj和变量person引用的是同一个对象Object，所以，你不动我也不动，你动我也动，你中有我，我中有你，情义绵绵，经久不息……</p><p>也就是说：即使变量person是按值传递的，但是参数obj（想象成局部变量）还是会按引用来访问同一个对象。</p><blockquote><p> 访问变量有按值和按引用两种方式，参数只能按值传递。</p></blockquote><h4 id="4-检测类型"><a href="#4-检测类型" class="headerlink" title="4. 检测类型"></a>4. 检测类型</h4><ul><li>基本类型：<code>typeof</code></li><li>引用类型：<code>instanceof</code>（对象或null）</li></ul><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'Yang Zilong'</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">24</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">var</span> d = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> e;</span><br><span class="line"><span class="keyword">var</span> g = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">var</span> f = <span class="literal">null</span>;  <span class="comment">// 比较特殊</span></span><br><span class="line"><span class="keyword">var</span> h = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a); <span class="comment">//string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> b); <span class="comment">//number </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> c); <span class="comment">//string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> d); <span class="comment">//boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> e); <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> g); <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> f); <span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> h); <span class="comment">//object</span></span><br></pre></td></tr></table></figure><blockquote><p>所用引用类型的值都是Object的实例。</p></blockquote><p>如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">var</span> num = [<span class="number">1</span>,<span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/.at/i</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>);     <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(num <span class="keyword">instanceof</span> <span class="built_in">Object</span>);        <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(num <span class="keyword">instanceof</span> <span class="built_in">Array</span>);         <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern <span class="keyword">instanceof</span> <span class="built_in">Object</span>);    <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>);    <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><blockquote><p>使用<code>instanceof</code>检测基本类型，会返回<code>false</code>，基本类型不是对象。</p></blockquote><ul><li>参考资料：《JavaScript高级程序设计》（第三版）第四章</li><li>同步于： <a href="https://juejin.im/post/5c73a28cf265da2de52d9390" target="_blank" rel="noopener">掘金</a>、<a href="https://www.imooc.com/article/280082" target="_blank" rel="noopener">慕课网</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基本类型和引用类型的值&quot;&gt;&lt;a href=&quot;#基本类型和引用类型的值&quot; class=&quot;headerlink&quot; title=&quot;基本类型和引用类型的值&quot;&gt;&lt;/a&gt;基本类型和引用类型的值&lt;/h3&gt;&lt;p&gt;&lt;code&gt;ECMAScript&lt;/code&gt;变量一般有两种数据类型的值：&lt;strong&gt;基本类型和引用类型&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本类型： 简单的数据段：&lt;code&gt;Undefined, Null, Boolean, Number, String&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;引用类型：多个值构成的对象；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Web" scheme="https://tangyanqiong.com/categories/Web/"/>
    
      <category term="JS" scheme="https://tangyanqiong.com/categories/Web/JS/"/>
    
    
      <category term="JavaScript" scheme="https://tangyanqiong.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Swift中UILabel设置角标</title>
    <link href="https://tangyanqiong.com/post/f0789496.html"/>
    <id>https://tangyanqiong.com/post/f0789496.html</id>
    <published>2018-12-20T07:10:08.000Z</published>
    <updated>2019-06-06T01:48:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>项目开发中，我们往往会遇到客户提出设置角标的需求，如下图：</p><fancybox><img src="https://i.loli.net/2019/06/03/5cf4c72d425fa66320.png" alt="02B93172-8856-45FA-9591-8430A6D962D2.png"></fancybox><p>这种是怎么实现的呢？</p><a id="more"></a><p>其实也很简单，我们用富文本就能实现这种方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let text = (textLabel.text)!</span><br><span class="line">let attrText = NSMutableAttributedString(string: text)</span><br><span class="line"></span><br><span class="line">var: scaleRange = (text as NSString).range(of: &quot;r&quot;)</span><br><span class="line">attrText.addAttribute(NSAttributedString.Key.font, value: UIFont.systemFont(ofSize: textLabel.font.pointSize*0.8), range: scaleRange) //设置角标的字体大小      </span><br><span class="line">attrText.addAttribute(NSAttributedString.Key.foregroundColor, value: textLabel.textColor, range: scaleRange) //设置角标的字体颜色</span><br><span class="line"></span><br><span class="line">textLabel.attributedText = attrText</span><br></pre></td></tr></table></figure><p>那<strong>-1</strong>在右上角的这种方式又是怎么实现的呢？</p><p>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scaleRange = (text as NSString).range(of: &quot;-1&quot;)</span><br><span class="line">attrText.addAttribute(NSAttributedString.Key.baselineOffset, value: (textLabel.font.pointSize*0.4), range: scaleRange)</span><br></pre></td></tr></table></figure><p><strong>同理，在OC里，同样用富文本也可实现角标显示。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;项目开发中，我们往往会遇到客户提出设置角标的需求，如下图：&lt;/p&gt;
&lt;fancybox&gt;&lt;img src=&quot;https://i.loli.net/2019/06/03/5cf4c72d425fa66320.png&quot; alt=&quot;02B93172-8856-45FA-9591-8430A6D962D2.png&quot;&gt;&lt;/fancybox&gt;

&lt;p&gt;这种是怎么实现的呢？&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://tangyanqiong.com/categories/iOS/"/>
    
      <category term="Swift" scheme="https://tangyanqiong.com/categories/iOS/Swift/"/>
    
    
      <category term="Swift" scheme="https://tangyanqiong.com/tags/Swift/"/>
    
      <category term="角标" scheme="https://tangyanqiong.com/tags/%E8%A7%92%E6%A0%87/"/>
    
  </entry>
  
  <entry>
    <title>Git使用命令行管理</title>
    <link href="https://tangyanqiong.com/post/c0119d4f.html"/>
    <id>https://tangyanqiong.com/post/c0119d4f.html</id>
    <published>2018-12-14T14:45:16.000Z</published>
    <updated>2019-07-26T09:48:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>平时项目中很常用的代码管理工具就是git了，其实有很好的类似SourceTree这样的工具来管理git，但是本文所讲的是通过终端命令行来管理git。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul><li>Workspace: 工作区</li><li>Index / Stage: 暂存区</li><li>Repository: 仓库区（或本地仓库）</li><li>Remote: 远程仓库</li><li><img src="https://user-images.githubusercontent.com/19526072/49999253-4c690980-ffd1-11e8-892a-bff60b374d12.png" alt="image"></li></ul><a id="more"></a><h1 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h1><h3 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在当前目录 git-command 下新建 Git 代码库，（会生成 .git 文件）</span></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建目录 git-command 并将其初始化为 Git 代码库</span></span><br><span class="line">git init git-command</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从线上获取一个完整的项目代码</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/yangtao2o/git-command.git</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>Git的设置文件为 <code>.gitconfig</code> ，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示配置信息</span></span><br><span class="line">git config --list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改</span></span><br><span class="line">git config --global</span><br><span class="line"></span><br><span class="line">git config --global user.name <span class="string">"yangtao"</span></span><br><span class="line">git config --global user.email <span class="string">"xxx@.qq.com"</span></span><br></pre></td></tr></table></figure><h3 id="增加、删除文件"><a href="#增加、删除文件" class="headerlink" title="增加、删除文件"></a>增加、删除文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加指定文件到暂存区</span></span><br><span class="line">git add index.html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加指定目录到暂存区，包括子目录</span></span><br><span class="line">git add assets</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加当前目录的所有文件到暂存区</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加每个变化前，都会要求确认</span></span><br><span class="line"><span class="comment"># 对于同一个文件的多处变化，可以实现分次提交</span></span><br><span class="line">git add -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除工作区文件，并将这次删除加入暂存区</span></span><br><span class="line">git rm [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止追踪指定文件，但该文件会保留在工作区</span></span><br><span class="line">git rm --cached [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改文件名，并放入暂存区</span></span><br><span class="line">git mv index.html index-new.html</span><br></pre></td></tr></table></figure><h3 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 暂存区提交到仓库区 ( -m (msg) )</span></span><br><span class="line">git commit -m <span class="string">"My first commit"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定文件提交</span></span><br><span class="line">git commit [file1] [file2] ... -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交工作区自上次 commit 之后的变化，直接到仓库区</span></span><br><span class="line">git commit -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交时显示所有的 diff 信息</span></span><br><span class="line">git commit -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用一次新的 commit ，提交上一次提交</span></span><br><span class="line"><span class="comment"># 如果代码没有任何变化，则用来改写上一次 commit 的提交信息</span></span><br><span class="line">git commit --amend -m <span class="string">"new commit"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重做上一次 commit ，并包括指定文件的新变化</span></span><br><span class="line">git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有的本地分支</span></span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有的远程分支 ( -r (remotes))</span></span><br><span class="line">git branch -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有的本地分支和远程分支</span></span><br><span class="line">git branch -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，但依然停留在当前分支</span></span><br><span class="line">git branch primary</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建，并切换至 该分支</span></span><br><span class="line">git checkout -b primary-yt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建，指向指定 commit</span></span><br><span class="line">git branch [branch] [commitID]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建，与指定的远程分支建立追踪关系</span></span><br><span class="line">git branch --track [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到指定分支，并更新工作区</span></span><br><span class="line">git checkout [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到上一个分支</span></span><br><span class="line">git checkout -</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立追踪关系，在现有分支与指定的远程分支之间</span></span><br><span class="line">git branch --<span class="built_in">set</span>-upstream [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并指定分支 master-yt 到当前分支 master</span></span><br><span class="line">git merge master-yt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择一个 commit，合并进当前分支</span></span><br><span class="line">git cherry-pick [commitid]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line">git branch -d master-ytt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程分支</span></span><br><span class="line">git push origin --delete [branch-name]</span><br><span class="line">git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出标签</span></span><br><span class="line">git tag</span><br></pre></td></tr></table></figure><h3 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示有变更的文件</span></span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前分支的版本历史</span></span><br><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><h1 id="参考目录"><a href="#参考目录" class="headerlink" title="参考目录"></a>参考目录</h1><ul><li><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">Git常用命令</a></li><li><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">Git教程 - 廖雪峰的官方网站</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;平时项目中很常用的代码管理工具就是git了，其实有很好的类似SourceTree这样的工具来管理git，但是本文所讲的是通过终端命令行来管理git。&lt;/p&gt;
&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Workspace: 工作区&lt;/li&gt;
&lt;li&gt;Index / Stage: 暂存区&lt;/li&gt;
&lt;li&gt;Repository: 仓库区（或本地仓库）&lt;/li&gt;
&lt;li&gt;Remote: 远程仓库&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/19526072/49999253-4c690980-ffd1-11e8-892a-bff60b374d12.png&quot; alt=&quot;image&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Others" scheme="https://tangyanqiong.com/categories/Others/"/>
    
    
      <category term="Git" scheme="https://tangyanqiong.com/tags/Git/"/>
    
      <category term="代码管理工具" scheme="https://tangyanqiong.com/tags/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
</feed>
